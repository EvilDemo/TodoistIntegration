{
  "version": 3,
  "sources": ["<define:__PROJECT_CONFIG__>", "../node_modules/@trigger.dev/core/src/v3/apiClient/index.ts", "../node_modules/@trigger.dev/core/package.json", "../node_modules/@trigger.dev/core/src/v3/schemas/tokens.ts", "../node_modules/@trigger.dev/core/src/v3/schemas/api.ts", "../node_modules/@trigger.dev/core/src/v3/schemas/resources.ts", "../node_modules/@trigger.dev/core/src/v3/schemas/schemas.ts", "../node_modules/@trigger.dev/core/src/v3/schemas/common.ts", "../node_modules/@trigger.dev/core/src/v3/errors.ts", "../node_modules/@trigger.dev/core/src/v3/schemas/messages.ts", "../node_modules/@trigger.dev/core/src/v3/schemas/style.ts", "../node_modules/@trigger.dev/core/src/v3/schemas/fetch.ts", "../node_modules/@trigger.dev/core/src/v3/schemas/eventFilter.ts", "../node_modules/@trigger.dev/core/src/v3/schemas/openTelemetry.ts", "../node_modules/@trigger.dev/core/src/v3/utils/platform.ts", "../node_modules/@trigger.dev/core/src/v3/utils/globals.ts", "../node_modules/@trigger.dev/core/src/v3/semanticInternalAttributes.ts", "../node_modules/@trigger.dev/core/src/v3/taskContext/index.ts", "../node_modules/@trigger.dev/core/src/v3/task-context-api.ts", "../node_modules/@trigger.dev/core/src/v3/apiClient/core.ts", "../node_modules/@trigger.dev/core/src/retry.ts", "../node_modules/@trigger.dev/core/src/v3/utils/retries.ts", "../node_modules/@trigger.dev/core/src/v3/apiClient/errors.ts", "../node_modules/@trigger.dev/core/src/v3/utils/flattenAttributes.ts", "../node_modules/@trigger.dev/core/src/v3/utils/styleAttributes.ts", "../node_modules/@trigger.dev/core/src/v3/apiClient/pagination.ts", "../node_modules/@trigger.dev/core/src/v3/clock/simpleClock.ts", "../node_modules/@trigger.dev/core/src/v3/clock/index.ts", "../node_modules/@trigger.dev/core/src/v3/clock-api.ts", "../node_modules/@trigger.dev/core/src/v3/limits.ts", "../node_modules/@trigger.dev/core/src/v3/logger/taskLogger.ts", "../node_modules/@trigger.dev/core/src/v3/logger/index.ts", "../node_modules/@trigger.dev/core/src/v3/logger-api.ts", "../node_modules/@trigger.dev/core/src/v3/runtime/noopRuntimeManager.ts", "../node_modules/@trigger.dev/core/src/v3/usage/noopUsageManager.ts", "../node_modules/@trigger.dev/core/src/v3/usage/api.ts", "../node_modules/@trigger.dev/core/src/v3/usage-api.ts", "../node_modules/@trigger.dev/core/src/v3/runtime/index.ts", "../node_modules/@trigger.dev/core/src/v3/runtime-api.ts", "../node_modules/@trigger.dev/core/src/v3/utils/getEnv.ts", "../node_modules/@trigger.dev/core/src/v3/apiClientManager/index.ts", "../node_modules/@trigger.dev/core/src/v3/apiClientManager-api.ts", "../node_modules/@trigger.dev/core/src/v3/task-catalog/noopTaskCatalog.ts", "../node_modules/@trigger.dev/core/src/v3/task-catalog/index.ts", "../node_modules/@trigger.dev/core/src/v3/task-catalog-api.ts", "../node_modules/@trigger.dev/core/src/v3/utils/durations.ts", "../node_modules/@trigger.dev/core/src/v3/tracer.ts", "../node_modules/@trigger.dev/core/src/eventFilterMatches.ts", "../node_modules/@trigger.dev/core/src/v3/utils/omit.ts", "../node_modules/@trigger.dev/core/src/v3/utils/detectDependencyVersion.ts", "../node_modules/@trigger.dev/core/src/v3/utils/ioSerialization.ts", "../node_modules/@trigger.dev/core/src/v3/workers/taskExecutor.ts", "../node_modules/@trigger.dev/core/src/v3/errors.ts", "../node_modules/@trigger.dev/core/src/v3/otel/index.ts", "../node_modules/@trigger.dev/core/src/v3/otel/tracingSDK.ts", "../node_modules/@trigger.dev/core/src/v3/limits.ts", "../node_modules/@trigger.dev/core/src/v3/semanticInternalAttributes.ts", "../node_modules/@trigger.dev/core/src/v3/utils/flattenAttributes.ts", "../node_modules/@trigger.dev/core/src/v3/utils/platform.ts", "../node_modules/@trigger.dev/core/src/v3/utils/globals.ts", "../node_modules/@trigger.dev/core/src/v3/taskContext/index.ts", "../node_modules/@trigger.dev/core/src/v3/task-context-api.ts", "../node_modules/@trigger.dev/core/src/v3/taskContext/otelProcessors.ts", "../node_modules/@trigger.dev/core/src/v3/utils/getEnv.ts", "../node_modules/@trigger.dev/core/package.json", "../node_modules/@trigger.dev/core/src/v3/schemas/api.ts", "../node_modules/@trigger.dev/core/src/v3/schemas/resources.ts", "../node_modules/@trigger.dev/core/src/v3/schemas/schemas.ts", "../node_modules/@trigger.dev/core/src/v3/schemas/common.ts", "../node_modules/@trigger.dev/core/src/v3/apiClient/index.ts", "../node_modules/@trigger.dev/core/src/v3/apiClient/core.ts", "../node_modules/@trigger.dev/core/src/v3/utils/retries.ts", "../node_modules/@trigger.dev/core/src/v3/apiClient/errors.ts", "../node_modules/@trigger.dev/core/src/v3/utils/styleAttributes.ts", "../node_modules/@trigger.dev/core/src/v3/apiClient/pagination.ts", "../node_modules/@trigger.dev/core/src/v3/apiClientManager/index.ts", "../node_modules/@trigger.dev/core/src/v3/apiClientManager-api.ts", "../node_modules/@trigger.dev/core/src/v3/utils/ioSerialization.ts", "../node_modules/@trigger.dev/core/src/v3/clock/preciseWallClock.ts", "../node_modules/@trigger.dev/core/src/v3/logger/taskLogger.ts", "../node_modules/@trigger.dev/core/src/v3/icons.ts", "../node_modules/@trigger.dev/core/src/v3/clock/simpleClock.ts", "../node_modules/@trigger.dev/core/src/v3/clock/index.ts", "../node_modules/@trigger.dev/core/src/v3/clock-api.ts", "../node_modules/@trigger.dev/core/src/v3/consoleInterceptor.ts", "../node_modules/@trigger.dev/core/src/v3/task-catalog/standardTaskCatalog.ts", "../node_modules/@trigger.dev/core/src/v3/usage/noopUsageManager.ts", "../node_modules/@trigger.dev/core/src/v3/usage/api.ts", "../node_modules/@trigger.dev/core/src/v3/usage-api.ts", "../node_modules/@trigger.dev/core/src/v3/clock/clock.ts", "../node_modules/@trigger.dev/core/src/v3/usage/devUsageManager.ts", "../node_modules/@trigger.dev/core/src/v3/usage/prodUsageManager.ts", "../node_modules/@trigger.dev/core/src/v3/usage/usageClient.ts", "../node_modules/@trigger.dev/core/src/v3/utils/timers.ts", "../node_modules/@trigger.dev/core/src/v3/runtime/devRuntimeManager.ts", "../node_modules/@trigger.dev/core/src/v3/zodMessageHandler.ts", "../__entryPoint.ts", "../../../../.npm/_npx/615bebf0b780b73f/node_modules/trigger.dev/dist/workers/dev/worker-setup.js", "../trigger.config.ts", "../src/trigger/todoist.ts", "../node_modules/@trigger.dev/core/src/schemas/api.ts", "../node_modules/@trigger.dev/core/src/schemas/addMissingVersionField.ts", "../node_modules/@trigger.dev/core/src/schemas/errors.ts", "../node_modules/@trigger.dev/core/src/schemas/eventFilter.ts", "../node_modules/@trigger.dev/core/src/schemas/integrations.ts", "../node_modules/@trigger.dev/core/src/schemas/json.ts", "../node_modules/@trigger.dev/core/src/schemas/properties.ts", "../node_modules/@trigger.dev/core/src/schemas/schedules.ts", "../node_modules/@trigger.dev/core/src/schemas/tasks.ts", "../node_modules/@trigger.dev/core/src/schemas/triggers.ts", "../node_modules/@trigger.dev/core/src/schemas/runs.ts", "../node_modules/@trigger.dev/core/src/schemas/statuses.ts", "../node_modules/@trigger.dev/core/src/schemas/requestFilter.ts", "../node_modules/@trigger.dev/core/src/schemas/notifications.ts", "../node_modules/@trigger.dev/core/src/schemas/fetch.ts", "../node_modules/@trigger.dev/core/src/schemas/events.ts", "../node_modules/@trigger.dev/core/src/schemas/request.ts", "../node_modules/@trigger.dev/core/src/schemas/jobs.ts", "../node_modules/@trigger.dev/core/src/utils.ts", "../node_modules/@trigger.dev/core/src/retry.ts", "../node_modules/@trigger.dev/core/src/replacements.ts", "../node_modules/@trigger.dev/core/src/searchParams.ts", "../node_modules/@trigger.dev/core/src/eventFilterMatches.ts", "../node_modules/@trigger.dev/core/src/requestFilterMatches.ts", "../node_modules/@trigger.dev/core/src/versions.ts", "../node_modules/@trigger.dev/core-backend/src/bloom.ts", "../node_modules/@trigger.dev/core-backend/src/logger.ts", "../node_modules/@trigger.dev/sdk/src/utils/typedAsyncLocalStorage.ts", "../node_modules/@trigger.dev/sdk/src/runLocalStorage.ts", "../node_modules/@trigger.dev/sdk/src/utils.ts", "../node_modules/@trigger.dev/sdk/src/job.ts", "../node_modules/@trigger.dev/sdk/src/triggerClient.ts", "../node_modules/@trigger.dev/sdk/package.json", "../node_modules/@trigger.dev/sdk/src/apiClient.ts", "../node_modules/@trigger.dev/sdk/src/io.ts", "../node_modules/@trigger.dev/sdk/src/errors.ts", "../node_modules/@trigger.dev/sdk/src/retry.ts", "../node_modules/@trigger.dev/sdk/src/status.ts", "../node_modules/@trigger.dev/sdk/src/types.ts", "../node_modules/@trigger.dev/sdk/src/store/keyValueStore.ts", "../node_modules/@trigger.dev/sdk/src/store/keyValueStoreClient.ts", "../node_modules/@trigger.dev/sdk/src/concurrencyLimit.ts", "../node_modules/@trigger.dev/sdk/src/httpEndpoint.ts", "../node_modules/@trigger.dev/sdk/src/utils/formatSchemaErrors.ts", "../node_modules/@trigger.dev/sdk/src/ioWithIntegrations.ts", "../node_modules/@trigger.dev/sdk/src/triggers/dynamic.ts", "../node_modules/@trigger.dev/sdk/src/triggers/eventTrigger.ts", "../node_modules/@trigger.dev/sdk/src/triggers/scheduled.ts", "../node_modules/@trigger.dev/sdk/src/triggers/externalSource.ts", "../node_modules/@trigger.dev/sdk/src/triggers/notifications.ts", "../node_modules/@trigger.dev/sdk/src/triggers/invokeTrigger.ts", "../node_modules/@trigger.dev/sdk/src/triggers/webhook.ts", "../node_modules/@trigger.dev/sdk/src/security.ts", "../node_modules/@trigger.dev/sdk/src/index.ts"],
  "sourcesContent": ["", "import { context, propagation } from \"@opentelemetry/api\";\nimport { z } from \"zod\";\nimport { version } from \"../../../package.json\";\nimport {\n  AddTagsRequestBody,\n  BatchTaskRunExecutionResult,\n  BatchTriggerTaskRequestBody,\n  BatchTriggerTaskResponse,\n  CanceledRunResponse,\n  CreateEnvironmentVariableRequestBody,\n  CreateScheduleOptions,\n  CreateUploadPayloadUrlResponseBody,\n  DeletedScheduleObject,\n  EnvironmentVariableResponseBody,\n  EnvironmentVariableValue,\n  EnvironmentVariables,\n  ListRunResponseItem,\n  ListScheduleOptions,\n  ReplayRunResponse,\n  RescheduleRunRequestBody,\n  RetrieveRunResponse,\n  ScheduleObject,\n  TaskRunExecutionResult,\n  TriggerTaskRequestBody,\n  TriggerTaskResponse,\n  UpdateEnvironmentVariableRequestBody,\n  UpdateScheduleOptions,\n} from \"../schemas\";\nimport { taskContext } from \"../task-context-api\";\nimport {\n  ApiRequestOptions,\n  CursorPagePromise,\n  ZodFetchOptions,\n  isRequestOptions,\n  zodfetch,\n  zodfetchCursorPage,\n  zodfetchOffsetLimitPage,\n} from \"./core\";\nimport { ApiError } from \"./errors\";\nimport {\n  CreateEnvironmentVariableParams,\n  ImportEnvironmentVariablesParams,\n  ListProjectRunsQueryParams,\n  ListRunsQueryParams,\n  UpdateEnvironmentVariableParams,\n} from \"./types\";\n\nexport type {\n  CreateEnvironmentVariableParams,\n  ImportEnvironmentVariablesParams,\n  UpdateEnvironmentVariableParams,\n};\n\nexport type TriggerOptions = {\n  spanParentAsLink?: boolean;\n};\n\nconst DEFAULT_ZOD_FETCH_OPTIONS: ZodFetchOptions = {\n  retry: {\n    maxAttempts: 3,\n    minTimeoutInMs: 1000,\n    maxTimeoutInMs: 30_000,\n    factor: 2,\n    randomize: false,\n  },\n};\n\nexport { isRequestOptions };\nexport type { ApiRequestOptions };\n\n/**\n * Trigger.dev v3 API client\n */\nexport class ApiClient {\n  private readonly baseUrl: string;\n  private readonly defaultRequestOptions: ZodFetchOptions;\n\n  constructor(\n    baseUrl: string,\n    private readonly accessToken: string,\n    requestOptions: ApiRequestOptions = {}\n  ) {\n    this.baseUrl = baseUrl.replace(/\\/$/, \"\");\n    this.defaultRequestOptions = mergeRequestOptions(DEFAULT_ZOD_FETCH_OPTIONS, requestOptions);\n  }\n\n  async getRunResult(\n    runId: string,\n    requestOptions?: ZodFetchOptions\n  ): Promise<TaskRunExecutionResult | undefined> {\n    try {\n      return await zodfetch(\n        TaskRunExecutionResult,\n        `${this.baseUrl}/api/v1/runs/${runId}/result`,\n        {\n          method: \"GET\",\n          headers: this.#getHeaders(false),\n        },\n        mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n      );\n    } catch (error) {\n      if (error instanceof ApiError) {\n        if (error.status === 404) {\n          return undefined;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  async getBatchResults(\n    batchId: string,\n    requestOptions?: ZodFetchOptions\n  ): Promise<BatchTaskRunExecutionResult | undefined> {\n    return await zodfetch(\n      BatchTaskRunExecutionResult,\n      `${this.baseUrl}/api/v1/batches/${batchId}/results`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  triggerTask(\n    taskId: string,\n    body: TriggerTaskRequestBody,\n    options?: TriggerOptions,\n    requestOptions?: ZodFetchOptions\n  ) {\n    const encodedTaskId = encodeURIComponent(taskId);\n\n    return zodfetch(\n      TriggerTaskResponse,\n      `${this.baseUrl}/api/v1/tasks/${encodedTaskId}/trigger`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(options?.spanParentAsLink ?? false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  batchTriggerTask(\n    taskId: string,\n    body: BatchTriggerTaskRequestBody,\n    options?: TriggerOptions,\n    requestOptions?: ZodFetchOptions\n  ) {\n    const encodedTaskId = encodeURIComponent(taskId);\n\n    return zodfetch(\n      BatchTriggerTaskResponse,\n      `${this.baseUrl}/api/v1/tasks/${encodedTaskId}/batch`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(options?.spanParentAsLink ?? false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  createUploadPayloadUrl(filename: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      CreateUploadPayloadUrlResponseBody,\n      `${this.baseUrl}/api/v1/packets/${filename}`,\n      {\n        method: \"PUT\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  getPayloadUrl(filename: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      CreateUploadPayloadUrlResponseBody,\n      `${this.baseUrl}/api/v1/packets/${filename}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  retrieveRun(runId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      RetrieveRunResponse,\n      `${this.baseUrl}/api/v3/runs/${runId}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listRuns(\n    query?: ListRunsQueryParams,\n    requestOptions?: ZodFetchOptions\n  ): CursorPagePromise<typeof ListRunResponseItem> {\n    const searchParams = createSearchQueryForListRuns(query);\n\n    return zodfetchCursorPage(\n      ListRunResponseItem,\n      `${this.baseUrl}/api/v1/runs`,\n      {\n        query: searchParams,\n        limit: query?.limit,\n        after: query?.after,\n        before: query?.before,\n      },\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listProjectRuns(\n    projectRef: string,\n    query?: ListProjectRunsQueryParams,\n    requestOptions?: ZodFetchOptions\n  ): CursorPagePromise<typeof ListRunResponseItem> {\n    const searchParams = createSearchQueryForListRuns(query);\n\n    if (query?.env) {\n      searchParams.append(\n        \"filter[env]\",\n        Array.isArray(query.env) ? query.env.join(\",\") : query.env\n      );\n    }\n\n    return zodfetchCursorPage(\n      ListRunResponseItem,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/runs`,\n      {\n        query: searchParams,\n        limit: query?.limit,\n        after: query?.after,\n        before: query?.before,\n      },\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  replayRun(runId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ReplayRunResponse,\n      `${this.baseUrl}/api/v1/runs/${runId}/replay`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  cancelRun(runId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      CanceledRunResponse,\n      `${this.baseUrl}/api/v2/runs/${runId}/cancel`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  rescheduleRun(runId: string, body: RescheduleRunRequestBody, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      RetrieveRunResponse,\n      `${this.baseUrl}/api/v1/runs/${runId}/reschedule`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  addTags(runId: string, body: AddTagsRequestBody, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      z.object({ message: z.string() }),\n      `${this.baseUrl}/api/v1/runs/${runId}/tags`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  createSchedule(options: CreateScheduleOptions, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(options),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listSchedules(options?: ListScheduleOptions, requestOptions?: ZodFetchOptions) {\n    const searchParams = new URLSearchParams();\n\n    if (options?.page) {\n      searchParams.append(\"page\", options.page.toString());\n    }\n\n    if (options?.perPage) {\n      searchParams.append(\"perPage\", options.perPage.toString());\n    }\n\n    return zodfetchOffsetLimitPage(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules`,\n      {\n        page: options?.page,\n        limit: options?.perPage,\n      },\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  retrieveSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  updateSchedule(\n    scheduleId: string,\n    options: UpdateScheduleOptions,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}`,\n      {\n        method: \"PUT\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(options),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  deactivateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}/deactivate`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  activateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}/activate`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  deleteSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      DeletedScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}`,\n      {\n        method: \"DELETE\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listEnvVars(projectRef: string, slug: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      EnvironmentVariables,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  importEnvVars(\n    projectRef: string,\n    slug: string,\n    body: ImportEnvironmentVariablesParams,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/import`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  retrieveEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      EnvironmentVariableValue,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  createEnvVar(\n    projectRef: string,\n    slug: string,\n    body: CreateEnvironmentVariableRequestBody,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  updateEnvVar(\n    projectRef: string,\n    slug: string,\n    key: string,\n    body: UpdateEnvironmentVariableRequestBody,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`,\n      {\n        method: \"PUT\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  deleteEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`,\n      {\n        method: \"DELETE\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  #getHeaders(spanParentAsLink: boolean) {\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.accessToken}`,\n      \"trigger-version\": version,\n    };\n\n    // Only inject the context if we are inside a task\n    if (taskContext.isInsideTask) {\n      headers[\"x-trigger-worker\"] = \"true\";\n      propagation.inject(context.active(), headers);\n\n      if (spanParentAsLink) {\n        headers[\"x-trigger-span-parent-as-link\"] = \"1\";\n      }\n    }\n\n    return headers;\n  }\n}\n\nfunction createSearchQueryForListRuns(query?: ListRunsQueryParams): URLSearchParams {\n  const searchParams = new URLSearchParams();\n\n  if (query) {\n    if (query.status) {\n      searchParams.append(\n        \"filter[status]\",\n        Array.isArray(query.status) ? query.status.join(\",\") : query.status\n      );\n    }\n\n    if (query.taskIdentifier) {\n      searchParams.append(\n        \"filter[taskIdentifier]\",\n        Array.isArray(query.taskIdentifier) ? query.taskIdentifier.join(\",\") : query.taskIdentifier\n      );\n    }\n\n    if (query.version) {\n      searchParams.append(\n        \"filter[version]\",\n        Array.isArray(query.version) ? query.version.join(\",\") : query.version\n      );\n    }\n\n    if (query.bulkAction) {\n      searchParams.append(\"filter[bulkAction]\", query.bulkAction);\n    }\n\n    if (query.tag) {\n      searchParams.append(\n        \"filter[tag]\",\n        Array.isArray(query.tag) ? query.tag.join(\",\") : query.tag\n      );\n    }\n\n    if (query.schedule) {\n      searchParams.append(\"filter[schedule]\", query.schedule);\n    }\n\n    if (typeof query.isTest === \"boolean\") {\n      searchParams.append(\"filter[isTest]\", String(query.isTest));\n    }\n\n    if (query.from) {\n      searchParams.append(\n        \"filter[createdAt][from]\",\n        query.from instanceof Date ? query.from.getTime().toString() : query.from.toString()\n      );\n    }\n\n    if (query.to) {\n      searchParams.append(\n        \"filter[createdAt][to]\",\n        query.to instanceof Date ? query.to.getTime().toString() : query.to.toString()\n      );\n    }\n\n    if (query.period) {\n      searchParams.append(\"filter[createdAt][period]\", query.period);\n    }\n  }\n\n  return searchParams;\n}\n\nexport function mergeRequestOptions(\n  defaultOptions: ZodFetchOptions,\n  options?: ApiRequestOptions\n): ZodFetchOptions {\n  if (!options) {\n    return defaultOptions;\n  }\n\n  return {\n    ...defaultOptions,\n    ...options,\n    retry: {\n      ...defaultOptions.retry,\n      ...options.retry,\n    },\n  };\n}\n", "{\n  \"name\": \"@trigger.dev/core\",\n  \"version\": \"3.0.0-beta.56\",\n  \"description\": \"Core code used across the Trigger.dev SDK and platform\",\n  \"license\": \"MIT\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"module\": \"./dist/index.mjs\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"import\": {\n        \"types\": \"./dist/index.d.mts\",\n        \"default\": \"./dist/index.mjs\"\n      },\n      \"require\": \"./dist/index.js\",\n      \"types\": \"./dist/index.d.ts\"\n    },\n    \"./eventFilterMatches\": {\n      \"import\": {\n        \"types\": \"./dist/eventFilterMatches.d.mts\",\n        \"default\": \"./dist/eventFilterMatches.mjs\"\n      },\n      \"require\": \"./dist/eventFilterMatches.js\",\n      \"types\": \"./dist/eventFilterMatches.d.ts\"\n    },\n    \"./replacements\": {\n      \"import\": {\n        \"types\": \"./dist/replacements.d.mts\",\n        \"default\": \"./dist/replacements.mjs\"\n      },\n      \"require\": \"./dist/replacements.js\",\n      \"types\": \"./dist/replacements.d.ts\"\n    },\n    \"./requestFilterMatches\": {\n      \"import\": {\n        \"types\": \"./dist/requestFilterMatches.d.mts\",\n        \"default\": \"./dist/requestFilterMatches.mjs\"\n      },\n      \"require\": \"./dist/requestFilterMatches.js\",\n      \"types\": \"./dist/requestFilterMatches.d.ts\"\n    },\n    \"./retry\": {\n      \"import\": {\n        \"types\": \"./dist/retry.d.mts\",\n        \"default\": \"./dist/retry.mjs\"\n      },\n      \"require\": \"./dist/retry.js\",\n      \"types\": \"./dist/retry.d.ts\"\n    },\n    \"./utils\": {\n      \"import\": {\n        \"types\": \"./dist/utils.d.mts\",\n        \"default\": \"./dist/utils.mjs\"\n      },\n      \"require\": \"./dist/utils.js\",\n      \"types\": \"./dist/utils.d.ts\"\n    },\n    \"./schemas\": {\n      \"import\": {\n        \"types\": \"./dist/schemas/index.d.mts\",\n        \"default\": \"./dist/schemas/index.mjs\"\n      },\n      \"require\": \"./dist/schemas/index.js\",\n      \"types\": \"./dist/schemas/index.d.ts\"\n    },\n    \"./types\": {\n      \"import\": {\n        \"types\": \"./dist/types.d.mts\",\n        \"default\": \"./dist/types.mjs\"\n      },\n      \"require\": \"./dist/types.js\",\n      \"types\": \"./dist/types.d.ts\"\n    },\n    \"./versions\": {\n      \"import\": {\n        \"types\": \"./dist/versions.d.mts\",\n        \"default\": \"./dist/versions.mjs\"\n      },\n      \"require\": \"./dist/versions.js\",\n      \"types\": \"./dist/versions.d.ts\"\n    },\n    \"./v3\": {\n      \"import\": {\n        \"types\": \"./dist/v3/index.d.mts\",\n        \"default\": \"./dist/v3/index.mjs\"\n      },\n      \"require\": \"./dist/v3/index.js\",\n      \"types\": \"./dist/v3/index.d.ts\"\n    },\n    \"./v3/errors\": {\n      \"import\": {\n        \"types\": \"./dist/v3/errors.d.mts\",\n        \"default\": \"./dist/v3/errors.mjs\"\n      },\n      \"require\": \"./dist/v3/errors.js\",\n      \"types\": \"./dist/v3/errors.d.ts\"\n    },\n    \"./v3/logger-api\": {\n      \"import\": {\n        \"types\": \"./dist/v3/logger-api.d.mts\",\n        \"default\": \"./dist/v3/logger-api.mjs\"\n      },\n      \"require\": \"./dist/v3/logger-api.js\",\n      \"types\": \"./dist/v3/logger-api.d.ts\"\n    },\n    \"./v3/otel\": {\n      \"import\": {\n        \"types\": \"./dist/v3/otel/index.d.mts\",\n        \"default\": \"./dist/v3/otel/index.mjs\"\n      },\n      \"require\": \"./dist/v3/otel/index.js\",\n      \"types\": \"./dist/v3/otel/index.d.ts\"\n    },\n    \"./v3/semanticInternalAttributes\": {\n      \"import\": {\n        \"types\": \"./dist/v3/semanticInternalAttributes.d.mts\",\n        \"default\": \"./dist/v3/semanticInternalAttributes.mjs\"\n      },\n      \"require\": \"./dist/v3/semanticInternalAttributes.js\",\n      \"types\": \"./dist/v3/semanticInternalAttributes.d.ts\"\n    },\n    \"./v3/utils/durations\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/durations.d.mts\",\n        \"default\": \"./dist/v3/utils/durations.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/durations.js\",\n      \"types\": \"./dist/v3/utils/durations.d.ts\"\n    },\n    \"./v3/utils/flattenAttributes\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/flattenAttributes.d.mts\",\n        \"default\": \"./dist/v3/utils/flattenAttributes.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/flattenAttributes.js\",\n      \"types\": \"./dist/v3/utils/flattenAttributes.d.ts\"\n    },\n    \"./v3/utils/ioSerialization\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/ioSerialization.d.mts\",\n        \"default\": \"./dist/v3/utils/ioSerialization.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/ioSerialization.js\",\n      \"types\": \"./dist/v3/utils/ioSerialization.d.ts\"\n    },\n    \"./v3/utils/omit\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/omit.d.mts\",\n        \"default\": \"./dist/v3/utils/omit.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/omit.js\",\n      \"types\": \"./dist/v3/utils/omit.d.ts\"\n    },\n    \"./v3/utils/retries\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/retries.d.mts\",\n        \"default\": \"./dist/v3/utils/retries.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/retries.js\",\n      \"types\": \"./dist/v3/utils/retries.d.ts\"\n    },\n    \"./v3/utils/structuredLogger\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/structuredLogger.d.mts\",\n        \"default\": \"./dist/v3/utils/structuredLogger.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/structuredLogger.js\",\n      \"types\": \"./dist/v3/utils/structuredLogger.d.ts\"\n    },\n    \"./v3/zodfetch\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodfetch.d.mts\",\n        \"default\": \"./dist/v3/zodfetch.mjs\"\n      },\n      \"require\": \"./dist/v3/zodfetch.js\",\n      \"types\": \"./dist/v3/zodfetch.d.ts\"\n    },\n    \"./v3/zodMessageHandler\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodMessageHandler.d.mts\",\n        \"default\": \"./dist/v3/zodMessageHandler.mjs\"\n      },\n      \"require\": \"./dist/v3/zodMessageHandler.js\",\n      \"types\": \"./dist/v3/zodMessageHandler.d.ts\"\n    },\n    \"./v3/zodNamespace\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodNamespace.d.mts\",\n        \"default\": \"./dist/v3/zodNamespace.mjs\"\n      },\n      \"require\": \"./dist/v3/zodNamespace.js\",\n      \"types\": \"./dist/v3/zodNamespace.d.ts\"\n    },\n    \"./v3/zodSocket\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodSocket.d.mts\",\n        \"default\": \"./dist/v3/zodSocket.mjs\"\n      },\n      \"require\": \"./dist/v3/zodSocket.js\",\n      \"types\": \"./dist/v3/zodSocket.d.ts\"\n    },\n    \"./v3/zodIpc\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodIpc.d.mts\",\n        \"default\": \"./dist/v3/zodIpc.mjs\"\n      },\n      \"require\": \"./dist/v3/zodIpc.js\",\n      \"types\": \"./dist/v3/zodIpc.d.ts\"\n    },\n    \"./v3/utils/timers\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/timers.d.mts\",\n        \"default\": \"./dist/v3/utils/timers.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/timers.js\",\n      \"types\": \"./dist/v3/utils/timers.d.ts\"\n    },\n    \"./v3/dev\": {\n      \"import\": {\n        \"types\": \"./dist/v3/dev/index.d.mts\",\n        \"default\": \"./dist/v3/dev/index.mjs\"\n      },\n      \"require\": \"./dist/v3/dev/index.js\",\n      \"types\": \"./dist/v3/dev/index.d.ts\"\n    },\n    \"./v3/prod\": {\n      \"import\": {\n        \"types\": \"./dist/v3/prod/index.d.mts\",\n        \"default\": \"./dist/v3/prod/index.mjs\"\n      },\n      \"require\": \"./dist/v3/prod/index.js\",\n      \"types\": \"./dist/v3/prod/index.d.ts\"\n    },\n    \"./v3/workers\": {\n      \"import\": {\n        \"types\": \"./dist/v3/workers/index.d.mts\",\n        \"default\": \"./dist/v3/workers/index.mjs\"\n      },\n      \"require\": \"./dist/v3/workers/index.js\",\n      \"types\": \"./dist/v3/workers/index.d.ts\"\n    },\n    \"./v3/schemas\": {\n      \"import\": {\n        \"types\": \"./dist/v3/schemas/index.d.mts\",\n        \"default\": \"./dist/v3/schemas/index.mjs\"\n      },\n      \"require\": \"./dist/v3/schemas/index.js\",\n      \"types\": \"./dist/v3/schemas/index.d.ts\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"v3\": [\n        \"./dist/v3/index.d.ts\"\n      ],\n      \"v3/otel\": [\n        \"./dist/v3/otel/index.d.ts\"\n      ]\n    }\n  },\n  \"sideEffects\": false,\n  \"scripts\": {\n    \"clean\": \"rimraf dist\",\n    \"build\": \"npm run clean && npm run build:tsup\",\n    \"build:tsup\": \"tsup --dts-resolve\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"test\": \"jest\"\n  },\n  \"dependencies\": {\n    \"@google-cloud/precise-date\": \"^4.0.0\",\n    \"@opentelemetry/api\": \"^1.8.0\",\n    \"@opentelemetry/api-logs\": \"^0.48.0\",\n    \"@opentelemetry/exporter-logs-otlp-http\": \"^0.49.1\",\n    \"@opentelemetry/exporter-trace-otlp-http\": \"^0.49.1\",\n    \"@opentelemetry/instrumentation\": \"^0.49.1\",\n    \"@opentelemetry/resources\": \"^1.22.0\",\n    \"@opentelemetry/sdk-logs\": \"^0.49.1\",\n    \"@opentelemetry/sdk-node\": \"^0.49.1\",\n    \"@opentelemetry/sdk-trace-base\": \"^1.22.0\",\n    \"@opentelemetry/sdk-trace-node\": \"^1.22.0\",\n    \"@opentelemetry/semantic-conventions\": \"^1.22.0\",\n    \"humanize-duration\": \"^3.27.3\",\n    \"socket.io-client\": \"4.7.5\",\n    \"superjson\": \"^2.2.1\",\n    \"ulidx\": \"^2.2.1\",\n    \"zod\": \"3.22.3\",\n    \"zod-error\": \"1.5.0\",\n    \"zod-validation-error\": \"^1.5.0\"\n  },\n  \"devDependencies\": {\n    \"@trigger.dev/tsconfig\": \"workspace:*\",\n    \"@trigger.dev/tsup\": \"workspace:*\",\n    \"@types/humanize-duration\": \"^3.27.1\",\n    \"@types/jest\": \"^29.5.3\",\n    \"@types/node\": \"20.12.7\",\n    \"@types/readable-stream\": \"^4.0.14\",\n    \"jest\": \"^29.6.2\",\n    \"rimraf\": \"^3.0.2\",\n    \"socket.io\": \"4.7.4\",\n    \"ts-jest\": \"^29.1.1\",\n    \"tsup\": \"^8.0.1\",\n    \"typescript\": \"^5.3.0\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  }\n}", "import { z } from \"zod\";\n\nexport const CreateAuthorizationCodeResponseSchema = z.object({\n  url: z.string().url(),\n  authorizationCode: z.string(),\n});\n\nexport type CreateAuthorizationCodeResponse = z.infer<typeof CreateAuthorizationCodeResponseSchema>;\n\nexport const GetPersonalAccessTokenRequestSchema = z.object({\n  authorizationCode: z.string(),\n});\nexport type GetPersonalAccessTokenRequest = z.infer<typeof GetPersonalAccessTokenRequestSchema>;\n\nexport const GetPersonalAccessTokenResponseSchema = z.object({\n  token: z\n    .object({\n      token: z.string(),\n      obfuscatedToken: z.string(),\n    })\n    .nullable(),\n});\nexport type GetPersonalAccessTokenResponse = z.infer<typeof GetPersonalAccessTokenResponseSchema>;\n", "import { z } from \"zod\";\nimport { BackgroundWorkerMetadata, ImageDetailsMetadata } from \"./resources\";\nimport { QueueOptions } from \"./schemas\";\nimport { SerializedError } from \"../errors\";\n\nexport const WhoAmIResponseSchema = z.object({\n  userId: z.string(),\n  email: z.string().email(),\n  dashboardUrl: z.string(),\n});\n\nexport type WhoAmIResponse = z.infer<typeof WhoAmIResponseSchema>;\n\nexport const GetProjectResponseBody = z.object({\n  id: z.string(),\n  externalRef: z.string(),\n  name: z.string(),\n  slug: z.string(),\n  createdAt: z.coerce.date(),\n  organization: z.object({\n    id: z.string(),\n    title: z.string(),\n    slug: z.string(),\n    createdAt: z.coerce.date(),\n  }),\n});\n\nexport type GetProjectResponseBody = z.infer<typeof GetProjectResponseBody>;\n\nexport const GetProjectsResponseBody = z.array(GetProjectResponseBody);\n\nexport type GetProjectsResponseBody = z.infer<typeof GetProjectsResponseBody>;\n\nexport const GetProjectEnvResponse = z.object({\n  apiKey: z.string(),\n  name: z.string(),\n  apiUrl: z.string(),\n});\n\nexport type GetProjectEnvResponse = z.infer<typeof GetProjectEnvResponse>;\n\nexport const CreateBackgroundWorkerRequestBody = z.object({\n  localOnly: z.boolean(),\n  metadata: BackgroundWorkerMetadata,\n  supportsLazyAttempts: z.boolean().optional(),\n});\n\nexport type CreateBackgroundWorkerRequestBody = z.infer<typeof CreateBackgroundWorkerRequestBody>;\n\nexport const CreateBackgroundWorkerResponse = z.object({\n  id: z.string(),\n  version: z.string(),\n  contentHash: z.string(),\n});\n\nexport type CreateBackgroundWorkerResponse = z.infer<typeof CreateBackgroundWorkerResponse>;\n\n//an array of 1, 2, or 3 strings\nconst RunTag = z.string().max(64, \"Tags must be less than 64 characters\");\nexport const RunTags = z.union([RunTag, RunTag.array()]);\n\nexport type RunTags = z.infer<typeof RunTags>;\n\nexport const TriggerTaskRequestBody = z.object({\n  payload: z.any(),\n  context: z.any(),\n  options: z\n    .object({\n      dependentAttempt: z.string().optional(),\n      dependentBatch: z.string().optional(),\n      lockToVersion: z.string().optional(),\n      queue: QueueOptions.optional(),\n      concurrencyKey: z.string().optional(),\n      idempotencyKey: z.string().optional(),\n      test: z.boolean().optional(),\n      payloadType: z.string().optional(),\n      delay: z.string().or(z.coerce.date()).optional(),\n      ttl: z.string().or(z.number().nonnegative().int()).optional(),\n      tags: RunTags.optional(),\n      maxAttempts: z.number().int().optional(),\n    })\n    .optional(),\n});\n\nexport type TriggerTaskRequestBody = z.infer<typeof TriggerTaskRequestBody>;\n\nexport const TriggerTaskResponse = z.object({\n  id: z.string(),\n});\n\nexport type TriggerTaskResponse = z.infer<typeof TriggerTaskResponse>;\n\nexport const BatchTriggerTaskRequestBody = z.object({\n  items: TriggerTaskRequestBody.array(),\n  dependentAttempt: z.string().optional(),\n});\n\nexport type BatchTriggerTaskRequestBody = z.infer<typeof BatchTriggerTaskRequestBody>;\n\nexport const BatchTriggerTaskResponse = z.object({\n  batchId: z.string(),\n  runs: z.string().array(),\n});\n\nexport type BatchTriggerTaskResponse = z.infer<typeof BatchTriggerTaskResponse>;\n\nexport const GetBatchResponseBody = z.object({\n  id: z.string(),\n  items: z.array(\n    z.object({\n      id: z.string(),\n      taskRunId: z.string(),\n      status: z.enum([\"PENDING\", \"CANCELED\", \"COMPLETED\", \"FAILED\"]),\n    })\n  ),\n});\n\nexport type GetBatchResponseBody = z.infer<typeof GetBatchResponseBody>;\n\nexport const AddTagsRequestBody = z.object({\n  tags: RunTags,\n});\n\nexport type AddTagsRequestBody = z.infer<typeof AddTagsRequestBody>;\n\nexport const RescheduleRunRequestBody = z.object({\n  delay: z.string().or(z.coerce.date()),\n});\n\nexport type RescheduleRunRequestBody = z.infer<typeof RescheduleRunRequestBody>;\n\nexport const GetEnvironmentVariablesResponseBody = z.object({\n  variables: z.record(z.string()),\n});\n\nexport type GetEnvironmentVariablesResponseBody = z.infer<\n  typeof GetEnvironmentVariablesResponseBody\n>;\n\nexport const StartDeploymentIndexingRequestBody = z.object({\n  imageReference: z.string(),\n  selfHosted: z.boolean().optional(),\n});\n\nexport type StartDeploymentIndexingRequestBody = z.infer<typeof StartDeploymentIndexingRequestBody>;\n\nexport const StartDeploymentIndexingResponseBody = z.object({\n  id: z.string(),\n  contentHash: z.string(),\n});\n\nexport type StartDeploymentIndexingResponseBody = z.infer<\n  typeof StartDeploymentIndexingResponseBody\n>;\n\nexport const ExternalBuildData = z.object({\n  buildId: z.string(),\n  buildToken: z.string(),\n  projectId: z.string(),\n});\n\nexport type ExternalBuildData = z.infer<typeof ExternalBuildData>;\n\nexport const InitializeDeploymentResponseBody = z.object({\n  id: z.string(),\n  contentHash: z.string(),\n  shortCode: z.string(),\n  version: z.string(),\n  imageTag: z.string(),\n  externalBuildData: ExternalBuildData.optional().nullable(),\n  registryHost: z.string().optional(),\n});\n\nexport type InitializeDeploymentResponseBody = z.infer<typeof InitializeDeploymentResponseBody>;\n\nexport const InitializeDeploymentRequestBody = z.object({\n  contentHash: z.string(),\n  userId: z.string().optional(),\n});\n\nexport type InitializeDeploymentRequestBody = z.infer<typeof InitializeDeploymentRequestBody>;\n\nexport const DeploymentErrorData = z.object({\n  name: z.string(),\n  message: z.string(),\n  stack: z.string().optional(),\n  stderr: z.string().optional(),\n});\n\nexport const GetDeploymentResponseBody = z.object({\n  id: z.string(),\n  status: z.enum([\n    \"PENDING\",\n    \"BUILDING\",\n    \"DEPLOYING\",\n    \"DEPLOYED\",\n    \"FAILED\",\n    \"CANCELED\",\n    \"TIMED_OUT\",\n  ]),\n  contentHash: z.string(),\n  shortCode: z.string(),\n  version: z.string(),\n  imageReference: z.string().optional(),\n  errorData: DeploymentErrorData.optional().nullable(),\n  worker: z\n    .object({\n      id: z.string(),\n      version: z.string(),\n      tasks: z.array(\n        z.object({\n          id: z.string(),\n          slug: z.string(),\n          filePath: z.string(),\n          exportName: z.string(),\n        })\n      ),\n    })\n    .optional(),\n});\n\nexport type GetDeploymentResponseBody = z.infer<typeof GetDeploymentResponseBody>;\n\nexport const CreateUploadPayloadUrlResponseBody = z.object({\n  presignedUrl: z.string(),\n});\n\nexport type CreateUploadPayloadUrlResponseBody = z.infer<typeof CreateUploadPayloadUrlResponseBody>;\n\nexport const ReplayRunResponse = z.object({\n  id: z.string(),\n});\n\nexport type ReplayRunResponse = z.infer<typeof ReplayRunResponse>;\n\nexport const CanceledRunResponse = z.object({\n  id: z.string(),\n});\n\nexport type CanceledRunResponse = z.infer<typeof CanceledRunResponse>;\n\nexport const ScheduleType = z.union([z.literal(\"DECLARATIVE\"), z.literal(\"IMPERATIVE\")]);\n\nexport const ScheduledTaskPayload = z.object({\n  /** The schedule id associated with this run (you can have many schedules for the same task).\n    You can use this to remove the schedule, update it, etc */\n  scheduleId: z.string(),\n  /** The type of schedule – `\"DECLARATIVE\"` or `\"IMPERATIVE\"`.\n   *\n   * **DECLARATIVE** – defined inline on your `schedules.task` using the `cron` property. They can only be created, updated or deleted by modifying the `cron` property on your task.\n   *\n   * **IMPERATIVE** – created using the `schedules.create` functions or in the dashboard.\n   */\n  type: ScheduleType,\n  /** When the task was scheduled to run.\n   * Note this will be slightly different from `new Date()` because it takes a few ms to run the task.\n   * \n   * This date is UTC. To output it as a string with a timezone you would do this: \n   * ```ts\n   * const formatted = payload.timestamp.toLocaleString(\"en-US\", {\n        timeZone: payload.timezone,\n    });\n    ```  */\n  timestamp: z.date(),\n  /** When the task was last run (it has been).\n    This can be undefined if it's never been run. This date is UTC. */\n  lastTimestamp: z.date().optional(),\n  /** You can optionally provide an external id when creating the schedule.\n    Usually you would use a userId or some other unique identifier.\n    This defaults to undefined if you didn't provide one. */\n  externalId: z.string().optional(),\n  /** The IANA timezone the schedule is set to. The default is UTC.\n   * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones\n   */\n  timezone: z.string(),\n  /** The next 5 dates this task is scheduled to run */\n  upcoming: z.array(z.date()),\n});\n\nexport type ScheduledTaskPayload = z.infer<typeof ScheduledTaskPayload>;\n\nexport const CreateScheduleOptions = z.object({\n  /** The id of the task you want to attach to. */\n  task: z.string(),\n  /**  The schedule in CRON format.\n   * \n   * ```txt\n*    *    *    *    *    *\n┬    ┬    ┬    ┬    ┬\n│    │    │    │    |\n│    │    │    │    └ day of week (0 - 7, 1L - 7L) (0 or 7 is Sun)\n│    │    │    └───── month (1 - 12)\n│    │    └────────── day of month (1 - 31, L)\n│    └─────────────── hour (0 - 23)\n└──────────────────── minute (0 - 59)\n   * ```\n\n\"L\" means the last. In the \"day of week\" field, 1L means the last Monday of the month. In the day of month field, L means the last day of the month.\n\n   */\n  cron: z.string(),\n  /** You can only create one schedule with this key. If you use it twice, the second call will update the schedule.\n   *\n   * This is required to prevent you from creating duplicate schedules. */\n  deduplicationKey: z.string(),\n  /** Optionally, you can specify your own IDs (like a user ID) and then use it inside the run function of your task.\n   *\n   * This allows you to have per-user CRON tasks.\n   */\n  externalId: z.string().optional(),\n  /** Optionally, you can specify a timezone in the IANA format. If unset it will use UTC.\n   * If specified then the CRON will be evaluated in that timezone and will respect daylight savings.\n   *\n   * If you set the CRON to `0 0 * * *` and the timezone to `America/New_York` then the task will run at midnight in New York time, no matter whether it's daylight savings or not.\n   *\n   * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones\n   *\n   * @example \"America/New_York\", \"Europe/London\", \"Asia/Tokyo\", \"Africa/Cairo\"\n   *\n   */\n  timezone: z.string().optional(),\n});\n\nexport type CreateScheduleOptions = z.infer<typeof CreateScheduleOptions>;\n\nexport const UpdateScheduleOptions = CreateScheduleOptions.omit({ deduplicationKey: true });\n\nexport type UpdateScheduleOptions = z.infer<typeof UpdateScheduleOptions>;\n\nexport const ScheduleGenerator = z.object({\n  type: z.literal(\"CRON\"),\n  expression: z.string(),\n  description: z.string(),\n});\n\nexport type ScheduleGenerator = z.infer<typeof ScheduleGenerator>;\n\nexport const ScheduleObject = z.object({\n  id: z.string(),\n  type: ScheduleType,\n  task: z.string(),\n  active: z.boolean(),\n  deduplicationKey: z.string().nullish(),\n  externalId: z.string().nullish(),\n  generator: ScheduleGenerator,\n  timezone: z.string(),\n  nextRun: z.coerce.date().nullish(),\n  environments: z.array(\n    z.object({\n      id: z.string(),\n      type: z.string(),\n      userName: z.string().nullish(),\n    })\n  ),\n});\n\nexport type ScheduleObject = z.infer<typeof ScheduleObject>;\n\nexport const DeletedScheduleObject = z.object({\n  id: z.string(),\n});\n\nexport type DeletedScheduleObject = z.infer<typeof DeletedScheduleObject>;\n\nexport const ListSchedulesResult = z.object({\n  data: z.array(ScheduleObject),\n  pagination: z.object({\n    currentPage: z.number(),\n    totalPages: z.number(),\n    count: z.number(),\n  }),\n});\n\nexport type ListSchedulesResult = z.infer<typeof ListSchedulesResult>;\n\nexport const ListScheduleOptions = z.object({\n  page: z.number().optional(),\n  perPage: z.number().optional(),\n});\n\nexport type ListScheduleOptions = z.infer<typeof ListScheduleOptions>;\n\nexport const TimezonesResult = z.object({\n  timezones: z.array(z.string()),\n});\n\nexport type TimezonesResult = z.infer<typeof TimezonesResult>;\n\nexport const RunStatus = z.enum([\n  /// Task hasn't been deployed yet but is waiting to be executed\n  \"WAITING_FOR_DEPLOY\",\n  /// Task is waiting to be executed by a worker\n  \"QUEUED\",\n  /// Task is currently being executed by a worker\n  \"EXECUTING\",\n  /// Task has failed and is waiting to be retried\n  \"REATTEMPTING\",\n  /// Task has been paused by the system, and will be resumed by the system\n  \"FROZEN\",\n  /// Task has been completed successfully\n  \"COMPLETED\",\n  /// Task has been canceled by the user\n  \"CANCELED\",\n  /// Task has been completed with errors\n  \"FAILED\",\n  /// Task has crashed and won't be retried, most likely the worker ran out of resources, e.g. memory or storage\n  \"CRASHED\",\n  /// Task was interrupted during execution, mostly this happens in development environments\n  \"INTERRUPTED\",\n  /// Task has failed to complete, due to an error in the system\n  \"SYSTEM_FAILURE\",\n  /// Task has been scheduled to run at a specific time\n  \"DELAYED\",\n  /// Task has expired and won't be executed\n  \"EXPIRED\",\n]);\n\nexport type RunStatus = z.infer<typeof RunStatus>;\n\nexport const AttemptStatus = z.enum([\n  \"PENDING\",\n  \"EXECUTING\",\n  \"PAUSED\",\n  \"COMPLETED\",\n  \"FAILED\",\n  \"CANCELED\",\n]);\n\nexport type AttemptStatus = z.infer<typeof AttemptStatus>;\n\nexport const RunEnvironmentDetails = z.object({\n  id: z.string(),\n  name: z.string(),\n  user: z.string().optional(),\n});\n\nexport type RunEnvironmentDetails = z.infer<typeof RunEnvironmentDetails>;\n\nexport const RunScheduleDetails = z.object({\n  id: z.string(),\n  externalId: z.string().optional(),\n  deduplicationKey: z.string().optional(),\n  generator: ScheduleGenerator,\n});\n\nexport type RunScheduleDetails = z.infer<typeof RunScheduleDetails>;\n\nconst CommonRunFields = {\n  id: z.string(),\n  status: RunStatus,\n  taskIdentifier: z.string(),\n  idempotencyKey: z.string().optional(),\n  version: z.string().optional(),\n  isQueued: z.boolean(),\n  isExecuting: z.boolean(),\n  isCompleted: z.boolean(),\n  isSuccess: z.boolean(),\n  isFailed: z.boolean(),\n  isCancelled: z.boolean(),\n  isTest: z.boolean(),\n  createdAt: z.coerce.date(),\n  updatedAt: z.coerce.date(),\n  startedAt: z.coerce.date().optional(),\n  finishedAt: z.coerce.date().optional(),\n  delayedUntil: z.coerce.date().optional(),\n  ttl: z.string().optional(),\n  expiredAt: z.coerce.date().optional(),\n  tags: z.string().array(),\n  costInCents: z.number(),\n  baseCostInCents: z.number(),\n  durationMs: z.number(),\n};\n\nexport const RetrieveRunResponse = z.object({\n  ...CommonRunFields,\n  payload: z.any().optional(),\n  payloadPresignedUrl: z.string().optional(),\n  output: z.any().optional(),\n  outputPresignedUrl: z.string().optional(),\n  schedule: RunScheduleDetails.optional(),\n  attempts: z.array(\n    z\n      .object({\n        id: z.string(),\n        status: AttemptStatus,\n        createdAt: z.coerce.date(),\n        updatedAt: z.coerce.date(),\n        startedAt: z.coerce.date().optional(),\n        completedAt: z.coerce.date().optional(),\n        error: SerializedError.optional(),\n      })\n      .optional()\n  ),\n});\n\nexport type RetrieveRunResponse = z.infer<typeof RetrieveRunResponse>;\n\nexport const ListRunResponseItem = z.object({\n  ...CommonRunFields,\n  env: RunEnvironmentDetails,\n});\n\nexport type ListRunResponseItem = z.infer<typeof ListRunResponseItem>;\n\nexport const ListRunResponse = z.object({\n  data: z.array(ListRunResponseItem),\n  pagination: z.object({\n    next: z.string().optional(),\n    previous: z.string().optional(),\n  }),\n});\n\nexport type ListRunResponse = z.infer<typeof ListRunResponse>;\n\nexport const CreateEnvironmentVariableRequestBody = z.object({\n  name: z.string(),\n  value: z.string(),\n});\n\nexport type CreateEnvironmentVariableRequestBody = z.infer<\n  typeof CreateEnvironmentVariableRequestBody\n>;\n\nexport const UpdateEnvironmentVariableRequestBody = z.object({\n  value: z.string(),\n});\n\nexport type UpdateEnvironmentVariableRequestBody = z.infer<\n  typeof UpdateEnvironmentVariableRequestBody\n>;\n\nexport const ImportEnvironmentVariablesRequestBody = z.object({\n  variables: z.record(z.string()),\n  override: z.boolean().optional(),\n});\n\nexport type ImportEnvironmentVariablesRequestBody = z.infer<\n  typeof ImportEnvironmentVariablesRequestBody\n>;\n\nexport const EnvironmentVariableResponseBody = z.object({\n  success: z.boolean(),\n});\n\nexport type EnvironmentVariableResponseBody = z.infer<typeof EnvironmentVariableResponseBody>;\n\nexport const EnvironmentVariableValue = z.object({\n  value: z.string(),\n});\n\nexport type EnvironmentVariableValue = z.infer<typeof EnvironmentVariableValue>;\n\nexport const EnvironmentVariable = z.object({\n  name: z.string(),\n  value: z.string(),\n});\n\nexport const EnvironmentVariables = z.array(EnvironmentVariable);\n\nexport type EnvironmentVariables = z.infer<typeof EnvironmentVariables>;\n", "import { z } from \"zod\";\nimport { QueueOptions, RetryOptions, ScheduleMetadata } from \"./schemas\";\nimport { MachineConfig } from \"./common\";\n\nexport const TaskResource = z.object({\n  id: z.string(),\n  filePath: z.string(),\n  exportName: z.string(),\n  queue: QueueOptions.optional(),\n  retry: RetryOptions.optional(),\n  machine: MachineConfig.optional(),\n  triggerSource: z.string().optional(),\n  schedule: ScheduleMetadata.optional(),\n});\n\nexport type TaskResource = z.infer<typeof TaskResource>;\n\nexport const BackgroundWorkerMetadata = z.object({\n  packageVersion: z.string(),\n  contentHash: z.string(),\n  cliPackageVersion: z.string().optional(),\n  tasks: z.array(TaskResource),\n});\n\nexport type BackgroundWorkerMetadata = z.infer<typeof BackgroundWorkerMetadata>;\n\nexport const ImageDetailsMetadata = z.object({\n  contentHash: z.string(),\n  imageTag: z.string(),\n});\n\nexport type ImageDetailsMetadata = z.infer<typeof ImageDetailsMetadata>;\n", "import { z } from \"zod\";\nimport { RequireKeys } from \"../types\";\nimport { MachineConfig, MachinePreset, TaskRunExecution } from \"./common\";\n\n/*\n    WARNING: Never import anything from ./messages here. If it's needed in both, put it here instead.\n*/\nexport const EnvironmentType = z.enum([\"PRODUCTION\", \"STAGING\", \"DEVELOPMENT\", \"PREVIEW\"]);\nexport type EnvironmentType = z.infer<typeof EnvironmentType>;\n\nexport const TaskRunExecutionPayload = z.object({\n  execution: TaskRunExecution,\n  traceContext: z.record(z.unknown()),\n  environment: z.record(z.string()).optional(),\n});\n\nexport type TaskRunExecutionPayload = z.infer<typeof TaskRunExecutionPayload>;\n\n// **IMPORTANT NOTE**: If you change this schema, make sure it is backwards compatible with the previous version as this also used when a worker signals to the coordinator that a TaskRun is complete.\n// Strategies for not breaking backwards compatibility:\n// 1. Add new fields as optional\n// 2. If a field is required, add a default value\nexport const ProdTaskRunExecution = TaskRunExecution.extend({\n  worker: z.object({\n    id: z.string(),\n    contentHash: z.string(),\n    version: z.string(),\n  }),\n  machine: MachinePreset.default({ name: \"small-1x\", cpu: 1, memory: 1, centsPerMs: 0 }),\n});\n\nexport type ProdTaskRunExecution = z.infer<typeof ProdTaskRunExecution>;\n\nexport const ProdTaskRunExecutionPayload = z.object({\n  execution: ProdTaskRunExecution,\n  traceContext: z.record(z.unknown()),\n  environment: z.record(z.string()).optional(),\n});\n\nexport type ProdTaskRunExecutionPayload = z.infer<typeof ProdTaskRunExecutionPayload>;\n\nexport const FixedWindowRateLimit = z.object({\n  type: z.literal(\"fixed-window\"),\n  limit: z.number(),\n  window: z.union([\n    z.object({\n      seconds: z.number(),\n    }),\n    z.object({\n      minutes: z.number(),\n    }),\n    z.object({\n      hours: z.number(),\n    }),\n  ]),\n});\n\nexport const SlidingWindowRateLimit = z.object({\n  type: z.literal(\"sliding-window\"),\n  limit: z.number(),\n  window: z.union([\n    z.object({\n      seconds: z.number(),\n    }),\n    z.object({\n      minutes: z.number(),\n    }),\n    z.object({\n      hours: z.number(),\n    }),\n  ]),\n});\n\nexport const RateLimitOptions = z.discriminatedUnion(\"type\", [\n  FixedWindowRateLimit,\n  SlidingWindowRateLimit,\n]);\n\nexport type RateLimitOptions = z.infer<typeof RateLimitOptions>;\n\nexport const RetryOptions = z.object({\n  /** The number of attempts before giving up */\n  maxAttempts: z.number().int().optional(),\n  /** The exponential factor to use when calculating the next retry time.\n   *\n   * Each subsequent retry will be calculated as `previousTimeout * factor`\n   */\n  factor: z.number().optional(),\n  /** The minimum time to wait before retrying */\n  minTimeoutInMs: z.number().int().optional(),\n  /** The maximum time to wait before retrying */\n  maxTimeoutInMs: z.number().int().optional(),\n  /** Randomize the timeout between retries.\n   *\n   * This can be useful to prevent the thundering herd problem where all retries happen at the same time.\n   */\n  randomize: z.boolean().optional(),\n});\n\nexport type RetryOptions = z.infer<typeof RetryOptions>;\n\nexport const QueueOptions = z.object({\n  /** You can define a shared queue and then pass the name in to your task.\n   * \n   * @example\n   * \n   * ```ts\n   * const myQueue = queue({\n      name: \"my-queue\",\n      concurrencyLimit: 1,\n    });\n\n    export const task1 = task({\n      id: \"task-1\",\n      queue: {\n        name: \"my-queue\",\n      },\n      run: async (payload: { message: string }) => {\n        // ...\n      },\n    });\n\n    export const task2 = task({\n      id: \"task-2\",\n      queue: {\n        name: \"my-queue\",\n      },\n      run: async (payload: { message: string }) => {\n        // ...\n      },\n    });\n   * ```\n   */\n  name: z.string().optional(),\n  /** An optional property that specifies the maximum number of concurrent run executions.\n   *\n   * If this property is omitted, the task can potentially use up the full concurrency of an environment. */\n  concurrencyLimit: z.number().int().min(0).max(1000).optional(),\n  /** @deprecated This feature is coming soon */\n  rateLimit: RateLimitOptions.optional(),\n});\n\nexport type QueueOptions = z.infer<typeof QueueOptions>;\n\nexport const ScheduleMetadata = z.object({\n  cron: z.string(),\n  timezone: z.string(),\n});\n\nexport const TaskMetadata = z.object({\n  id: z.string(),\n  packageVersion: z.string(),\n  queue: QueueOptions.optional(),\n  retry: RetryOptions.optional(),\n  machine: MachineConfig.optional(),\n  triggerSource: z.string().optional(),\n  schedule: ScheduleMetadata.optional(),\n});\n\nexport type TaskMetadata = z.infer<typeof TaskMetadata>;\n\nexport const TaskFileMetadata = z.object({\n  filePath: z.string(),\n  exportName: z.string(),\n});\n\nexport type TaskFileMetadata = z.infer<typeof TaskFileMetadata>;\n\nexport const TaskMetadataWithFilePath = z.object({\n  id: z.string(),\n  packageVersion: z.string(),\n  queue: QueueOptions.optional(),\n  retry: RetryOptions.optional(),\n  machine: MachineConfig.optional(),\n  triggerSource: z.string().optional(),\n  schedule: ScheduleMetadata.optional(),\n  filePath: z.string(),\n  exportName: z.string(),\n});\n\nexport type TaskMetadataWithFilePath = z.infer<typeof TaskMetadataWithFilePath>;\n\nexport const PostStartCauses = z.enum([\"index\", \"create\", \"restore\"]);\nexport type PostStartCauses = z.infer<typeof PostStartCauses>;\n\nexport const PreStopCauses = z.enum([\"terminate\"]);\nexport type PreStopCauses = z.infer<typeof PreStopCauses>;\n\nconst RegexSchema = z.custom<RegExp>((val) => {\n  try {\n    // Check to see if val is a regex\n    return typeof (val as RegExp).test === \"function\";\n  } catch {\n    return false;\n  }\n});\n\nexport const Config = z.object({\n  project: z.string(),\n  triggerDirectories: z.string().array().optional(),\n  triggerUrl: z.string().optional(),\n  projectDir: z.string().optional(),\n  tsconfigPath: z.string().optional(),\n  retries: z\n    .object({\n      enabledInDev: z.boolean().default(true),\n      default: RetryOptions.optional(),\n    })\n    .optional(),\n  additionalPackages: z.string().array().optional(),\n  additionalFiles: z.string().array().optional(),\n  dependenciesToBundle: z.array(z.union([z.string(), RegexSchema])).optional(),\n  logLevel: z.string().optional(),\n  enableConsoleLogging: z.boolean().optional(),\n  postInstall: z.string().optional(),\n  extraCACerts: z.string().optional(),\n});\n\nexport type Config = z.infer<typeof Config>;\nexport type ResolvedConfig = RequireKeys<\n  Config,\n  \"triggerDirectories\" | \"triggerUrl\" | \"projectDir\" | \"tsconfigPath\"\n>;\n\nexport const WaitReason = z.enum([\"WAIT_FOR_DURATION\", \"WAIT_FOR_TASK\", \"WAIT_FOR_BATCH\"]);\n\nexport type WaitReason = z.infer<typeof WaitReason>;\n\nexport const TaskRunExecutionLazyAttemptPayload = z.object({\n  runId: z.string(),\n  attemptCount: z.number().optional(),\n  messageId: z.string(),\n  isTest: z.boolean(),\n  traceContext: z.record(z.unknown()),\n  environment: z.record(z.string()).optional(),\n});\n\nexport type TaskRunExecutionLazyAttemptPayload = z.infer<typeof TaskRunExecutionLazyAttemptPayload>;\n", "import { z } from \"zod\";\n\n// Defaults to 0.5\nexport const MachineCpu = z.union([\n  z.literal(0.25),\n  z.literal(0.5),\n  z.literal(1),\n  z.literal(2),\n  z.literal(4),\n]);\n\nexport type MachineCpu = z.infer<typeof MachineCpu>;\n\n// Defaults to 1\nexport const MachineMemory = z.union([\n  z.literal(0.25),\n  z.literal(0.5),\n  z.literal(1),\n  z.literal(2),\n  z.literal(4),\n  z.literal(8),\n]);\n\nexport type MachineMemory = z.infer<typeof MachineMemory>;\n\n// Default is small-1x\nexport const MachinePresetName = z.enum([\n  \"micro\",\n  \"small-1x\",\n  \"small-2x\",\n  \"medium-1x\",\n  \"medium-2x\",\n  \"large-1x\",\n  \"large-2x\",\n]);\n\nexport type MachinePresetName = z.infer<typeof MachinePresetName>;\n\nexport const MachineConfig = z.object({\n  cpu: MachineCpu.optional(),\n  memory: MachineMemory.optional(),\n  preset: MachinePresetName.optional(),\n});\n\nexport type MachineConfig = z.infer<typeof MachineConfig>;\n\nexport const MachinePreset = z.object({\n  name: MachinePresetName,\n  cpu: z.number(),\n  memory: z.number(),\n  centsPerMs: z.number(),\n});\n\nexport type MachinePreset = z.infer<typeof MachinePreset>;\n\nexport const TaskRunBuiltInError = z.object({\n  type: z.literal(\"BUILT_IN_ERROR\"),\n  name: z.string(),\n  message: z.string(),\n  stackTrace: z.string(),\n});\n\nexport type TaskRunBuiltInError = z.infer<typeof TaskRunBuiltInError>;\n\nexport const TaskRunCustomErrorObject = z.object({\n  type: z.literal(\"CUSTOM_ERROR\"),\n  raw: z.string(),\n});\n\nexport type TaskRunCustomErrorObject = z.infer<typeof TaskRunCustomErrorObject>;\n\nexport const TaskRunStringError = z.object({\n  type: z.literal(\"STRING_ERROR\"),\n  raw: z.string(),\n});\n\nexport type TaskRunStringError = z.infer<typeof TaskRunStringError>;\n\nexport const TaskRunErrorCodes = {\n  COULD_NOT_FIND_EXECUTOR: \"COULD_NOT_FIND_EXECUTOR\",\n  COULD_NOT_FIND_TASK: \"COULD_NOT_FIND_TASK\",\n  CONFIGURED_INCORRECTLY: \"CONFIGURED_INCORRECTLY\",\n  TASK_ALREADY_RUNNING: \"TASK_ALREADY_RUNNING\",\n  TASK_EXECUTION_FAILED: \"TASK_EXECUTION_FAILED\",\n  TASK_EXECUTION_ABORTED: \"TASK_EXECUTION_ABORTED\",\n  TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE: \"TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE\",\n  TASK_PROCESS_SIGKILL_TIMEOUT: \"TASK_PROCESS_SIGKILL_TIMEOUT\",\n  TASK_RUN_CANCELLED: \"TASK_RUN_CANCELLED\",\n  TASK_OUTPUT_ERROR: \"TASK_OUTPUT_ERROR\",\n  HANDLE_ERROR_ERROR: \"HANDLE_ERROR_ERROR\",\n  GRACEFUL_EXIT_TIMEOUT: \"GRACEFUL_EXIT_TIMEOUT\",\n  TASK_RUN_CRASHED: \"TASK_RUN_CRASHED\",\n} as const;\n\nexport const TaskRunInternalError = z.object({\n  type: z.literal(\"INTERNAL_ERROR\"),\n  code: z.enum([\n    \"COULD_NOT_FIND_EXECUTOR\",\n    \"COULD_NOT_FIND_TASK\",\n    \"CONFIGURED_INCORRECTLY\",\n    \"TASK_ALREADY_RUNNING\",\n    \"TASK_EXECUTION_FAILED\",\n    \"TASK_EXECUTION_ABORTED\",\n    \"TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE\",\n    \"TASK_PROCESS_SIGKILL_TIMEOUT\",\n    \"TASK_RUN_CANCELLED\",\n    \"TASK_OUTPUT_ERROR\",\n    \"HANDLE_ERROR_ERROR\",\n    \"GRACEFUL_EXIT_TIMEOUT\",\n    \"TASK_RUN_HEARTBEAT_TIMEOUT\",\n    \"TASK_RUN_CRASHED\",\n  ]),\n  message: z.string().optional(),\n  stackTrace: z.string().optional(),\n});\n\nexport type TaskRunInternalError = z.infer<typeof TaskRunInternalError>;\n\nexport const TaskRunError = z.discriminatedUnion(\"type\", [\n  TaskRunBuiltInError,\n  TaskRunCustomErrorObject,\n  TaskRunStringError,\n  TaskRunInternalError,\n]);\n\nexport type TaskRunError = z.infer<typeof TaskRunError>;\n\nexport const TaskRun = z.object({\n  id: z.string(),\n  payload: z.string(),\n  payloadType: z.string(),\n  context: z.any(),\n  tags: z.array(z.string()),\n  isTest: z.boolean().default(false),\n  createdAt: z.coerce.date(),\n  startedAt: z.coerce.date().default(() => new Date()),\n  idempotencyKey: z.string().optional(),\n  maxAttempts: z.number().optional(),\n  durationMs: z.number().default(0),\n  costInCents: z.number().default(0),\n  baseCostInCents: z.number().default(0),\n  version: z.string().optional(),\n});\n\nexport type TaskRun = z.infer<typeof TaskRun>;\n\nexport const TaskRunExecutionTask = z.object({\n  id: z.string(),\n  filePath: z.string(),\n  exportName: z.string(),\n});\n\nexport type TaskRunExecutionTask = z.infer<typeof TaskRunExecutionTask>;\n\nexport const TaskRunExecutionAttempt = z.object({\n  id: z.string(),\n  number: z.number(),\n  startedAt: z.coerce.date(),\n  backgroundWorkerId: z.string(),\n  backgroundWorkerTaskId: z.string(),\n  status: z.string(),\n});\n\nexport type TaskRunExecutionAttempt = z.infer<typeof TaskRunExecutionAttempt>;\n\nexport const TaskRunExecutionEnvironment = z.object({\n  id: z.string(),\n  slug: z.string(),\n  type: z.enum([\"PRODUCTION\", \"STAGING\", \"DEVELOPMENT\", \"PREVIEW\"]),\n});\n\nexport type TaskRunExecutionEnvironment = z.infer<typeof TaskRunExecutionEnvironment>;\n\nexport const TaskRunExecutionOrganization = z.object({\n  id: z.string(),\n  slug: z.string(),\n  name: z.string(),\n});\n\nexport type TaskRunExecutionOrganization = z.infer<typeof TaskRunExecutionOrganization>;\n\nexport const TaskRunExecutionProject = z.object({\n  id: z.string(),\n  ref: z.string(),\n  slug: z.string(),\n  name: z.string(),\n});\n\nexport type TaskRunExecutionProject = z.infer<typeof TaskRunExecutionProject>;\n\nexport const TaskRunExecutionQueue = z.object({\n  id: z.string(),\n  name: z.string(),\n});\n\nexport type TaskRunExecutionQueue = z.infer<typeof TaskRunExecutionQueue>;\n\nexport const TaskRunExecutionBatch = z.object({\n  id: z.string(),\n});\n\nexport const TaskRunExecution = z.object({\n  task: TaskRunExecutionTask,\n  attempt: TaskRunExecutionAttempt,\n  run: TaskRun,\n  queue: TaskRunExecutionQueue,\n  environment: TaskRunExecutionEnvironment,\n  organization: TaskRunExecutionOrganization,\n  project: TaskRunExecutionProject,\n  batch: TaskRunExecutionBatch.optional(),\n  machine: MachinePreset.optional(),\n});\n\nexport type TaskRunExecution = z.infer<typeof TaskRunExecution>;\n\nexport const TaskRunContext = z.object({\n  task: TaskRunExecutionTask,\n  attempt: TaskRunExecutionAttempt.omit({\n    backgroundWorkerId: true,\n    backgroundWorkerTaskId: true,\n  }),\n  run: TaskRun.omit({ payload: true, payloadType: true }),\n  queue: TaskRunExecutionQueue,\n  environment: TaskRunExecutionEnvironment,\n  organization: TaskRunExecutionOrganization,\n  project: TaskRunExecutionProject,\n  batch: TaskRunExecutionBatch.optional(),\n  machine: MachinePreset.optional(),\n});\n\nexport type TaskRunContext = z.infer<typeof TaskRunContext>;\n\nexport const TaskRunExecutionRetry = z.object({\n  timestamp: z.number(),\n  delay: z.number(),\n  error: z.unknown().optional(),\n});\n\nexport type TaskRunExecutionRetry = z.infer<typeof TaskRunExecutionRetry>;\n\nexport const TaskRunExecutionUsage = z.object({\n  durationMs: z.number(),\n});\n\nexport type TaskRunExecutionUsage = z.infer<typeof TaskRunExecutionUsage>;\n\nexport const TaskRunFailedExecutionResult = z.object({\n  ok: z.literal(false),\n  id: z.string(),\n  error: TaskRunError,\n  retry: TaskRunExecutionRetry.optional(),\n  skippedRetrying: z.boolean().optional(),\n  usage: TaskRunExecutionUsage.optional(),\n});\n\nexport type TaskRunFailedExecutionResult = z.infer<typeof TaskRunFailedExecutionResult>;\n\nexport const TaskRunSuccessfulExecutionResult = z.object({\n  ok: z.literal(true),\n  id: z.string(),\n  output: z.string().optional(),\n  outputType: z.string(),\n  usage: TaskRunExecutionUsage.optional(),\n});\n\nexport type TaskRunSuccessfulExecutionResult = z.infer<typeof TaskRunSuccessfulExecutionResult>;\n\nexport const TaskRunExecutionResult = z.discriminatedUnion(\"ok\", [\n  TaskRunSuccessfulExecutionResult,\n  TaskRunFailedExecutionResult,\n]);\n\nexport type TaskRunExecutionResult = z.infer<typeof TaskRunExecutionResult>;\n\nexport const BatchTaskRunExecutionResult = z.object({\n  id: z.string(),\n  items: TaskRunExecutionResult.array(),\n});\n\nexport type BatchTaskRunExecutionResult = z.infer<typeof BatchTaskRunExecutionResult>;\n", "import { z } from \"zod\";\nimport { TaskRunError } from \"./schemas/common\";\n\nexport class AbortTaskRunError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"AbortTaskRunError\";\n  }\n}\n\nexport function parseError(error: unknown): TaskRunError {\n  if (error instanceof Error) {\n    return {\n      type: \"BUILT_IN_ERROR\",\n      name: error.name,\n      message: error.message,\n      stackTrace: error.stack ?? \"\",\n    };\n  }\n\n  if (typeof error === \"string\") {\n    return {\n      type: \"STRING_ERROR\",\n      raw: error,\n    };\n  }\n\n  try {\n    return {\n      type: \"CUSTOM_ERROR\",\n      raw: JSON.stringify(error),\n    };\n  } catch (e) {\n    return {\n      type: \"CUSTOM_ERROR\",\n      raw: String(error),\n    };\n  }\n}\n\nexport function createErrorTaskError(error: TaskRunError): any {\n  switch (error.type) {\n    case \"BUILT_IN_ERROR\": {\n      const e = new Error(error.message);\n\n      e.name = error.name;\n      e.stack = error.stackTrace;\n\n      return e;\n    }\n    case \"STRING_ERROR\": {\n      return error.raw;\n    }\n    case \"CUSTOM_ERROR\": {\n      return JSON.parse(error.raw);\n    }\n    case \"INTERNAL_ERROR\": {\n      return new Error(`trigger.dev internal error (${error.code})`);\n    }\n  }\n}\n\nexport const SerializedError = z.object({\n  message: z.string(),\n  name: z.string().optional(),\n  stackTrace: z.string().optional(),\n});\n\nexport type SerializedError = z.infer<typeof SerializedError>;\n\nexport function createJsonErrorObject(error: TaskRunError): SerializedError {\n  switch (error.type) {\n    case \"BUILT_IN_ERROR\": {\n      return {\n        name: error.name,\n        message: error.message,\n        stackTrace: error.stackTrace,\n      };\n    }\n    case \"STRING_ERROR\": {\n      return {\n        message: error.raw,\n      };\n    }\n    case \"CUSTOM_ERROR\": {\n      return {\n        message: error.raw,\n      };\n    }\n    case \"INTERNAL_ERROR\": {\n      return {\n        message: `trigger.dev internal error (${error.code})`,\n      };\n    }\n  }\n}\n\n// Removes any null characters from the error message\nexport function sanitizeError(error: TaskRunError): TaskRunError {\n  switch (error.type) {\n    case \"BUILT_IN_ERROR\": {\n      return {\n        type: \"BUILT_IN_ERROR\",\n        message: error.message?.replace(/\\0/g, \"\"),\n        name: error.name?.replace(/\\0/g, \"\"),\n        stackTrace: error.stackTrace?.replace(/\\0/g, \"\"),\n      };\n    }\n    case \"STRING_ERROR\": {\n      return {\n        type: \"STRING_ERROR\",\n        raw: error.raw.replace(/\\0/g, \"\"),\n      };\n    }\n    case \"CUSTOM_ERROR\": {\n      return {\n        type: \"CUSTOM_ERROR\",\n        raw: error.raw.replace(/\\0/g, \"\"),\n      };\n    }\n    case \"INTERNAL_ERROR\": {\n      return {\n        type: \"INTERNAL_ERROR\",\n        code: error.code,\n        message: error.message?.replace(/\\0/g, \"\"),\n        stackTrace: error.stackTrace?.replace(/\\0/g, \"\"),\n      };\n    }\n  }\n}\n\nexport function correctErrorStackTrace(\n  stackTrace: string,\n  projectDir?: string,\n  options?: { removeFirstLine?: boolean; isDev?: boolean }\n) {\n  const [errorLine, ...traceLines] = stackTrace.split(\"\\n\");\n\n  return [\n    options?.removeFirstLine ? undefined : errorLine,\n    ...traceLines.map((line) => correctStackTraceLine(line, projectDir, options?.isDev)),\n  ]\n    .filter(Boolean)\n    .join(\"\\n\");\n}\n\nconst LINES_TO_IGNORE = [\n  /ConsoleInterceptor/,\n  /TriggerTracer/,\n  /TaskExecutor/,\n  /EXECUTE_TASK_RUN/,\n  /@trigger.dev\\/core/,\n  /packages\\/core\\/src\\/v3/,\n  /safeJsonProcess/,\n  /__entryPoint.ts/,\n  /ZodIpc/,\n  /startActiveSpan/,\n  /processTicksAndRejections/,\n];\n\nfunction correctStackTraceLine(line: string, projectDir?: string, isDev?: boolean) {\n  if (LINES_TO_IGNORE.some((regex) => regex.test(line))) {\n    return;\n  }\n\n  // Check to see if the path is inside the project directory\n  if (isDev && projectDir && !line.includes(projectDir)) {\n    return;\n  }\n\n  return line.trim();\n}\n\nexport function groupTaskMetadataIssuesByTask(tasks: any, issues: z.ZodIssue[]) {\n  return issues.reduce(\n    (acc, issue) => {\n      if (issue.path.length === 0) {\n        return acc;\n      }\n\n      const taskIndex = issue.path[1];\n\n      if (typeof taskIndex !== \"number\") {\n        return acc;\n      }\n\n      const task = tasks[taskIndex];\n\n      if (!task) {\n        return acc;\n      }\n\n      const restOfPath = issue.path.slice(2);\n\n      const taskId = task.id;\n      const taskName = task.exportName;\n      const filePath = task.filePath;\n\n      const key = taskIndex;\n\n      const existing = acc[key] ?? {\n        id: taskId,\n        exportName: taskName,\n        filePath,\n        issues: [] as Array<{ message: string; path?: string }>,\n      };\n\n      existing.issues.push({\n        message: issue.message,\n        path: restOfPath.length === 0 ? undefined : restOfPath.join(\".\"),\n      });\n\n      return {\n        ...acc,\n        [key]: existing,\n      };\n    },\n    {} as Record<\n      number,\n      {\n        id: any;\n        exportName: string;\n        filePath: string;\n        issues: Array<{ message: string; path?: string }>;\n      }\n    >\n  );\n}\n", "import { z } from \"zod\";\nimport {\n  MachinePreset,\n  TaskRunExecution,\n  TaskRunExecutionResult,\n  TaskRunFailedExecutionResult,\n} from \"./common\";\nimport {\n  EnvironmentType,\n  ProdTaskRunExecution,\n  ProdTaskRunExecutionPayload,\n  TaskMetadataWithFilePath,\n  TaskRunExecutionLazyAttemptPayload,\n  TaskRunExecutionPayload,\n  WaitReason,\n} from \"./schemas\";\nimport { TaskResource } from \"./resources\";\n\nexport const BackgroundWorkerServerMessages = z.discriminatedUnion(\"type\", [\n  z.object({\n    type: z.literal(\"EXECUTE_RUNS\"),\n    payloads: z.array(TaskRunExecutionPayload),\n  }),\n  z.object({\n    type: z.literal(\"CANCEL_ATTEMPT\"),\n    taskAttemptId: z.string(),\n    taskRunId: z.string(),\n  }),\n  z.object({\n    type: z.literal(\"SCHEDULE_ATTEMPT\"),\n    image: z.string(),\n    version: z.string(),\n    machine: MachinePreset,\n    nextAttemptNumber: z.number().optional(),\n    // identifiers\n    id: z.string().optional(), // TODO: Remove this completely in a future release\n    envId: z.string(),\n    envType: EnvironmentType,\n    orgId: z.string(),\n    projectId: z.string(),\n    runId: z.string(),\n  }),\n  z.object({\n    type: z.literal(\"EXECUTE_RUN_LAZY_ATTEMPT\"),\n    payload: TaskRunExecutionLazyAttemptPayload,\n  }),\n]);\n\nexport type BackgroundWorkerServerMessages = z.infer<typeof BackgroundWorkerServerMessages>;\n\nexport const serverWebsocketMessages = {\n  SERVER_READY: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    id: z.string(),\n  }),\n  BACKGROUND_WORKER_MESSAGE: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    backgroundWorkerId: z.string(),\n    data: BackgroundWorkerServerMessages,\n  }),\n};\n\nexport const BackgroundWorkerClientMessages = z.discriminatedUnion(\"type\", [\n  z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    type: z.literal(\"TASK_RUN_COMPLETED\"),\n    completion: TaskRunExecutionResult,\n    execution: TaskRunExecution,\n  }),\n  z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    type: z.literal(\"TASK_RUN_FAILED_TO_RUN\"),\n    completion: TaskRunFailedExecutionResult,\n  }),\n  z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    type: z.literal(\"TASK_HEARTBEAT\"),\n    id: z.string(),\n  }),\n  z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    type: z.literal(\"TASK_RUN_HEARTBEAT\"),\n    id: z.string(),\n  }),\n]);\n\nexport type BackgroundWorkerClientMessages = z.infer<typeof BackgroundWorkerClientMessages>;\n\nexport const BackgroundWorkerProperties = z.object({\n  id: z.string(),\n  version: z.string(),\n  contentHash: z.string(),\n});\n\nexport type BackgroundWorkerProperties = z.infer<typeof BackgroundWorkerProperties>;\n\nexport const clientWebsocketMessages = {\n  READY_FOR_TASKS: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    backgroundWorkerId: z.string(),\n    inProgressRuns: z.string().array().optional(),\n  }),\n  BACKGROUND_WORKER_DEPRECATED: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    backgroundWorkerId: z.string(),\n  }),\n  BACKGROUND_WORKER_MESSAGE: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    backgroundWorkerId: z.string(),\n    data: BackgroundWorkerClientMessages,\n  }),\n};\n\nexport const workerToChildMessages = {\n  EXECUTE_TASK_RUN: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    execution: TaskRunExecution,\n    traceContext: z.record(z.unknown()),\n    metadata: BackgroundWorkerProperties,\n  }),\n  TASK_RUN_COMPLETED_NOTIFICATION: z.discriminatedUnion(\"version\", [\n    z.object({\n      version: z.literal(\"v1\"),\n      completion: TaskRunExecutionResult,\n      execution: TaskRunExecution,\n    }),\n    z.object({\n      version: z.literal(\"v2\"),\n      completion: TaskRunExecutionResult,\n    }),\n  ]),\n  CLEANUP: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    flush: z.boolean().default(false),\n    kill: z.boolean().default(true),\n  }),\n};\n\nexport const UncaughtExceptionMessage = z.object({\n  version: z.literal(\"v1\").default(\"v1\"),\n  error: z.object({\n    name: z.string(),\n    message: z.string(),\n    stack: z.string().optional(),\n  }),\n  origin: z.enum([\"uncaughtException\", \"unhandledRejection\"]),\n});\n\nexport const TaskMetadataFailedToParseData = z.object({\n  version: z.literal(\"v1\").default(\"v1\"),\n  tasks: z.unknown(),\n  zodIssues: z.custom<z.ZodIssue[]>((v) => {\n    return Array.isArray(v) && v.every((issue) => typeof issue === \"object\" && \"message\" in issue);\n  }),\n});\n\nexport const childToWorkerMessages = {\n  TASK_RUN_COMPLETED: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    execution: TaskRunExecution,\n    result: TaskRunExecutionResult,\n  }),\n  TASKS_READY: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    tasks: TaskMetadataWithFilePath.array(),\n  }),\n  TASKS_FAILED_TO_PARSE: TaskMetadataFailedToParseData,\n  TASK_HEARTBEAT: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    id: z.string(),\n  }),\n  TASK_RUN_HEARTBEAT: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    id: z.string(),\n  }),\n  READY_TO_DISPOSE: z.undefined(),\n  WAIT_FOR_DURATION: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    ms: z.number(),\n  }),\n  WAIT_FOR_TASK: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    id: z.string(),\n  }),\n  WAIT_FOR_BATCH: z.object({\n    version: z.literal(\"v1\").default(\"v1\"),\n    id: z.string(),\n    runs: z.string().array(),\n  }),\n  UNCAUGHT_EXCEPTION: UncaughtExceptionMessage,\n};\n\nexport const ProdChildToWorkerMessages = {\n  TASK_RUN_COMPLETED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      execution: TaskRunExecution,\n      result: TaskRunExecutionResult,\n    }),\n  },\n  TASKS_READY: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      tasks: TaskMetadataWithFilePath.array(),\n    }),\n  },\n  TASKS_FAILED_TO_PARSE: {\n    message: TaskMetadataFailedToParseData,\n  },\n  TASK_HEARTBEAT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      id: z.string(),\n    }),\n  },\n  READY_TO_DISPOSE: {\n    message: z.undefined(),\n  },\n  WAIT_FOR_DURATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      ms: z.number(),\n      now: z.number(),\n      waitThresholdInMs: z.number(),\n    }),\n  },\n  WAIT_FOR_TASK: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      friendlyId: z.string(),\n    }),\n  },\n  WAIT_FOR_BATCH: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      batchFriendlyId: z.string(),\n      runFriendlyIds: z.string().array(),\n    }),\n  },\n  UNCAUGHT_EXCEPTION: {\n    message: UncaughtExceptionMessage,\n  },\n};\n\nexport const ProdWorkerToChildMessages = {\n  EXECUTE_TASK_RUN: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      execution: TaskRunExecution,\n      traceContext: z.record(z.unknown()),\n      metadata: BackgroundWorkerProperties,\n    }),\n  },\n  TASK_RUN_COMPLETED_NOTIFICATION: {\n    message: z.discriminatedUnion(\"version\", [\n      z.object({\n        version: z.literal(\"v1\"),\n        completion: TaskRunExecutionResult,\n        execution: TaskRunExecution,\n      }),\n      z.object({\n        version: z.literal(\"v2\"),\n        completion: TaskRunExecutionResult,\n      }),\n    ]),\n  },\n  CLEANUP: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      flush: z.boolean().default(false),\n      kill: z.boolean().default(true),\n    }),\n    callback: z.void(),\n  },\n  WAIT_COMPLETED_NOTIFICATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n    }),\n  },\n};\n\nexport const ProviderToPlatformMessages = {\n  LOG: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      data: z.string(),\n    }),\n  },\n  LOG_WITH_ACK: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      data: z.string(),\n    }),\n    callback: z.object({\n      status: z.literal(\"ok\"),\n    }),\n  },\n  WORKER_CRASHED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      reason: z.string().optional(),\n      exitCode: z.number().optional(),\n      message: z.string().optional(),\n      logs: z.string().optional(),\n      overrideCompletion: z.boolean().optional(),\n    }),\n  },\n  INDEXING_FAILED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      deploymentId: z.string(),\n      error: z.object({\n        name: z.string(),\n        message: z.string(),\n        stack: z.string().optional(),\n        stderr: z.string().optional(),\n      }),\n      overrideCompletion: z.boolean().optional(),\n    }),\n  },\n};\n\nexport const PlatformToProviderMessages = {\n  INDEX: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      imageTag: z.string(),\n      shortCode: z.string(),\n      apiKey: z.string(),\n      apiUrl: z.string(),\n      // identifiers\n      envId: z.string(),\n      envType: EnvironmentType,\n      orgId: z.string(),\n      projectId: z.string(),\n      deploymentId: z.string(),\n    }),\n    callback: z.discriminatedUnion(\"success\", [\n      z.object({\n        success: z.literal(false),\n        error: z.object({\n          name: z.string(),\n          message: z.string(),\n          stack: z.string().optional(),\n          stderr: z.string().optional(),\n        }),\n      }),\n      z.object({\n        success: z.literal(true),\n      }),\n    ]),\n  },\n  RESTORE: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      type: z.enum([\"DOCKER\", \"KUBERNETES\"]),\n      location: z.string(),\n      reason: z.string().optional(),\n      imageRef: z.string(),\n      attemptNumber: z.number().optional(),\n      machine: MachinePreset,\n      // identifiers\n      checkpointId: z.string(),\n      envId: z.string(),\n      envType: EnvironmentType,\n      orgId: z.string(),\n      projectId: z.string(),\n      runId: z.string(),\n    }),\n  },\n  PRE_PULL_DEPLOYMENT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      imageRef: z.string(),\n      shortCode: z.string(),\n      // identifiers\n      envId: z.string(),\n      envType: EnvironmentType,\n      orgId: z.string(),\n      projectId: z.string(),\n      deploymentId: z.string(),\n    }),\n  },\n};\n\nconst CreateWorkerMessage = z.object({\n  projectRef: z.string(),\n  envId: z.string(),\n  deploymentId: z.string(),\n  metadata: z.object({\n    cliPackageVersion: z.string().optional(),\n    contentHash: z.string(),\n    packageVersion: z.string(),\n    tasks: TaskResource.array(),\n  }),\n});\n\nexport const CoordinatorToPlatformMessages = {\n  LOG: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      metadata: z.any(),\n      text: z.string(),\n    }),\n  },\n  CREATE_WORKER: {\n    message: z.discriminatedUnion(\"version\", [\n      CreateWorkerMessage.extend({\n        version: z.literal(\"v1\"),\n      }),\n      CreateWorkerMessage.extend({\n        version: z.literal(\"v2\"),\n        supportsLazyAttempts: z.boolean(),\n      }),\n    ]),\n    callback: z.discriminatedUnion(\"success\", [\n      z.object({\n        success: z.literal(false),\n      }),\n      z.object({\n        success: z.literal(true),\n      }),\n    ]),\n  },\n  CREATE_TASK_RUN_ATTEMPT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      envId: z.string(),\n    }),\n    callback: z.discriminatedUnion(\"success\", [\n      z.object({\n        success: z.literal(false),\n        reason: z.string().optional(),\n      }),\n      z.object({\n        success: z.literal(true),\n        executionPayload: ProdTaskRunExecutionPayload,\n      }),\n    ]),\n  },\n  // Deprecated: Only workers without lazy attempt support will use this\n  READY_FOR_EXECUTION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      totalCompletions: z.number(),\n    }),\n    callback: z.discriminatedUnion(\"success\", [\n      z.object({\n        success: z.literal(false),\n      }),\n      z.object({\n        success: z.literal(true),\n        payload: ProdTaskRunExecutionPayload,\n      }),\n    ]),\n  },\n  READY_FOR_LAZY_ATTEMPT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      envId: z.string(),\n      totalCompletions: z.number(),\n    }),\n    callback: z.discriminatedUnion(\"success\", [\n      z.object({\n        success: z.literal(false),\n        reason: z.string().optional(),\n      }),\n      z.object({\n        success: z.literal(true),\n        lazyPayload: TaskRunExecutionLazyAttemptPayload,\n      }),\n    ]),\n  },\n  READY_FOR_RESUME: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptFriendlyId: z.string(),\n      type: WaitReason,\n    }),\n  },\n  TASK_RUN_COMPLETED: {\n    message: z.object({\n      version: z.enum([\"v1\", \"v2\"]).default(\"v1\"),\n      execution: ProdTaskRunExecution,\n      completion: TaskRunExecutionResult,\n      checkpoint: z\n        .object({\n          docker: z.boolean(),\n          location: z.string(),\n        })\n        .optional(),\n    }),\n  },\n  TASK_RUN_FAILED_TO_RUN: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      completion: TaskRunFailedExecutionResult,\n    }),\n  },\n  TASK_HEARTBEAT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptFriendlyId: z.string(),\n    }),\n  },\n  TASK_RUN_HEARTBEAT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n    }),\n  },\n  CHECKPOINT_CREATED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptFriendlyId: z.string(),\n      docker: z.boolean(),\n      location: z.string(),\n      reason: z.discriminatedUnion(\"type\", [\n        z.object({\n          type: z.literal(\"WAIT_FOR_DURATION\"),\n          ms: z.number(),\n          now: z.number(),\n        }),\n        z.object({\n          type: z.literal(\"WAIT_FOR_BATCH\"),\n          batchFriendlyId: z.string(),\n          runFriendlyIds: z.string().array(),\n        }),\n        z.object({\n          type: z.literal(\"WAIT_FOR_TASK\"),\n          friendlyId: z.string(),\n        }),\n        z.object({\n          type: z.literal(\"RETRYING_AFTER_FAILURE\"),\n          attemptNumber: z.number(),\n        }),\n      ]),\n    }),\n    callback: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      keepRunAlive: z.boolean(),\n    }),\n  },\n  INDEXING_FAILED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      deploymentId: z.string(),\n      error: z.object({\n        name: z.string(),\n        message: z.string(),\n        stack: z.string().optional(),\n        stderr: z.string().optional(),\n      }),\n    }),\n  },\n  RUN_CRASHED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      error: z.object({\n        name: z.string(),\n        message: z.string(),\n        stack: z.string().optional(),\n      }),\n    }),\n  },\n};\n\nexport const PlatformToCoordinatorMessages = {\n  RESUME_AFTER_DEPENDENCY: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      attemptId: z.string(),\n      attemptFriendlyId: z.string(),\n      completions: TaskRunExecutionResult.array(),\n      executions: TaskRunExecution.array(),\n    }),\n  },\n  RESUME_AFTER_DURATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptId: z.string(),\n      attemptFriendlyId: z.string(),\n    }),\n  },\n  REQUEST_ATTEMPT_CANCELLATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptId: z.string(),\n      attemptFriendlyId: z.string(),\n    }),\n  },\n  REQUEST_RUN_CANCELLATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      delayInMs: z.number().optional(),\n    }),\n  },\n  READY_FOR_RETRY: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n    }),\n  },\n  DYNAMIC_CONFIG: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      checkpointThresholdInMs: z.number(),\n    }),\n  },\n};\n\nexport const ClientToSharedQueueMessages = {\n  READY_FOR_TASKS: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      backgroundWorkerId: z.string(),\n    }),\n  },\n  BACKGROUND_WORKER_DEPRECATED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      backgroundWorkerId: z.string(),\n    }),\n  },\n  BACKGROUND_WORKER_MESSAGE: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      backgroundWorkerId: z.string(),\n      data: BackgroundWorkerClientMessages,\n    }),\n  },\n};\n\nexport const SharedQueueToClientMessages = {\n  SERVER_READY: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      id: z.string(),\n    }),\n  },\n  BACKGROUND_WORKER_MESSAGE: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      backgroundWorkerId: z.string(),\n      data: BackgroundWorkerServerMessages,\n    }),\n  },\n};\n\nconst IndexTasksMessage = z.object({\n  version: z.literal(\"v1\"),\n  deploymentId: z.string(),\n  tasks: TaskResource.array(),\n  packageVersion: z.string(),\n});\n\nexport const ProdWorkerToCoordinatorMessages = {\n  TEST: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n    }),\n    callback: z.void(),\n  },\n  INDEX_TASKS: {\n    message: z.discriminatedUnion(\"version\", [\n      IndexTasksMessage.extend({\n        version: z.literal(\"v1\"),\n      }),\n      IndexTasksMessage.extend({\n        version: z.literal(\"v2\"),\n        supportsLazyAttempts: z.boolean(),\n      }),\n    ]),\n    callback: z.discriminatedUnion(\"success\", [\n      z.object({\n        success: z.literal(false),\n      }),\n      z.object({\n        success: z.literal(true),\n      }),\n    ]),\n  },\n  // Deprecated: Only workers without lazy attempt support will use this\n  READY_FOR_EXECUTION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      totalCompletions: z.number(),\n    }),\n  },\n  READY_FOR_LAZY_ATTEMPT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n      totalCompletions: z.number(),\n    }),\n  },\n  READY_FOR_RESUME: {\n    message: z.discriminatedUnion(\"version\", [\n      z.object({\n        version: z.literal(\"v1\"),\n        attemptFriendlyId: z.string(),\n        type: WaitReason,\n      }),\n      z.object({\n        version: z.literal(\"v2\"),\n        attemptFriendlyId: z.string(),\n        attemptNumber: z.number(),\n        type: WaitReason,\n      }),\n    ]),\n  },\n  READY_FOR_CHECKPOINT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n    }),\n  },\n  CANCEL_CHECKPOINT: {\n    message: z\n      .discriminatedUnion(\"version\", [\n        z.object({\n          version: z.literal(\"v1\"),\n        }),\n        z.object({\n          version: z.literal(\"v2\"),\n          reason: WaitReason.optional(),\n        }),\n      ])\n      .default({ version: \"v1\" }),\n    callback: z.object({\n      version: z.literal(\"v2\").default(\"v2\"),\n      checkpointCanceled: z.boolean(),\n      reason: WaitReason.optional(),\n    }),\n  },\n  TASK_HEARTBEAT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptFriendlyId: z.string(),\n    }),\n  },\n  TASK_RUN_HEARTBEAT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n    }),\n  },\n  TASK_RUN_COMPLETED: {\n    message: z.object({\n      version: z.enum([\"v1\", \"v2\"]).default(\"v1\"),\n      execution: ProdTaskRunExecution,\n      completion: TaskRunExecutionResult,\n    }),\n    callback: z.object({\n      willCheckpointAndRestore: z.boolean(),\n      shouldExit: z.boolean(),\n    }),\n  },\n  TASK_RUN_FAILED_TO_RUN: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      completion: TaskRunFailedExecutionResult,\n    }),\n  },\n  WAIT_FOR_DURATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      ms: z.number(),\n      now: z.number(),\n      attemptFriendlyId: z.string(),\n    }),\n    callback: z.object({\n      willCheckpointAndRestore: z.boolean(),\n    }),\n  },\n  WAIT_FOR_TASK: {\n    message: z.object({\n      version: z.enum([\"v1\", \"v2\"]).default(\"v1\"),\n      friendlyId: z.string(),\n      // This is the attempt that is waiting\n      attemptFriendlyId: z.string(),\n    }),\n    callback: z.object({\n      willCheckpointAndRestore: z.boolean(),\n    }),\n  },\n  WAIT_FOR_BATCH: {\n    message: z.object({\n      version: z.enum([\"v1\", \"v2\"]).default(\"v1\"),\n      batchFriendlyId: z.string(),\n      runFriendlyIds: z.string().array(),\n      // This is the attempt that is waiting\n      attemptFriendlyId: z.string(),\n    }),\n    callback: z.object({\n      willCheckpointAndRestore: z.boolean(),\n    }),\n  },\n  INDEXING_FAILED: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      deploymentId: z.string(),\n      error: z.object({\n        name: z.string(),\n        message: z.string(),\n        stack: z.string().optional(),\n        stderr: z.string().optional(),\n      }),\n    }),\n  },\n  CREATE_TASK_RUN_ATTEMPT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n    }),\n    callback: z.discriminatedUnion(\"success\", [\n      z.object({\n        success: z.literal(false),\n        reason: z.string().optional(),\n      }),\n      z.object({\n        success: z.literal(true),\n        executionPayload: ProdTaskRunExecutionPayload,\n      }),\n    ]),\n  },\n  UNRECOVERABLE_ERROR: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      error: z.object({\n        name: z.string(),\n        message: z.string(),\n        stack: z.string().optional(),\n      }),\n    }),\n  },\n  SET_STATE: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptFriendlyId: z.string().optional(),\n      attemptNumber: z.string().optional(),\n    }),\n  },\n};\n\n// TODO: The coordinator can only safely use v1 worker messages, higher versions will need a new flag, e.g. SUPPORTS_VERSIONED_MESSAGES\nexport const CoordinatorToProdWorkerMessages = {\n  RESUME_AFTER_DEPENDENCY: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptId: z.string(),\n      completions: TaskRunExecutionResult.array(),\n      executions: TaskRunExecution.array(),\n    }),\n  },\n  RESUME_AFTER_DURATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptId: z.string(),\n    }),\n  },\n  // Deprecated: Only workers without lazy attempt support will use this\n  EXECUTE_TASK_RUN: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      executionPayload: ProdTaskRunExecutionPayload,\n    }),\n  },\n  EXECUTE_TASK_RUN_LAZY_ATTEMPT: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      lazyPayload: TaskRunExecutionLazyAttemptPayload,\n    }),\n  },\n  REQUEST_ATTEMPT_CANCELLATION: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      attemptId: z.string(),\n    }),\n  },\n  REQUEST_EXIT: {\n    message: z.discriminatedUnion(\"version\", [\n      z.object({\n        version: z.literal(\"v1\"),\n      }),\n      z.object({\n        version: z.literal(\"v2\"),\n        delayInMs: z.number().optional(),\n      }),\n    ]),\n  },\n  READY_FOR_RETRY: {\n    message: z.object({\n      version: z.literal(\"v1\").default(\"v1\"),\n      runId: z.string(),\n    }),\n  },\n};\n\nexport const ProdWorkerSocketData = z.object({\n  contentHash: z.string(),\n  projectRef: z.string(),\n  envId: z.string(),\n  runId: z.string(),\n  attemptFriendlyId: z.string().optional(),\n  attemptNumber: z.string().optional(),\n  podName: z.string(),\n  deploymentId: z.string(),\n  deploymentVersion: z.string(),\n});\n\nexport const CoordinatorSocketData = z.object({\n  supportsDynamicConfig: z.string().optional(),\n});\n", "import { z } from \"zod\";\n\nexport const PRIMARY_VARIANT = \"primary\";\n\nconst Variant = z.enum([PRIMARY_VARIANT]);\nexport type Variant = z.infer<typeof Variant>;\n\nconst AccessoryItem = z.object({\n  text: z.string(),\n  variant: z.string().optional(),\n  url: z.string().optional(),\n});\n\nconst Accessory = z.object({\n  items: z.array(AccessoryItem),\n  style: z.enum([\"codepath\"]).optional(),\n});\n\nexport type Accessory = z.infer<typeof Accessory>;\n\nexport const TaskEventStyle = z\n  .object({\n    icon: z.string().optional(),\n    variant: Variant.optional(),\n    accessory: Accessory.optional(),\n  })\n  .default({\n    icon: undefined,\n    variant: undefined,\n  });\n\nexport type TaskEventStyle = z.infer<typeof TaskEventStyle>;\n", "import { z } from \"zod\";\nimport { RetryOptions } from \"./schemas\";\nimport { EventFilter } from \"./eventFilter\";\nimport { Prettify } from \"../types\";\n\nexport const FetchRetryHeadersStrategy = z.object({\n  /** The `headers` strategy retries the request using info from the response headers. */\n  strategy: z.literal(\"headers\"),\n  /** The header to use to determine the maximum number of times to retry the request. */\n  limitHeader: z.string(),\n  /** The header to use to determine the number of remaining retries. */\n  remainingHeader: z.string(),\n  /** The header to use to determine the time when the number of remaining retries will be reset. */\n  resetHeader: z.string(),\n  /** The event filter to use to determine if the request should be retried. */\n  bodyFilter: EventFilter.optional(),\n\n  /** The format of the `resetHeader` value. */\n  resetFormat: z\n    .enum([\n      \"unix_timestamp\",\n      \"unix_timestamp_in_ms\",\n      \"iso_8601\",\n      \"iso_8601_duration_openai_variant\",\n    ])\n    .default(\"unix_timestamp\")\n    .optional(),\n});\n\nexport type FetchRetryHeadersStrategy = z.infer<typeof FetchRetryHeadersStrategy>;\n\nexport const FetchRetryBackoffStrategy = RetryOptions.extend({\n  /** The `backoff` strategy retries the request with an exponential backoff. */\n  strategy: z.literal(\"backoff\"),\n  /** The event filter to use to determine if the request should be retried. */\n  bodyFilter: EventFilter.optional(),\n});\n\n/** The `backoff` strategy retries the request with an exponential backoff. */\nexport type FetchRetryBackoffStrategy = z.infer<typeof FetchRetryBackoffStrategy>;\n\nexport const FetchRetryStrategy = z.discriminatedUnion(\"strategy\", [\n  FetchRetryHeadersStrategy,\n  FetchRetryBackoffStrategy,\n]);\n\nexport type FetchRetryStrategy = z.infer<typeof FetchRetryStrategy>;\n\nexport const FetchRetryByStatusOptions = z.record(z.string(), FetchRetryStrategy);\n\n/** An object where the key is a status code pattern and the value is a retrying strategy. Supported patterns are:\n  - Specific status codes: 429\n  - Ranges: 500-599\n  - Wildcards: 2xx, 3xx, 4xx, 5xx \n  */\nexport type FetchRetryByStatusOptions = Prettify<z.infer<typeof FetchRetryByStatusOptions>>;\n\nexport const FetchTimeoutOptions = z.object({\n  /** The maximum time to wait for the request to complete. */\n  durationInMs: z.number().optional(),\n  retry: RetryOptions.optional(),\n});\n\nexport type FetchTimeoutOptions = z.infer<typeof FetchTimeoutOptions>;\n\nexport const FetchRetryOptions = z.object({\n  /** The retrying strategy for specific status codes. */\n  byStatus: FetchRetryByStatusOptions.optional(),\n  /** The timeout options for the request. */\n  timeout: RetryOptions.optional(),\n  /**\n   * The retrying strategy for connection errors.\n   */\n  connectionError: RetryOptions.optional(),\n});\n\nexport type FetchRetryOptions = Prettify<z.infer<typeof FetchRetryOptions>>;\n", "import { z } from \"zod\";\n\nexport const stringPatternMatchers = [\n  z.object({\n    $endsWith: z.string(),\n  }),\n  z.object({\n    $startsWith: z.string(),\n  }),\n  z.object({\n    $ignoreCaseEquals: z.string(),\n  }),\n] as const;\n\nconst EventMatcher = z.union([\n  /** Match against a string */\n  z.array(z.string()),\n  /** Match against a number */\n  z.array(z.number()),\n  /** Match against a boolean */\n  z.array(z.boolean()),\n  z.array(\n    z.union([\n      ...stringPatternMatchers,\n      z.object({\n        $exists: z.boolean(),\n      }),\n      z.object({\n        $isNull: z.boolean(),\n      }),\n      z.object({\n        $anythingBut: z.union([z.string(), z.number(), z.boolean()]),\n      }),\n      z.object({\n        $anythingBut: z.union([z.array(z.string()), z.array(z.number()), z.array(z.boolean())]),\n      }),\n      z.object({\n        $gt: z.number(),\n      }),\n      z.object({\n        $lt: z.number(),\n      }),\n      z.object({\n        $gte: z.number(),\n      }),\n      z.object({\n        $lte: z.number(),\n      }),\n      z.object({\n        $between: z.tuple([z.number(), z.number()]),\n      }),\n      z.object({\n        $includes: z.union([z.string(), z.number(), z.boolean()]),\n      }),\n      z.object({\n        $not: z.union([z.string(), z.number(), z.boolean()]),\n      }),\n    ])\n  ),\n]);\n\ntype EventMatcher = z.infer<typeof EventMatcher>;\n\n/** A filter for matching against data */\nexport type EventFilter = { [key: string]: EventMatcher | EventFilter };\n\nexport const EventFilter: z.ZodType<EventFilter> = z.lazy(() =>\n  z.record(z.union([EventMatcher, EventFilter]))\n);\n", "import { z } from \"zod\";\n\nexport const ExceptionEventProperties = z.object({\n  type: z.string().optional(),\n  message: z.string().optional(),\n  stacktrace: z.string().optional(),\n});\n\nexport type ExceptionEventProperties = z.infer<typeof ExceptionEventProperties>;\n\nexport const ExceptionSpanEvent = z.object({\n  name: z.literal(\"exception\"),\n  time: z.coerce.date(),\n  properties: z.object({\n    exception: ExceptionEventProperties,\n  }),\n});\n\nexport type ExceptionSpanEvent = z.infer<typeof ExceptionSpanEvent>;\n\nexport const CancellationSpanEvent = z.object({\n  name: z.literal(\"cancellation\"),\n  time: z.coerce.date(),\n  properties: z.object({\n    reason: z.string(),\n  }),\n});\n\nexport type CancellationSpanEvent = z.infer<typeof CancellationSpanEvent>;\n\nexport const OtherSpanEvent = z.object({\n  name: z.string(),\n  time: z.coerce.date(),\n  properties: z.record(z.unknown()),\n});\n\nexport type OtherSpanEvent = z.infer<typeof OtherSpanEvent>;\n\nexport const SpanEvent = z.union([ExceptionSpanEvent, CancellationSpanEvent, OtherSpanEvent]);\n\nexport type SpanEvent = z.infer<typeof SpanEvent>;\n\nexport const SpanEvents = z.array(SpanEvent);\n\nexport type SpanEvents = z.infer<typeof SpanEvents>;\n\nexport function isExceptionSpanEvent(event: SpanEvent): event is ExceptionSpanEvent {\n  return event.name === \"exception\";\n}\n\nexport function isCancellationSpanEvent(event: SpanEvent): event is CancellationSpanEvent {\n  return event.name === \"cancellation\";\n}\n\nexport const SpanMessagingEvent = z.object({\n  system: z.string().optional(),\n  client_id: z.string().optional(),\n  operation: z.enum([\"publish\", \"create\", \"receive\", \"deliver\"]),\n  message: z.any(),\n  destination: z.string().optional(),\n});\n\nexport type SpanMessagingEvent = z.infer<typeof SpanMessagingEvent>;\n", "export const _globalThis = typeof globalThis === \"object\" ? globalThis : global;\n", "import { ApiClientConfiguration } from \"../apiClientManager/types\";\nimport { Clock } from \"../clock/clock\";\nimport type { RuntimeManager } from \"../runtime/manager\";\nimport { TaskCatalog } from \"../task-catalog/catalog\";\nimport { TaskContext } from \"../taskContext/types\";\nimport { UsageManager } from \"../usage/types\";\nimport { _globalThis } from \"./platform\";\n\nconst GLOBAL_TRIGGER_DOT_DEV_KEY = Symbol.for(`dev.trigger.ts.api`);\n\nconst _global = _globalThis as TriggerDotDevGlobal;\n\nexport function registerGlobal<Type extends keyof TriggerDotDevGlobalAPI>(\n  type: Type,\n  instance: TriggerDotDevGlobalAPI[Type],\n  allowOverride = false\n): boolean {\n  const api = (_global[GLOBAL_TRIGGER_DOT_DEV_KEY] = _global[GLOBAL_TRIGGER_DOT_DEV_KEY] ?? {});\n\n  if (!allowOverride && api[type]) {\n    // already registered an API of this type\n    const err = new Error(`trigger.dev: Attempted duplicate registration of API: ${type}`);\n    return false;\n  }\n\n  api[type] = instance;\n\n  return true;\n}\n\nexport function getGlobal<Type extends keyof TriggerDotDevGlobalAPI>(\n  type: Type\n): TriggerDotDevGlobalAPI[Type] | undefined {\n  return _global[GLOBAL_TRIGGER_DOT_DEV_KEY]?.[type];\n}\n\nexport function unregisterGlobal(type: keyof TriggerDotDevGlobalAPI) {\n  const api = _global[GLOBAL_TRIGGER_DOT_DEV_KEY];\n\n  if (api) {\n    delete api[type];\n  }\n}\n\ntype TriggerDotDevGlobal = {\n  [GLOBAL_TRIGGER_DOT_DEV_KEY]?: TriggerDotDevGlobalAPI;\n};\n\ntype TriggerDotDevGlobalAPI = {\n  runtime?: RuntimeManager;\n  logger?: any;\n  clock?: Clock;\n  usage?: UsageManager;\n  [\"task-catalog\"]?: TaskCatalog;\n  [\"task-context\"]?: TaskContext;\n  [\"api-client\"]?: ApiClientConfiguration;\n};\n", "export const SemanticInternalAttributes = {\n  ENVIRONMENT_ID: \"ctx.environment.id\",\n  ENVIRONMENT_TYPE: \"ctx.environment.type\",\n  ORGANIZATION_ID: \"ctx.organization.id\",\n  ORGANIZATION_SLUG: \"ctx.organization.slug\",\n  ORGANIZATION_NAME: \"ctx.organization.name\",\n  PROJECT_ID: \"ctx.project.id\",\n  PROJECT_REF: \"ctx.project.ref\",\n  PROJECT_NAME: \"ctx.project.title\",\n  PROJECT_DIR: \"project.dir\",\n  ATTEMPT_ID: \"ctx.attempt.id\",\n  ATTEMPT_NUMBER: \"ctx.attempt.number\",\n  RUN_ID: \"ctx.run.id\",\n  RUN_IS_TEST: \"ctx.run.isTest\",\n  BATCH_ID: \"ctx.batch.id\",\n  TASK_SLUG: \"ctx.task.id\",\n  TASK_PATH: \"ctx.task.filePath\",\n  TASK_EXPORT_NAME: \"ctx.task.exportName\",\n  QUEUE_NAME: \"ctx.queue.name\",\n  QUEUE_ID: \"ctx.queue.id\",\n  MACHINE_PRESET_NAME: \"ctx.machine.name\",\n  MACHINE_PRESET_CPU: \"ctx.machine.cpu\",\n  MACHINE_PRESET_MEMORY: \"ctx.machine.memory\",\n  MACHINE_PRESET_CENTS_PER_MS: \"ctx.machine.centsPerMs\",\n  SPAN_PARTIAL: \"$span.partial\",\n  SPAN_ID: \"$span.span_id\",\n  OUTPUT: \"$output\",\n  OUTPUT_TYPE: \"$mime_type_output\",\n  STYLE: \"$style\",\n  STYLE_ICON: \"$style.icon\",\n  STYLE_VARIANT: \"$style.variant\",\n  STYLE_ACCESSORY: \"$style.accessory\",\n  METADATA: \"$metadata\",\n  TRIGGER: \"$trigger\",\n  PAYLOAD: \"$payload\",\n  PAYLOAD_TYPE: \"$mime_type_payload\",\n  SHOW: \"$show\",\n  SHOW_ACTIONS: \"$show.actions\",\n  WORKER_ID: \"worker.id\",\n  WORKER_VERSION: \"worker.version\",\n  CLI_VERSION: \"cli.version\",\n  SDK_VERSION: \"sdk.version\",\n  SDK_LANGUAGE: \"sdk.language\",\n  RETRY_AT: \"retry.at\",\n  RETRY_DELAY: \"retry.delay\",\n  RETRY_COUNT: \"retry.count\",\n  LINK_TITLE: \"$link.title\",\n  IDEMPOTENCY_KEY: \"ctx.run.idempotencyKey\",\n  USAGE_DURATION_MS: \"$usage.durationMs\",\n  USAGE_COST_IN_CENTS: \"$usage.costInCents\",\n  RATE_LIMIT_LIMIT: \"response.rateLimit.limit\",\n  RATE_LIMIT_REMAINING: \"response.rateLimit.remaining\",\n  RATE_LIMIT_RESET: \"response.rateLimit.reset\",\n};\n", "import { Attributes } from \"@opentelemetry/api\";\nimport { BackgroundWorkerProperties, TaskRunContext } from \"../schemas\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport { TaskContext } from \"./types\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\n\nconst API_NAME = \"task-context\";\n\nexport class TaskContextAPI {\n  private static _instance?: TaskContextAPI;\n\n  private constructor() {}\n\n  public static getInstance(): TaskContextAPI {\n    if (!this._instance) {\n      this._instance = new TaskContextAPI();\n    }\n\n    return this._instance;\n  }\n\n  get isInsideTask(): boolean {\n    return this.#getTaskContext() !== undefined;\n  }\n\n  get ctx(): TaskRunContext | undefined {\n    return this.#getTaskContext()?.ctx;\n  }\n\n  get worker(): BackgroundWorkerProperties | undefined {\n    return this.#getTaskContext()?.worker;\n  }\n\n  get attributes(): Attributes {\n    if (this.ctx) {\n      return {\n        ...this.contextAttributes,\n        ...this.workerAttributes,\n      };\n    }\n\n    return {};\n  }\n\n  get workerAttributes(): Attributes {\n    if (this.worker) {\n      return {\n        [SemanticInternalAttributes.WORKER_ID]: this.worker.id,\n        [SemanticInternalAttributes.WORKER_VERSION]: this.worker.version,\n      };\n    }\n\n    return {};\n  }\n\n  get contextAttributes(): Attributes {\n    if (this.ctx) {\n      return {\n        [SemanticInternalAttributes.ATTEMPT_ID]: this.ctx.attempt.id,\n        [SemanticInternalAttributes.ATTEMPT_NUMBER]: this.ctx.attempt.number,\n        [SemanticInternalAttributes.TASK_SLUG]: this.ctx.task.id,\n        [SemanticInternalAttributes.TASK_PATH]: this.ctx.task.filePath,\n        [SemanticInternalAttributes.TASK_EXPORT_NAME]: this.ctx.task.exportName,\n        [SemanticInternalAttributes.QUEUE_NAME]: this.ctx.queue.name,\n        [SemanticInternalAttributes.QUEUE_ID]: this.ctx.queue.id,\n        [SemanticInternalAttributes.ENVIRONMENT_ID]: this.ctx.environment.id,\n        [SemanticInternalAttributes.ENVIRONMENT_TYPE]: this.ctx.environment.type,\n        [SemanticInternalAttributes.ORGANIZATION_ID]: this.ctx.organization.id,\n        [SemanticInternalAttributes.PROJECT_ID]: this.ctx.project.id,\n        [SemanticInternalAttributes.PROJECT_REF]: this.ctx.project.ref,\n        [SemanticInternalAttributes.PROJECT_NAME]: this.ctx.project.name,\n        [SemanticInternalAttributes.RUN_ID]: this.ctx.run.id,\n        [SemanticInternalAttributes.RUN_IS_TEST]: this.ctx.run.isTest,\n        [SemanticInternalAttributes.ORGANIZATION_SLUG]: this.ctx.organization.slug,\n        [SemanticInternalAttributes.ORGANIZATION_NAME]: this.ctx.organization.name,\n        [SemanticInternalAttributes.BATCH_ID]: this.ctx.batch?.id,\n        [SemanticInternalAttributes.IDEMPOTENCY_KEY]: this.ctx.run.idempotencyKey,\n        [SemanticInternalAttributes.MACHINE_PRESET_NAME]: this.ctx.machine?.name,\n        [SemanticInternalAttributes.MACHINE_PRESET_CPU]: this.ctx.machine?.cpu,\n        [SemanticInternalAttributes.MACHINE_PRESET_MEMORY]: this.ctx.machine?.memory,\n        [SemanticInternalAttributes.MACHINE_PRESET_CENTS_PER_MS]: this.ctx.machine?.centsPerMs,\n      };\n    }\n\n    return {};\n  }\n\n  public disable() {\n    unregisterGlobal(API_NAME);\n  }\n\n  public setGlobalTaskContext(taskContext: TaskContext): boolean {\n    return registerGlobal(API_NAME, taskContext);\n  }\n\n  #getTaskContext(): TaskContext | undefined {\n    return getGlobal(API_NAME);\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TaskContextAPI } from \"./taskContext\";\n/** Entrypoint for logger API */\nexport const taskContext = TaskContextAPI.getInstance();\n", "import { z } from \"zod\";\nimport { fromZodError } from \"zod-validation-error\";\nimport { RetryOptions } from \"../schemas\";\nimport { calculateNextRetryDelay } from \"../utils/retries\";\nimport { ApiConnectionError, ApiError } from \"./errors\";\n\nimport { Attributes, Span } from \"@opentelemetry/api\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { TriggerTracer } from \"../tracer\";\nimport { accessoryAttributes } from \"../utils/styleAttributes\";\nimport {\n  CursorPage,\n  CursorPageParams,\n  CursorPageResponse,\n  OffsetLimitPage,\n  OffsetLimitPageParams,\n  OffsetLimitPageResponse,\n} from \"./pagination\";\n\nexport const defaultRetryOptions = {\n  maxAttempts: 3,\n  factor: 2,\n  minTimeoutInMs: 1000,\n  maxTimeoutInMs: 60000,\n  randomize: false,\n} satisfies RetryOptions;\n\nexport type ZodFetchOptions = {\n  retry?: RetryOptions;\n  tracer?: TriggerTracer;\n  name?: string;\n  attributes?: Attributes;\n  icon?: string;\n  onResponseBody?: (body: unknown, span: Span) => void;\n};\n\nexport type ApiRequestOptions = Pick<ZodFetchOptions, \"retry\">;\ntype KeysEnum<T> = { [P in keyof Required<T>]: true };\n\n// This is required so that we can determine if a given object matches the ApiRequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys: KeysEnum<ApiRequestOptions> = {\n  retry: true,\n};\n\nexport const isRequestOptions = (obj: unknown): obj is ApiRequestOptions => {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    !isEmptyObj(obj) &&\n    Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k))\n  );\n};\n\ninterface FetchCursorPageParams extends CursorPageParams {\n  query?: URLSearchParams;\n}\n\ninterface FetchOffsetLimitPageParams extends OffsetLimitPageParams {\n  query?: URLSearchParams;\n}\n\nexport function zodfetch<TResponseBodySchema extends z.ZodTypeAny>(\n  schema: TResponseBodySchema,\n  url: string,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions\n): ApiPromise<z.output<TResponseBodySchema>> {\n  return new ApiPromise(_doZodFetch(schema, url, requestInit, options));\n}\n\nexport function zodfetchCursorPage<TItemSchema extends z.ZodTypeAny>(\n  schema: TItemSchema,\n  url: string,\n  params: FetchCursorPageParams,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions\n) {\n  const query = new URLSearchParams(params.query);\n\n  if (params.limit) {\n    query.set(\"page[size]\", String(params.limit));\n  }\n\n  if (params.after) {\n    query.set(\"page[after]\", params.after);\n  }\n\n  if (params.before) {\n    query.set(\"page[before]\", params.before);\n  }\n\n  const cursorPageSchema = z.object({\n    data: z.array(schema),\n    pagination: z.object({\n      next: z.string().optional(),\n      previous: z.string().optional(),\n    }),\n  });\n\n  const $url = new URL(url);\n  $url.search = query.toString();\n\n  const fetchResult = _doZodFetch(cursorPageSchema, $url.href, requestInit, options);\n\n  return new CursorPagePromise(fetchResult, schema, url, params, requestInit, options);\n}\n\nexport function zodfetchOffsetLimitPage<TItemSchema extends z.ZodTypeAny>(\n  schema: TItemSchema,\n  url: string,\n  params: FetchOffsetLimitPageParams,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions\n) {\n  const query = new URLSearchParams(params.query);\n\n  if (params.limit) {\n    query.set(\"perPage\", String(params.limit));\n  }\n\n  if (params.page) {\n    query.set(\"page\", String(params.page));\n  }\n\n  const offsetLimitPageSchema = z.object({\n    data: z.array(schema),\n    pagination: z.object({\n      currentPage: z.coerce.number(),\n      totalPages: z.coerce.number(),\n      count: z.coerce.number(),\n    }),\n  });\n\n  const $url = new URL(url);\n  $url.search = query.toString();\n\n  const fetchResult = _doZodFetch(offsetLimitPageSchema, $url.href, requestInit, options);\n\n  return new OffsetLimitPagePromise(fetchResult, schema, url, params, requestInit, options);\n}\n\ntype ZodFetchResult<T> = {\n  data: T;\n  response: Response;\n};\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\nasync function traceZodFetch<T>(\n  params: {\n    url: string;\n    requestInit?: RequestInit;\n    options?: ZodFetchOptions;\n  },\n  callback: (span?: Span) => Promise<T>\n): Promise<T> {\n  if (!params.options?.tracer) {\n    return callback();\n  }\n\n  const url = new URL(params.url);\n  const method = params.requestInit?.method ?? \"GET\";\n  const name = params.options.name ?? `${method} ${url.pathname}`;\n\n  return await params.options.tracer.startActiveSpan(\n    name,\n    async (span) => {\n      return await callback(span);\n    },\n    {\n      attributes: {\n        [SemanticInternalAttributes.STYLE_ICON]: params.options?.icon ?? \"api\",\n        ...params.options.attributes,\n      },\n    }\n  );\n}\n\nasync function _doZodFetch<TResponseBodySchema extends z.ZodTypeAny>(\n  schema: TResponseBodySchema,\n  url: string,\n  requestInit?: PromiseOrValue<RequestInit>,\n  options?: ZodFetchOptions\n): Promise<ZodFetchResult<z.output<TResponseBodySchema>>> {\n  const $requestInit = await requestInit;\n\n  return traceZodFetch({ url, requestInit: $requestInit, options }, async (span) => {\n    const result = await _doZodFetchWithRetries(schema, url, $requestInit, options);\n\n    if (options?.onResponseBody && span) {\n      options.onResponseBody(result.data, span);\n    }\n\n    return result;\n  });\n}\n\nasync function _doZodFetchWithRetries<TResponseBodySchema extends z.ZodTypeAny>(\n  schema: TResponseBodySchema,\n  url: string,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions,\n  attempt = 1\n): Promise<ZodFetchResult<z.output<TResponseBodySchema>>> {\n  try {\n    const response = await fetch(url, requestInitWithCache(requestInit));\n\n    const responseHeaders = createResponseHeaders(response.headers);\n\n    if (!response.ok) {\n      const retryResult = shouldRetry(response, attempt, options?.retry);\n\n      if (retryResult.retry) {\n        await waitForRetry(url, attempt + 1, retryResult.delay, options, requestInit, response);\n\n        return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);\n      } else {\n        const errText = await response.text().catch((e) => castToError(e).message);\n        const errJSON = safeJsonParse(errText);\n        const errMessage = errJSON ? undefined : errText;\n\n        throw ApiError.generate(response.status, errJSON, errMessage, responseHeaders);\n      }\n    }\n\n    const jsonBody = await response.json();\n    const parsedResult = schema.safeParse(jsonBody);\n\n    if (parsedResult.success) {\n      return { data: parsedResult.data, response };\n    }\n\n    throw fromZodError(parsedResult.error);\n  } catch (error) {\n    if (error instanceof ApiError) {\n      throw error;\n    }\n\n    if (options?.retry) {\n      const retry = { ...defaultRetryOptions, ...options.retry };\n\n      const delay = calculateNextRetryDelay(retry, attempt);\n\n      if (delay) {\n        await waitForRetry(url, attempt + 1, delay, options, requestInit);\n\n        return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);\n      }\n    }\n\n    throw new ApiConnectionError({ cause: castToError(error) });\n  }\n}\n\nfunction castToError(err: any): Error {\n  if (err instanceof Error) return err;\n  return new Error(err);\n}\n\ntype ShouldRetryResult =\n  | {\n      retry: false;\n    }\n  | {\n      retry: true;\n      delay: number;\n    };\n\nfunction shouldRetry(\n  response: Response,\n  attempt: number,\n  retryOptions?: RetryOptions\n): ShouldRetryResult {\n  function shouldRetryForOptions(): ShouldRetryResult {\n    const retry = { ...defaultRetryOptions, ...retryOptions };\n\n    const delay = calculateNextRetryDelay(retry, attempt);\n\n    if (delay) {\n      return { retry: true, delay };\n    } else {\n      return { retry: false };\n    }\n  }\n\n  // Note this is not a standard header.\n  const shouldRetryHeader = response.headers.get(\"x-should-retry\");\n\n  // If the server explicitly says whether or not to retry, obey.\n  if (shouldRetryHeader === \"true\") return shouldRetryForOptions();\n  if (shouldRetryHeader === \"false\") return { retry: false };\n\n  // Retry on request timeouts.\n  if (response.status === 408) return shouldRetryForOptions();\n\n  // Retry on lock timeouts.\n  if (response.status === 409) return shouldRetryForOptions();\n\n  // Retry on rate limits.\n  if (response.status === 429) {\n    if (\n      attempt >= (typeof retryOptions?.maxAttempts === \"number\" ? retryOptions?.maxAttempts : 3)\n    ) {\n      return { retry: false };\n    }\n\n    // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.\n    const resetAtUnixEpochMs = response.headers.get(\"x-ratelimit-reset\");\n\n    if (resetAtUnixEpochMs) {\n      const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);\n      const delay = resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 1000);\n\n      if (delay > 0) {\n        return { retry: true, delay };\n      }\n    }\n\n    return shouldRetryForOptions();\n  }\n\n  // Retry internal errors.\n  if (response.status >= 500) return shouldRetryForOptions();\n\n  return { retry: false };\n}\n\nfunction safeJsonParse(text: string): any {\n  try {\n    return JSON.parse(text);\n  } catch (e) {\n    return undefined;\n  }\n}\n\nfunction createResponseHeaders(headers: Response[\"headers\"]): Record<string, string> {\n  return new Proxy(\n    Object.fromEntries(\n      // @ts-ignore\n      headers.entries()\n    ),\n    {\n      get(target, name) {\n        const key = name.toString();\n        return target[key.toLowerCase()] || target[key];\n      },\n    }\n  );\n}\n\nfunction requestInitWithCache(requestInit?: RequestInit): RequestInit {\n  try {\n    const withCache: RequestInit = {\n      ...requestInit,\n      cache: \"no-cache\",\n    };\n\n    const _ = new Request(\"http://localhost\", withCache);\n\n    return withCache;\n  } catch (error) {\n    return requestInit ?? {};\n  }\n}\n\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class ApiPromise<T> extends Promise<T> {\n  constructor(private responsePromise: Promise<ZodFetchResult<T>>) {\n    super((resolve) => {\n      // this is maybe a bit weird but this has to be a no-op to not implicitly\n      // parse the response body; instead .then, .catch, .finally are overridden\n      // to parse the response\n      resolve(null as any);\n    });\n  }\n\n  /**\n   * Gets the raw `Response` instance instead of parsing the response\n   * data.\n   *\n   * If you want to parse the response body but still get the `Response`\n   * instance, you can use {@link withResponse()}.\n   */\n  asResponse(): Promise<Response> {\n    return this.responsePromise.then((p) => p.response);\n  }\n\n  /**\n   * Gets the parsed response data and the raw `Response` instance.\n   *\n   * If you just want to get the raw `Response` instance without parsing it,\n   * you can use {@link asResponse()}.\n   */\n  async withResponse(): Promise<{ data: T; response: Response }> {\n    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n    return { data, response };\n  }\n\n  private parse(): Promise<T> {\n    return this.responsePromise.then((result) => result.data);\n  }\n\n  override then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): Promise<TResult1 | TResult2> {\n    return this.parse().then(onfulfilled, onrejected);\n  }\n\n  override catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null\n  ): Promise<T | TResult> {\n    return this.parse().catch(onrejected);\n  }\n\n  override finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    return this.parse().finally(onfinally);\n  }\n}\n\nexport class CursorPagePromise<TItemSchema extends z.ZodTypeAny>\n  extends ApiPromise<CursorPage<z.output<TItemSchema>>>\n  implements AsyncIterable<z.output<TItemSchema>>\n{\n  constructor(\n    result: Promise<ZodFetchResult<CursorPageResponse<z.output<TItemSchema>>>>,\n    private schema: TItemSchema,\n    private url: string,\n    private params: FetchCursorPageParams,\n    private requestInit?: RequestInit,\n    private options?: ZodFetchOptions\n  ) {\n    super(\n      result.then((result) => ({\n        data: new CursorPage(result.data.data, result.data.pagination, this.#fetchPage.bind(this)),\n        response: result.response,\n      }))\n    );\n  }\n\n  #fetchPage(params: Omit<CursorPageParams, \"limit\">): Promise<CursorPage<z.output<TItemSchema>>> {\n    return zodfetchCursorPage(\n      this.schema,\n      this.url,\n      { ...this.params, ...params },\n      this.requestInit,\n      this.options\n    );\n  }\n\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n\nexport class OffsetLimitPagePromise<TItemSchema extends z.ZodTypeAny>\n  extends ApiPromise<OffsetLimitPage<z.output<TItemSchema>>>\n  implements AsyncIterable<z.output<TItemSchema>>\n{\n  constructor(\n    result: Promise<ZodFetchResult<OffsetLimitPageResponse<z.output<TItemSchema>>>>,\n    private schema: TItemSchema,\n    private url: string,\n    private params: FetchOffsetLimitPageParams,\n    private requestInit?: RequestInit,\n    private options?: ZodFetchOptions\n  ) {\n    super(\n      result.then((result) => ({\n        data: new OffsetLimitPage(\n          result.data.data,\n          result.data.pagination,\n          this.#fetchPage.bind(this)\n        ),\n        response: result.response,\n      }))\n    );\n  }\n\n  #fetchPage(\n    params: Omit<FetchOffsetLimitPageParams, \"limit\">\n  ): Promise<OffsetLimitPage<z.output<TItemSchema>>> {\n    return zodfetchOffsetLimitPage(\n      this.schema,\n      this.url,\n      { ...this.params, ...params },\n      this.requestInit,\n      this.options\n    );\n  }\n\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n\nasync function waitForRetry(\n  url: string,\n  attempt: number,\n  delay: number,\n  options?: ZodFetchOptions,\n  requestInit?: RequestInit,\n  response?: Response\n): Promise<void> {\n  if (options?.tracer) {\n    const method = requestInit?.method ?? \"GET\";\n\n    return options.tracer.startActiveSpan(\n      response ? `wait after ${response.status}` : `wait after error`,\n      async (span) => {\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"wait\",\n          ...accessoryAttributes({\n            items: [\n              {\n                text: `retrying ${options?.name ?? method.toUpperCase()} in ${delay}ms`,\n                variant: \"normal\",\n              },\n            ],\n            style: \"codepath\",\n          }),\n        },\n      }\n    );\n  }\n\n  await new Promise((resolve) => setTimeout(resolve, delay));\n}\n\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj: Object | null | undefined): boolean {\n  if (!obj) return true;\n  for (const _k in obj) return false;\n  return true;\n}\n\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj: Object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n", "import { RetryOptions } from \"./schemas\";\n\nconst DEFAULT_RETRY_OPTIONS = {\n  limit: 5,\n  factor: 1.8,\n  minTimeoutInMs: 1000,\n  maxTimeoutInMs: 60000,\n  randomize: true,\n} satisfies RetryOptions;\n\nexport function calculateRetryAt(retryOptions: RetryOptions, attempts: number): Date | undefined {\n  const options = {\n    ...DEFAULT_RETRY_OPTIONS,\n    ...retryOptions,\n  };\n\n  const retryCount = attempts + 1;\n\n  if (retryCount >= options.limit) {\n    return;\n  }\n\n  const random = options.randomize ? Math.random() + 1 : 1;\n\n  let timeoutInMs = Math.round(\n    random *\n      Math.max(options.minTimeoutInMs, 1) *\n      Math.pow(options.factor, Math.max(attempts - 1, 0))\n  );\n\n  timeoutInMs = Math.min(timeoutInMs, options.maxTimeoutInMs);\n\n  return new Date(Date.now() + timeoutInMs);\n}\n\nexport function calculateResetAt(\n  resets: string | undefined | null,\n  format:\n    | \"unix_timestamp\"\n    | \"iso_8601\"\n    | \"iso_8601_duration_openai_variant\"\n    | \"unix_timestamp_in_ms\",\n  now: Date = new Date()\n): Date | undefined {\n  if (!resets) return;\n\n  switch (format) {\n    case \"iso_8601_duration_openai_variant\": {\n      return calculateISO8601DurationOpenAIVariantResetAt(resets, now);\n    }\n    case \"iso_8601\": {\n      return calculateISO8601ResetAt(resets, now);\n    }\n    case \"unix_timestamp\": {\n      return calculateUnixTimestampResetAt(resets, now);\n    }\n    case \"unix_timestamp_in_ms\": {\n      return calculateUnixTimestampInMsResetAt(resets, now);\n    }\n  }\n}\n\nfunction calculateUnixTimestampResetAt(resets: string, now: Date = new Date()): Date | undefined {\n  // Check if the input is null or undefined\n  if (!resets) return undefined;\n\n  // Convert the string to a number\n  const resetAt = parseInt(resets, 10);\n\n  // If the string doesn't match the expected format, return undefined\n  if (isNaN(resetAt)) return undefined;\n\n  // Return the date\n  return new Date(resetAt * 1000);\n}\n\nfunction calculateUnixTimestampInMsResetAt(\n  resets: string,\n  now: Date = new Date()\n): Date | undefined {\n  // Check if the input is null or undefined\n  if (!resets) return undefined;\n\n  // Convert the string to a number\n  const resetAt = parseInt(resets, 10);\n\n  // If the string doesn't match the expected format, return undefined\n  if (isNaN(resetAt)) return undefined;\n\n  // Return the date\n  return new Date(resetAt);\n}\n\nfunction calculateISO8601ResetAt(resets: string, now: Date = new Date()): Date | undefined {\n  // Check if the input is null or undefined\n  if (!resets) return undefined;\n\n  // Parse the date\n  const resetAt = new Date(resets);\n\n  // If the string doesn't match the expected format, return undefined\n  if (isNaN(resetAt.getTime())) return undefined;\n\n  return resetAt;\n}\n\nfunction calculateISO8601DurationOpenAIVariantResetAt(\n  resets: string,\n  now: Date = new Date()\n): Date | undefined {\n  // Check if the input is null or undefined\n  if (!resets) return undefined;\n\n  // Regular expression to match the duration string pattern\n  const pattern = /^(?:(\\d+)d)?(?:(\\d+)h)?(?:(\\d+)m)?(?:(\\d+(?:\\.\\d+)?)s)?(?:(\\d+)ms)?$/;\n  const match = resets.match(pattern);\n\n  // If the string doesn't match the expected format, return undefined\n  if (!match) return undefined;\n\n  // Extract days, hours, minutes, seconds, and milliseconds from the string\n  const days = parseInt(match[1], 10) || 0;\n  const hours = parseInt(match[2], 10) || 0;\n  const minutes = parseInt(match[3], 10) || 0;\n  const seconds = parseFloat(match[4]) || 0;\n  const milliseconds = parseInt(match[5], 10) || 0;\n\n  // Calculate the future date based on the current date plus the extracted time\n  const resetAt = new Date(now);\n  resetAt.setDate(resetAt.getDate() + days);\n  resetAt.setHours(resetAt.getHours() + hours);\n  resetAt.setMinutes(resetAt.getMinutes() + minutes);\n  resetAt.setSeconds(resetAt.getSeconds() + Math.floor(seconds));\n  resetAt.setMilliseconds(\n    resetAt.getMilliseconds() + (seconds - Math.floor(seconds)) * 1000 + milliseconds\n  );\n\n  return resetAt;\n}\n", "import { calculateResetAt as calculateResetAtInternal } from \"../../retry\";\nimport { FetchRetryOptions, type RetryOptions } from \"../schemas\";\n\nexport const defaultRetryOptions = {\n  maxAttempts: 3,\n  factor: 2,\n  minTimeoutInMs: 1000,\n  maxTimeoutInMs: 60000,\n  randomize: true,\n} satisfies RetryOptions;\n\nexport const defaultFetchRetryOptions = {\n  byStatus: {\n    \"429,408,409,5xx\": {\n      strategy: \"backoff\",\n      ...defaultRetryOptions,\n    },\n  },\n  connectionError: defaultRetryOptions,\n  timeout: defaultRetryOptions,\n} satisfies FetchRetryOptions;\n\n/**\n *\n * @param options\n * @param attempt - The current attempt number. If the first attempt has failed, this will be 1.\n * @returns\n */\nexport function calculateNextRetryDelay(options: RetryOptions, attempt: number) {\n  const opts = { ...defaultRetryOptions, ...options };\n\n  if (attempt >= opts.maxAttempts) {\n    return;\n  }\n\n  const { factor, minTimeoutInMs, maxTimeoutInMs, randomize } = opts;\n\n  const random = randomize ? Math.random() + 1 : 1;\n\n  const timeout = Math.min(maxTimeoutInMs, random * minTimeoutInMs * Math.pow(factor, attempt - 1));\n\n  // Round to the nearest integer\n  return Math.round(timeout);\n}\n\nexport function calculateResetAt(\n  resets: string | undefined | null,\n  format:\n    | \"unix_timestamp\"\n    | \"iso_8601\"\n    | \"iso_8601_duration_openai_variant\"\n    | \"unix_timestamp_in_ms\",\n  now: number = Date.now()\n): number | undefined {\n  const resetAt = calculateResetAtInternal(resets, format, new Date(now));\n\n  return resetAt?.getTime();\n}\n", "export type APIHeaders = Record<string, string | null | undefined>;\n\nexport class ApiError extends Error {\n  readonly status: number | undefined;\n  readonly headers: APIHeaders | undefined;\n  readonly error: Object | undefined;\n\n  readonly code: string | null | undefined;\n  readonly param: string | null | undefined;\n  readonly type: string | undefined;\n\n  constructor(\n    status: number | undefined,\n    error: Object | undefined,\n    message: string | undefined,\n    headers: APIHeaders | undefined\n  ) {\n    super(`${ApiError.makeMessage(status, error, message)}`);\n    this.name = \"TriggerApiError\";\n    this.status = status;\n    this.headers = headers;\n\n    const data = error as Record<string, any>;\n    this.error = data;\n    this.code = data?.[\"code\"];\n    this.param = data?.[\"param\"];\n    this.type = data?.[\"type\"];\n  }\n\n  private static makeMessage(status: number | undefined, error: any, message: string | undefined) {\n    const msg = error?.message\n      ? typeof error.message === \"string\"\n        ? error.message\n        : JSON.stringify(error.message)\n      : error\n      ? JSON.stringify(error)\n      : message;\n\n    if (status && msg) {\n      return `${status} ${msg}`;\n    }\n    if (status) {\n      return `${status} status code (no body)`;\n    }\n    if (msg) {\n      return msg;\n    }\n    return \"(no status code or body)\";\n  }\n\n  static generate(\n    status: number | undefined,\n    errorResponse: Object | undefined,\n    message: string | undefined,\n    headers: APIHeaders | undefined\n  ) {\n    if (!status) {\n      return new ApiConnectionError({ cause: castToError(errorResponse) });\n    }\n\n    const error = (errorResponse as Record<string, any>)?.[\"error\"];\n\n    if (status === 400) {\n      return new BadRequestError(status, error, message, headers);\n    }\n\n    if (status === 401) {\n      return new AuthenticationError(status, error, message, headers);\n    }\n\n    if (status === 403) {\n      return new PermissionDeniedError(status, error, message, headers);\n    }\n\n    if (status === 404) {\n      return new NotFoundError(status, error, message, headers);\n    }\n\n    if (status === 409) {\n      return new ConflictError(status, error, message, headers);\n    }\n\n    if (status === 422) {\n      return new UnprocessableEntityError(status, error, message, headers);\n    }\n\n    if (status === 429) {\n      return new RateLimitError(status, error, message, headers);\n    }\n\n    if (status >= 500) {\n      return new InternalServerError(status, error, message, headers);\n    }\n\n    return new ApiError(status, error, message, headers);\n  }\n}\n\nexport class ApiConnectionError extends ApiError {\n  override readonly status: undefined = undefined;\n\n  constructor({ message, cause }: { message?: string; cause?: Error | undefined }) {\n    super(undefined, undefined, message || \"Connection error.\", undefined);\n    // in some environments the 'cause' property is already declared\n    // @ts-ignore\n    if (cause) this.cause = cause;\n  }\n}\n\nexport class BadRequestError extends ApiError {\n  override readonly status: 400 = 400;\n}\n\nexport class AuthenticationError extends ApiError {\n  override readonly status: 401 = 401;\n}\n\nexport class PermissionDeniedError extends ApiError {\n  override readonly status: 403 = 403;\n}\n\nexport class NotFoundError extends ApiError {\n  override readonly status: 404 = 404;\n}\n\nexport class ConflictError extends ApiError {\n  override readonly status: 409 = 409;\n}\n\nexport class UnprocessableEntityError extends ApiError {\n  override readonly status: 422 = 422;\n}\n\nexport class RateLimitError extends ApiError {\n  override readonly status: 429 = 429;\n\n  get millisecondsUntilReset(): number | undefined {\n    // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.\n    const resetAtUnixEpochMs = (this.headers ?? {})[\"x-ratelimit-reset\"];\n\n    if (typeof resetAtUnixEpochMs === \"string\") {\n      const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);\n\n      if (isNaN(resetAtUnixEpoch)) {\n        return;\n      }\n\n      // Add between 0 and 2000ms to the reset time to add jitter\n      return Math.max(resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 2000), 0);\n    }\n  }\n}\n\nexport class InternalServerError extends ApiError {}\n\nfunction castToError(err: any): Error {\n  if (err instanceof Error) return err;\n  return new Error(err);\n}\n", "import { Attributes } from \"@opentelemetry/api\";\n\nexport const NULL_SENTINEL = \"$@null((\";\n\nexport function flattenAttributes(\n  obj: Record<string, unknown> | Array<unknown> | string | boolean | number | null | undefined,\n  prefix?: string\n): Attributes {\n  const result: Attributes = {};\n\n  // Check if obj is null or undefined\n  if (obj === undefined) {\n    return result;\n  }\n\n  if (obj === null) {\n    result[prefix || \"\"] = NULL_SENTINEL;\n    return result;\n  }\n\n  if (typeof obj === \"string\") {\n    result[prefix || \"\"] = obj;\n    return result;\n  }\n\n  if (typeof obj === \"number\") {\n    result[prefix || \"\"] = obj;\n    return result;\n  }\n\n  if (typeof obj === \"boolean\") {\n    result[prefix || \"\"] = obj;\n    return result;\n  }\n\n  for (const [key, value] of Object.entries(obj)) {\n    const newPrefix = `${prefix ? `${prefix}.` : \"\"}${Array.isArray(obj) ? `[${key}]` : key}`;\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        if (typeof value[i] === \"object\" && value[i] !== null) {\n          // update null check here as well\n          Object.assign(result, flattenAttributes(value[i], `${newPrefix}.[${i}]`));\n        } else {\n          if (value[i] === null) {\n            result[`${newPrefix}.[${i}]`] = NULL_SENTINEL;\n          } else {\n            result[`${newPrefix}.[${i}]`] = value[i];\n          }\n        }\n      }\n    } else if (isRecord(value)) {\n      // update null check here\n      Object.assign(result, flattenAttributes(value, newPrefix));\n    } else {\n      if (typeof value === \"number\" || typeof value === \"string\" || typeof value === \"boolean\") {\n        result[newPrefix] = value;\n      } else if (value === null) {\n        result[newPrefix] = NULL_SENTINEL;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\n\nexport function unflattenAttributes(\n  obj: Attributes\n): Record<string, unknown> | string | number | boolean | null | undefined {\n  if (typeof obj !== \"object\" || obj === null || Array.isArray(obj)) {\n    return obj;\n  }\n\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    Object.keys(obj).length === 1 &&\n    Object.keys(obj)[0] === \"\"\n  ) {\n    return rehydrateNull(obj[\"\"]) as any;\n  }\n\n  if (Object.keys(obj).length === 0) {\n    return;\n  }\n\n  const result: Record<string, unknown> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    const parts = key.split(\".\").reduce((acc, part) => {\n      if (part.includes(\"[\")) {\n        // Handling nested array indices\n        const subparts = part.split(/\\[|\\]/).filter((p) => p !== \"\");\n        acc.push(...subparts);\n      } else {\n        acc.push(part);\n      }\n      return acc;\n    }, [] as string[]);\n\n    let current: any = result;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i];\n      const nextPart = parts[i + 1];\n      const isArray = /^\\d+$/.test(nextPart);\n      if (isArray && !Array.isArray(current[part])) {\n        current[part] = [];\n      } else if (!isArray && current[part] === undefined) {\n        current[part] = {};\n      }\n      current = current[part];\n    }\n    const lastPart = parts[parts.length - 1];\n    current[lastPart] = rehydrateNull(value);\n  }\n\n  // Convert the result to an array if all top-level keys are numeric indices\n  if (Object.keys(result).every((k) => /^\\d+$/.test(k))) {\n    const maxIndex = Math.max(...Object.keys(result).map((k) => parseInt(k)));\n    const arrayResult = Array(maxIndex + 1);\n    for (const key in result) {\n      arrayResult[parseInt(key)] = result[key];\n    }\n    return arrayResult as any;\n  }\n\n  return result;\n}\n\nexport function primitiveValueOrflattenedAttributes(\n  obj: Record<string, unknown> | Array<unknown> | string | boolean | number | undefined,\n  prefix: string | undefined\n): Attributes | string | number | boolean | undefined {\n  if (\n    typeof obj === \"string\" ||\n    typeof obj === \"number\" ||\n    typeof obj === \"boolean\" ||\n    obj === null ||\n    obj === undefined\n  ) {\n    return obj;\n  }\n\n  const attributes = flattenAttributes(obj, prefix);\n\n  if (\n    prefix !== undefined &&\n    typeof attributes[prefix] !== \"undefined\" &&\n    attributes[prefix] !== null\n  ) {\n    return attributes[prefix] as unknown as Attributes;\n  }\n\n  return attributes;\n}\n\nfunction rehydrateNull(value: any): any {\n  if (value === NULL_SENTINEL) {\n    return null;\n  }\n\n  return value;\n}\n", "import { Attributes } from \"@opentelemetry/api\";\nimport { Accessory } from \"../schemas\";\nimport { flattenAttributes } from \"./flattenAttributes\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\n\nexport function accessoryAttributes(accessory: Accessory): Attributes {\n  return flattenAttributes(accessory, SemanticInternalAttributes.STYLE_ACCESSORY);\n}\n", "export interface CursorPageParams {\n  limit?: number;\n  after?: string;\n  before?: string;\n}\n\nexport interface OffsetLimitPageParams {\n  limit?: number;\n  page?: number;\n}\n\nexport interface PageResponse<Item> {\n  data: Array<Item>;\n}\n\nexport interface CursorPageResponse<Item> extends PageResponse<Item> {\n  pagination: {\n    next?: string;\n    previous?: string;\n  };\n}\n\nexport interface OffsetLimitPageResponse<Item> extends PageResponse<Item> {\n  pagination: {\n    currentPage: number;\n    totalPages: number;\n    count: number;\n  };\n}\n\nexport interface Page<Item> {\n  getPaginatedItems(): Item[];\n  hasNextPage(): boolean;\n  hasPreviousPage(): boolean;\n}\n\nexport class CursorPage<Item> implements CursorPageResponse<Item>, Page<Item>, AsyncIterable<Item> {\n  data: Array<Item>;\n  pagination: { next?: string; previous?: string };\n\n  constructor(\n    data: Array<Item>,\n    pagination: { next?: string; previous?: string },\n    private pageFetcher: (params: Omit<CursorPageParams, \"limit\">) => Promise<CursorPage<Item>>\n  ) {\n    this.data = data;\n    this.pagination = pagination;\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data ?? [];\n  }\n\n  hasNextPage(): boolean {\n    return !!this.pagination.next;\n  }\n\n  hasPreviousPage(): boolean {\n    return !!this.pagination.previous;\n  }\n\n  getNextPage(): Promise<CursorPage<Item>> {\n    if (!this.pagination.next) {\n      throw new Error(\"No next page available\");\n    }\n\n    return this.pageFetcher({ after: this.pagination.next });\n  }\n\n  getPreviousPage(): Promise<CursorPage<Item>> {\n    if (!this.pagination.previous) {\n      throw new Error(\"No previous page available\");\n    }\n\n    return this.pageFetcher({ before: this.pagination.previous });\n  }\n\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page: CursorPage<Item> = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n\nexport class OffsetLimitPage<Item>\n  implements OffsetLimitPageResponse<Item>, Page<Item>, AsyncIterable<Item>\n{\n  data: Array<Item>;\n  pagination: { currentPage: number; totalPages: number; count: number };\n\n  constructor(\n    data: Array<Item>,\n    pagination: { currentPage: number; totalPages: number; count: number },\n    private pageFetcher: (\n      params: Omit<OffsetLimitPageParams, \"limit\">\n    ) => Promise<OffsetLimitPage<Item>>\n  ) {\n    this.data = data;\n    this.pagination = pagination;\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data ?? [];\n  }\n\n  hasNextPage(): boolean {\n    return this.pagination.currentPage < this.pagination.totalPages;\n  }\n\n  hasPreviousPage(): boolean {\n    return this.pagination.currentPage > 1;\n  }\n\n  getNextPage(): Promise<OffsetLimitPage<Item>> {\n    if (!this.hasNextPage()) {\n      throw new Error(\"No next page available\");\n    }\n\n    return this.pageFetcher({\n      page: this.pagination.currentPage + 1,\n    });\n  }\n\n  getPreviousPage(): Promise<OffsetLimitPage<Item>> {\n    if (!this.hasPreviousPage()) {\n      throw new Error(\"No previous page available\");\n    }\n\n    return this.pageFetcher({\n      page: this.pagination.currentPage - 1,\n    });\n  }\n\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page: OffsetLimitPage<Item> = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n", "import { PreciseDate } from \"@google-cloud/precise-date\";\nimport { Clock } from \"./clock\";\n\nexport class SimpleClock implements Clock {\n  preciseNow(): [number, number] {\n    const now = new PreciseDate();\n    const nowStruct = now.toStruct();\n\n    return [nowStruct.seconds, nowStruct.nanos];\n  }\n\n  reset() {\n    // do nothing\n  }\n}\n", "const API_NAME = \"clock\";\n\nimport { getGlobal, registerGlobal } from \"../utils/globals\";\nimport type { Clock, ClockTime } from \"./clock\";\nimport { SimpleClock } from \"./simpleClock\";\n\nconst SIMPLE_CLOCK = new SimpleClock();\n\nexport class ClockAPI {\n  private static _instance?: ClockAPI;\n\n  private constructor() {}\n\n  public static getInstance(): ClockAPI {\n    if (!this._instance) {\n      this._instance = new ClockAPI();\n    }\n\n    return this._instance;\n  }\n\n  public setGlobalClock(clock: Clock): boolean {\n    return registerGlobal(API_NAME, clock);\n  }\n\n  public preciseNow(): ClockTime {\n    return this.#getClock().preciseNow();\n  }\n\n  public reset(): void {\n    this.#getClock().reset();\n  }\n\n  #getClock(): Clock {\n    return getGlobal(API_NAME) ?? SIMPLE_CLOCK;\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { ClockAPI } from \"./clock\";\n/** Entrypoint for clock API */\nexport const clock = ClockAPI.getInstance();\n", "import { AttributeValue, Attributes } from \"@opentelemetry/api\";\n\nexport const OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT = 256;\nexport const OTEL_LOG_ATTRIBUTE_COUNT_LIMIT = 256;\nexport const OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT = 1028;\nexport const OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT = 1028;\nexport const OTEL_SPAN_EVENT_COUNT_LIMIT = 10;\nexport const OTEL_LINK_COUNT_LIMIT = 2;\nexport const OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 10;\nexport const OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 10;\nexport const OFFLOAD_IO_PACKET_LENGTH_LIMIT = 128 * 1024;\n\nexport function imposeAttributeLimits(attributes: Attributes): Attributes {\n  const newAttributes: Attributes = {};\n\n  for (const [key, value] of Object.entries(attributes)) {\n    if (calculateAttributeValueLength(value) > OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) {\n      continue;\n    }\n\n    if (Object.keys(newAttributes).length >= OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) {\n      break;\n    }\n\n    newAttributes[key] = value;\n  }\n\n  return newAttributes;\n}\n\nfunction calculateAttributeValueLength(value: AttributeValue | undefined | null): number {\n  if (value === undefined || value === null) {\n    return 0;\n  }\n\n  if (typeof value === \"string\") {\n    return value.length;\n  }\n\n  if (typeof value === \"number\") {\n    return 8;\n  }\n\n  if (typeof value === \"boolean\") {\n    return 4;\n  }\n\n  if (Array.isArray(value)) {\n    return value.reduce((acc: number, v) => acc + calculateAttributeValueLength(v), 0);\n  }\n\n  return 0;\n}\n", "import { Attributes, Span, SpanOptions } from \"@opentelemetry/api\";\nimport { Logger, SeverityNumber } from \"@opentelemetry/api-logs\";\nimport { iconStringForSeverity } from \"../icons\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { TriggerTracer } from \"../tracer\";\nimport { flattenAttributes } from \"../utils/flattenAttributes\";\nimport { ClockTime } from \"../clock/clock\";\nimport { clock } from \"../clock-api\";\n\nexport type LogLevel = \"none\" | \"error\" | \"warn\" | \"info\" | \"debug\" | \"log\";\n\nexport const logLevels: Array<LogLevel> = [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\nexport type TaskLoggerConfig = {\n  logger: Logger;\n  tracer: TriggerTracer;\n  level: LogLevel;\n};\n\nexport interface TaskLogger {\n  debug(message: string, properties?: Record<string, unknown>): void;\n  log(message: string, properties?: Record<string, unknown>): void;\n  info(message: string, properties?: Record<string, unknown>): void;\n  warn(message: string, properties?: Record<string, unknown>): void;\n  error(message: string, properties?: Record<string, unknown>): void;\n  trace<T>(name: string, fn: (span: Span) => Promise<T>, options?: SpanOptions): Promise<T>;\n}\n\nexport class OtelTaskLogger implements TaskLogger {\n  private readonly _level: number;\n\n  constructor(private readonly _config: TaskLoggerConfig) {\n    this._level = logLevels.indexOf(_config.level);\n  }\n\n  debug(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 4) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"debug\", SeverityNumber.DEBUG, properties);\n  }\n\n  log(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 3) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"log\", SeverityNumber.INFO, properties);\n  }\n\n  info(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 3) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"info\", SeverityNumber.INFO, properties);\n  }\n\n  warn(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 2) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"warn\", SeverityNumber.WARN, properties);\n  }\n\n  error(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 1) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"error\", SeverityNumber.ERROR, properties);\n  }\n\n  #emitLog(\n    message: string,\n    timestamp: ClockTime,\n    severityText: string,\n    severityNumber: SeverityNumber,\n    properties?: Record<string, unknown>\n  ) {\n    let attributes: Attributes = { ...flattenAttributes(safeJsonProcess(properties)) };\n\n    const icon = iconStringForSeverity(severityNumber);\n    if (icon !== undefined) {\n      attributes[SemanticInternalAttributes.STYLE_ICON] = icon;\n    }\n\n    this._config.logger.emit({\n      severityNumber,\n      severityText,\n      body: message,\n      attributes,\n      timestamp,\n    });\n  }\n\n  trace<T>(name: string, fn: (span: Span) => Promise<T>, options?: SpanOptions): Promise<T> {\n    return this._config.tracer.startActiveSpan(name, fn, options);\n  }\n\n  #getTimestampInHrTime(): ClockTime {\n    return clock.preciseNow();\n  }\n}\n\nexport class NoopTaskLogger implements TaskLogger {\n  debug() {}\n  log() {}\n  info() {}\n  warn() {}\n  error() {}\n  trace<T>(name: string, fn: (span: Span) => Promise<T>): Promise<T> {\n    return fn({} as Span);\n  }\n}\n\nfunction safeJsonProcess(value?: Record<string, unknown>): Record<string, unknown> | undefined {\n  try {\n    return JSON.parse(JSON.stringify(value, jsonErrorReplacer));\n  } catch {\n    return value;\n  }\n}\n\nfunction jsonErrorReplacer(key: string, value: unknown) {\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: value.message,\n      stack: value.stack,\n    };\n  }\n\n  return value;\n}\n", "import { NoopTaskLogger, TaskLogger } from \"./taskLogger\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport { Span } from \"@opentelemetry/api\";\n\nconst API_NAME = \"logger\";\n\nconst NOOP_TASK_LOGGER = new NoopTaskLogger();\n\nexport class LoggerAPI implements TaskLogger {\n  private static _instance?: LoggerAPI;\n\n  private constructor() {}\n\n  public static getInstance(): LoggerAPI {\n    if (!this._instance) {\n      this._instance = new LoggerAPI();\n    }\n\n    return this._instance;\n  }\n\n  public disable() {\n    unregisterGlobal(API_NAME);\n  }\n\n  public setGlobalTaskLogger(taskLogger: TaskLogger): boolean {\n    return registerGlobal(API_NAME, taskLogger);\n  }\n\n  public debug(message: string, metadata?: Record<string, unknown>) {\n    this.#getTaskLogger().debug(message, metadata);\n  }\n\n  public log(message: string, metadata?: Record<string, unknown>) {\n    this.#getTaskLogger().log(message, metadata);\n  }\n\n  public info(message: string, metadata?: Record<string, unknown>) {\n    this.#getTaskLogger().info(message, metadata);\n  }\n\n  public warn(message: string, metadata?: Record<string, unknown>) {\n    this.#getTaskLogger().warn(message, metadata);\n  }\n\n  public error(message: string, metadata?: Record<string, unknown>) {\n    this.#getTaskLogger().error(message, metadata);\n  }\n\n  public trace<T>(name: string, fn: (span: Span) => Promise<T>): Promise<T> {\n    return this.#getTaskLogger().trace(name, fn);\n  }\n\n  #getTaskLogger(): TaskLogger {\n    return getGlobal(API_NAME) ?? NOOP_TASK_LOGGER;\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { LoggerAPI } from \"./logger\";\n/** Entrypoint for logger API */\nexport const logger = LoggerAPI.getInstance();\n", "import { BatchTaskRunExecutionResult, TaskRunContext, TaskRunExecutionResult } from \"../schemas\";\nimport { RuntimeManager } from \"./manager\";\n\nexport class NoopRuntimeManager implements RuntimeManager {\n  disable(): void {\n    // do nothing\n  }\n\n  waitForDuration(ms: number): Promise<void> {\n    return Promise.resolve();\n  }\n\n  waitUntil(date: Date): Promise<void> {\n    return Promise.resolve();\n  }\n\n  waitForTask(params: { id: string; ctx: TaskRunContext }): Promise<TaskRunExecutionResult> {\n    return Promise.resolve({\n      ok: false,\n      id: params.id,\n      error: { type: \"INTERNAL_ERROR\", code: \"CONFIGURED_INCORRECTLY\" },\n    });\n  }\n\n  waitForBatch(params: {\n    id: string;\n    runs: string[];\n    ctx: TaskRunContext;\n  }): Promise<BatchTaskRunExecutionResult> {\n    return Promise.resolve({\n      id: params.id,\n      items: [],\n    });\n  }\n}\n", "import { UsageManager, UsageMeasurement, UsageSample } from \"./types\";\n\nexport class NoopUsageManager implements UsageManager {\n  disable(): void {\n    // Noop\n  }\n\n  start(): UsageMeasurement {\n    return {\n      sample: () => ({ cpuTime: 0, wallTime: 0 }),\n    };\n  }\n\n  stop(measurement: UsageMeasurement): UsageSample {\n    return measurement.sample();\n  }\n\n  pauseAsync<T>(cb: () => Promise<T>): Promise<T> {\n    return cb();\n  }\n\n  sample(): UsageSample | undefined {\n    return undefined;\n  }\n}\n", "const API_NAME = \"usage\";\n\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport type { UsageManager, UsageMeasurement, UsageSample } from \"./types\";\nimport { NoopUsageManager } from \"./noopUsageManager\";\n\nconst NOOP_USAGE_MANAGER = new NoopUsageManager();\n\nexport class UsageAPI implements UsageManager {\n  private static _instance?: UsageAPI;\n\n  private constructor() {}\n\n  public static getInstance(): UsageAPI {\n    if (!this._instance) {\n      this._instance = new UsageAPI();\n    }\n\n    return this._instance;\n  }\n\n  public setGlobalUsageManager(manager: UsageManager): boolean {\n    return registerGlobal(API_NAME, manager);\n  }\n\n  public disable() {\n    this.#getUsageManager().disable();\n    unregisterGlobal(API_NAME);\n  }\n\n  public start(): UsageMeasurement {\n    return this.#getUsageManager().start();\n  }\n\n  public stop(measurement: UsageMeasurement): UsageSample {\n    return this.#getUsageManager().stop(measurement);\n  }\n\n  public pauseAsync<T>(cb: () => Promise<T>): Promise<T> {\n    return this.#getUsageManager().pauseAsync(cb);\n  }\n\n  public sample(): UsageSample | undefined {\n    return this.#getUsageManager().sample();\n  }\n\n  #getUsageManager(): UsageManager {\n    return getGlobal(API_NAME) ?? NOOP_USAGE_MANAGER;\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { UsageAPI } from \"./usage/api\";\n/** Entrypoint for usage API */\nexport const usage = UsageAPI.getInstance();\n", "const API_NAME = \"runtime\";\n\nimport { BatchTaskRunExecutionResult, TaskRunContext, TaskRunExecutionResult } from \"../schemas\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport { type RuntimeManager } from \"./manager\";\nimport { NoopRuntimeManager } from \"./noopRuntimeManager\";\nimport { usage } from \"../usage-api\";\n\nconst NOOP_RUNTIME_MANAGER = new NoopRuntimeManager();\n\nexport class RuntimeAPI {\n  private static _instance?: RuntimeAPI;\n\n  private constructor() {}\n\n  public static getInstance(): RuntimeAPI {\n    if (!this._instance) {\n      this._instance = new RuntimeAPI();\n    }\n\n    return this._instance;\n  }\n\n  public waitForDuration(ms: number): Promise<void> {\n    return usage.pauseAsync(() => this.#getRuntimeManager().waitForDuration(ms));\n  }\n\n  public waitUntil(date: Date): Promise<void> {\n    return usage.pauseAsync(() => this.#getRuntimeManager().waitUntil(date));\n  }\n\n  public waitForTask(params: { id: string; ctx: TaskRunContext }): Promise<TaskRunExecutionResult> {\n    return usage.pauseAsync(() => this.#getRuntimeManager().waitForTask(params));\n  }\n\n  public waitForBatch(params: {\n    id: string;\n    runs: string[];\n    ctx: TaskRunContext;\n  }): Promise<BatchTaskRunExecutionResult> {\n    return usage.pauseAsync(() => this.#getRuntimeManager().waitForBatch(params));\n  }\n\n  public setGlobalRuntimeManager(runtimeManager: RuntimeManager): boolean {\n    return registerGlobal(API_NAME, runtimeManager);\n  }\n\n  public disable() {\n    this.#getRuntimeManager().disable();\n    unregisterGlobal(API_NAME);\n  }\n\n  #getRuntimeManager(): RuntimeManager {\n    return getGlobal(API_NAME) ?? NOOP_RUNTIME_MANAGER;\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { RuntimeAPI } from \"./runtime\";\n/** Entrypoint for runtime API */\nexport const runtime = RuntimeAPI.getInstance();\n", "export function getEnvVar(name: string): string | undefined {\n  // This could run in a non-Node.js environment (Bun, Deno, CF Worker, etc.), so don't just assume process.env is a thing\n  if (typeof process !== \"undefined\" && typeof process.env === \"object\" && process.env !== null) {\n    return process.env[name];\n  }\n}\n", "import { ApiClient } from \"../apiClient\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport { getEnvVar } from \"../utils/getEnv\";\nimport { ApiClientConfiguration } from \"./types\";\n\nconst API_NAME = \"api-client\";\n\nexport class APIClientManagerAPI {\n  private static _instance?: APIClientManagerAPI;\n\n  private constructor() {}\n\n  public static getInstance(): APIClientManagerAPI {\n    if (!this._instance) {\n      this._instance = new APIClientManagerAPI();\n    }\n\n    return this._instance;\n  }\n\n  public disable() {\n    unregisterGlobal(API_NAME);\n  }\n\n  public setGlobalAPIClientConfiguration(config: ApiClientConfiguration): boolean {\n    return registerGlobal(API_NAME, config);\n  }\n\n  get baseURL(): string | undefined {\n    const store = this.#getConfig();\n    return store?.baseURL ?? getEnvVar(\"TRIGGER_API_URL\") ?? \"https://api.trigger.dev\";\n  }\n\n  get accessToken(): string | undefined {\n    const store = this.#getConfig();\n    return store?.secretKey ?? getEnvVar(\"TRIGGER_SECRET_KEY\") ?? getEnvVar(\"TRIGGER_ACCESS_TOKEN\");\n  }\n\n  get client(): ApiClient | undefined {\n    if (!this.baseURL || !this.accessToken) {\n      return undefined;\n    }\n\n    return new ApiClient(this.baseURL, this.accessToken);\n  }\n\n  #getConfig(): ApiClientConfiguration | undefined {\n    return getGlobal(API_NAME);\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { APIClientManagerAPI } from \"./apiClientManager\";\n/** Entrypoint for logger API */\nexport const apiClientManager = APIClientManagerAPI.getInstance();\n\nexport type { ApiClientConfiguration } from \"./apiClientManager/types\";\n", "import { TaskFileMetadata, TaskMetadataWithFilePath } from \"../schemas\";\nimport { TaskMetadataWithFunctions } from \"../types\";\nimport { TaskCatalog } from \"./catalog\";\n\nexport class NoopTaskCatalog implements TaskCatalog {\n  registerTaskMetadata(task: TaskMetadataWithFunctions): void {\n    // noop\n  }\n\n  registerTaskFileMetadata(id: string, metadata: TaskFileMetadata): void {\n    // noop\n  }\n\n  updateTaskMetadata(id: string, updates: Partial<TaskMetadataWithFunctions>): void {\n    // noop\n  }\n\n  getAllTaskMetadata(): Array<TaskMetadataWithFilePath> {\n    return [];\n  }\n\n  getTaskMetadata(id: string): TaskMetadataWithFilePath | undefined {\n    return undefined;\n  }\n\n  getTask(id: string): TaskMetadataWithFunctions | undefined {\n    return undefined;\n  }\n\n  taskExists(id: string): boolean {\n    return false;\n  }\n\n  disable() {\n    // noop\n  }\n}\n", "const API_NAME = \"task-catalog\";\n\nimport { TaskFileMetadata, TaskMetadataWithFilePath } from \"../schemas\";\nimport { TaskMetadataWithFunctions } from \"../types\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport { type TaskCatalog } from \"./catalog\";\nimport { NoopTaskCatalog } from \"./noopTaskCatalog\";\n\nconst NOOP_TASK_CATALOG = new NoopTaskCatalog();\n\nexport class TaskCatalogAPI {\n  private static _instance?: TaskCatalogAPI;\n\n  private constructor() {}\n\n  public static getInstance(): TaskCatalogAPI {\n    if (!this._instance) {\n      this._instance = new TaskCatalogAPI();\n    }\n\n    return this._instance;\n  }\n\n  public setGlobalTaskCatalog(taskCatalog: TaskCatalog): boolean {\n    return registerGlobal(API_NAME, taskCatalog);\n  }\n\n  public disable() {\n    unregisterGlobal(API_NAME);\n  }\n\n  public registerTaskMetadata(task: TaskMetadataWithFunctions): void {\n    this.#getCatalog().registerTaskMetadata(task);\n  }\n\n  public updateTaskMetadata(id: string, updates: Partial<TaskMetadataWithFunctions>): void {\n    this.#getCatalog().updateTaskMetadata(id, updates);\n  }\n\n  public registerTaskFileMetadata(id: string, metadata: TaskFileMetadata): void {\n    this.#getCatalog().registerTaskFileMetadata(id, metadata);\n  }\n\n  public getAllTaskMetadata(): Array<TaskMetadataWithFilePath> {\n    return this.#getCatalog().getAllTaskMetadata();\n  }\n\n  public getTaskMetadata(id: string): TaskMetadataWithFilePath | undefined {\n    return this.#getCatalog().getTaskMetadata(id);\n  }\n\n  public getTask(id: string): TaskMetadataWithFunctions | undefined {\n    return this.#getCatalog().getTask(id);\n  }\n\n  public taskExists(id: string): boolean {\n    return this.#getCatalog().taskExists(id);\n  }\n\n  #getCatalog(): TaskCatalog {\n    return getGlobal(API_NAME) ?? NOOP_TASK_CATALOG;\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TaskCatalogAPI } from \"./task-catalog\";\n/** Entrypoint for runtime API */\nexport const taskCatalog = TaskCatalogAPI.getInstance();\n", "import humanizeDuration, { Unit } from \"humanize-duration\";\n\nfunction dateDifference(date1: Date, date2: Date) {\n  return Math.abs(date1.getTime() - date2.getTime());\n}\n\ntype DurationOptions = {\n  style?: \"long\" | \"short\";\n  maxDecimalPoints?: number;\n  units?: Unit[];\n};\n\nexport function formatDuration(\n  start?: Date | null,\n  end?: Date | null,\n  options?: DurationOptions\n): string {\n  if (!start || !end) {\n    return \"–\";\n  }\n\n  return formatDurationMilliseconds(dateDifference(start, end), options);\n}\n\nexport function nanosecondsToMilliseconds(nanoseconds: number): number {\n  return nanoseconds / 1_000_000;\n}\n\nexport function millisecondsToNanoseconds(milliseconds: number): number {\n  return milliseconds * 1_000_000;\n}\n\nexport function formatDurationNanoseconds(nanoseconds: number, options?: DurationOptions): string {\n  return formatDurationMilliseconds(nanosecondsToMilliseconds(nanoseconds), options);\n}\n\nconst aboveOneSecondUnits = [\"d\", \"h\", \"m\", \"s\"] as Unit[];\nconst belowOneSecondUnits = [\"ms\"] as Unit[];\n\nexport function formatDurationMilliseconds(\n  milliseconds: number,\n  options?: DurationOptions\n): string {\n  let duration = humanizeDuration(milliseconds, {\n    units: options?.units\n      ? options.units\n      : milliseconds < 1000\n      ? belowOneSecondUnits\n      : aboveOneSecondUnits,\n    maxDecimalPoints: options?.maxDecimalPoints ?? 1,\n    largest: 2,\n  });\n\n  if (!options) {\n    return duration;\n  }\n\n  switch (options.style) {\n    case \"short\":\n      duration = duration.replace(\" milliseconds\", \"ms\");\n      duration = duration.replace(\" millisecond\", \"ms\");\n      duration = duration.replace(\" seconds\", \"s\");\n      duration = duration.replace(\" second\", \"s\");\n      duration = duration.replace(\" minutes\", \"m\");\n      duration = duration.replace(\" minute\", \"m\");\n      duration = duration.replace(\" hours\", \"h\");\n      duration = duration.replace(\" hour\", \"h\");\n      duration = duration.replace(\" days\", \"d\");\n      duration = duration.replace(\" day\", \"d\");\n      duration = duration.replace(\" weeks\", \"w\");\n      duration = duration.replace(\" week\", \"w\");\n      duration = duration.replace(\" months\", \"mo\");\n      duration = duration.replace(\" month\", \"mo\");\n      duration = duration.replace(\" years\", \"y\");\n      duration = duration.replace(\" year\", \"y\");\n  }\n\n  return duration;\n}\n\nexport function formatDurationInDays(milliseconds: number): string {\n  let duration = humanizeDuration(milliseconds, {\n    maxDecimalPoints: 0,\n    largest: 2,\n    units: [\"d\"],\n  });\n\n  return duration;\n}\n", "import {\n  Context,\n  SpanOptions,\n  SpanStatusCode,\n  context,\n  propagation,\n  trace,\n  type Span,\n  type Tracer,\n} from \"@opentelemetry/api\";\nimport { Logger, logs } from \"@opentelemetry/api-logs\";\nimport { SemanticInternalAttributes } from \"./semanticInternalAttributes\";\nimport { clock } from \"./clock-api\";\nimport { usage } from \"./usage-api\";\nimport { taskContext } from \"./task-context-api\";\n\nexport type TriggerTracerConfig =\n  | {\n      name: string;\n      version: string;\n    }\n  | {\n      tracer: Tracer;\n      logger: Logger;\n    };\n\nexport class TriggerTracer {\n  constructor(private readonly _config: TriggerTracerConfig) {}\n\n  private _tracer: Tracer | undefined;\n  private get tracer(): Tracer {\n    if (!this._tracer) {\n      if (\"tracer\" in this._config) return this._config.tracer;\n\n      this._tracer = trace.getTracer(this._config.name, this._config.version);\n    }\n\n    return this._tracer;\n  }\n\n  private _logger: Logger | undefined;\n  private get logger(): Logger {\n    if (!this._logger) {\n      if (\"logger\" in this._config) return this._config.logger;\n\n      this._logger = logs.getLogger(this._config.name, this._config.version);\n    }\n\n    return this._logger;\n  }\n\n  extractContext(traceContext?: Record<string, unknown>) {\n    return propagation.extract(context.active(), traceContext ?? {});\n  }\n\n  startActiveSpan<T>(\n    name: string,\n    fn: (span: Span) => Promise<T>,\n    options?: SpanOptions,\n    ctx?: Context\n  ): Promise<T> {\n    const parentContext = ctx ?? context.active();\n\n    const attributes = options?.attributes ?? {};\n\n    return this.tracer.startActiveSpan(\n      name,\n      {\n        ...options,\n        attributes,\n        startTime: clock.preciseNow(),\n      },\n      parentContext,\n      async (span) => {\n        if (taskContext.ctx) {\n          this.tracer\n            .startSpan(\n              name,\n              {\n                ...options,\n                attributes: {\n                  ...attributes,\n                  [SemanticInternalAttributes.SPAN_PARTIAL]: true,\n                  [SemanticInternalAttributes.SPAN_ID]: span.spanContext().spanId,\n                },\n              },\n              parentContext\n            )\n            .end();\n        }\n\n        const usageMeasurement = usage.start();\n\n        try {\n          return await fn(span);\n        } catch (e) {\n          if (typeof e === \"string\" || e instanceof Error) {\n            span.recordException(e);\n          }\n\n          span.setStatus({ code: SpanStatusCode.ERROR });\n\n          throw e;\n        } finally {\n          if (taskContext.ctx) {\n            const usageSample = usage.stop(usageMeasurement);\n            const machine = taskContext.ctx.machine;\n\n            span.setAttributes({\n              [SemanticInternalAttributes.USAGE_DURATION_MS]: usageSample.cpuTime,\n              [SemanticInternalAttributes.USAGE_COST_IN_CENTS]: machine?.centsPerMs\n                ? usageSample.cpuTime * machine.centsPerMs\n                : 0,\n            });\n          }\n\n          span.end(clock.preciseNow());\n        }\n      }\n    );\n  }\n\n  startSpan(name: string, options?: SpanOptions, ctx?: Context) {\n    const parentContext = ctx ?? context.active();\n\n    const attributes = options?.attributes ?? {};\n\n    const span = this.tracer.startSpan(name, options, ctx);\n\n    this.tracer\n      .startSpan(\n        name,\n        {\n          ...options,\n          attributes: {\n            ...attributes,\n            [SemanticInternalAttributes.SPAN_PARTIAL]: true,\n            [SemanticInternalAttributes.SPAN_ID]: span.spanContext().spanId,\n          },\n        },\n        parentContext\n      )\n      .end();\n\n    return span;\n  }\n}\n", "import { EventFilter } from \"./schemas/eventFilter\";\n\n// EventFilter is a recursive type, where the keys are strings and the values are an array of strings, numbers, booleans, or objects.\n// If the values of the array are strings, numbers, or booleans, than we are matching against the value of the payload.\n// If the values of the array are objects, then we are doing content filtering\n// An example would be [{ $endsWith: \".png\" }, { $startsWith: \"images/\" } ]\nexport function eventFilterMatches(payload: any, filter: EventFilter): boolean {\n  if (payload === undefined || payload === null) {\n    if (Object.entries(filter).length === 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  for (const [patternKey, patternValue] of Object.entries(filter)) {\n    const payloadValue = payload[patternKey];\n\n    if (Array.isArray(patternValue)) {\n      if (patternValue.length === 0) {\n        continue;\n      }\n\n      // Check to see if all the items in the array are a string\n      if ((patternValue as unknown[]).every((item) => typeof item === \"string\")) {\n        if ((patternValue as string[]).includes(payloadValue)) {\n          continue;\n        }\n\n        return false;\n      }\n\n      // Check to see if all the items in the array are a number\n      if ((patternValue as unknown[]).every((item) => typeof item === \"number\")) {\n        if ((patternValue as number[]).includes(payloadValue)) {\n          continue;\n        }\n\n        return false;\n      }\n\n      // Check to see if all the items in the array are a boolean\n      if ((patternValue as unknown[]).every((item) => typeof item === \"boolean\")) {\n        if ((patternValue as boolean[]).includes(payloadValue)) {\n          continue;\n        }\n\n        return false;\n      }\n\n      // Now we know that all the items in the array are objects\n      const objectArray = patternValue as Exclude<\n        typeof patternValue,\n        number[] | string[] | boolean[]\n      >;\n\n      if (!contentFiltersMatches(payloadValue, objectArray)) {\n        return false;\n      }\n\n      continue;\n    } else if (typeof patternValue === \"object\") {\n      if (Array.isArray(payloadValue)) {\n        if (!payloadValue.some((item) => eventFilterMatches(item, patternValue))) {\n          return false;\n        }\n      } else {\n        if (!eventFilterMatches(payloadValue, patternValue)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\ntype ContentFilters = Exclude<EventFilter[string], EventFilter | string[] | number[] | boolean[]>;\n\nfunction contentFiltersMatches(actualValue: any, contentFilters: ContentFilters): boolean {\n  for (const contentFilter of contentFilters) {\n    if (typeof contentFilter === \"object\") {\n      const [key, value] = Object.entries(contentFilter)[0];\n\n      if (!contentFilterMatches(actualValue, contentFilter)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction contentFilterMatches(actualValue: any, contentFilter: ContentFilters[number]): boolean {\n  if (\"$endsWith\" in contentFilter) {\n    if (typeof actualValue !== \"string\") {\n      return false;\n    }\n\n    return actualValue.endsWith(contentFilter.$endsWith);\n  }\n\n  if (\"$startsWith\" in contentFilter) {\n    if (typeof actualValue !== \"string\") {\n      return false;\n    }\n\n    return actualValue.startsWith(contentFilter.$startsWith);\n  }\n\n  if (\"$anythingBut\" in contentFilter) {\n    if (Array.isArray(contentFilter.$anythingBut)) {\n      if ((contentFilter.$anythingBut as any[]).includes(actualValue)) {\n        return false;\n      }\n    }\n\n    if (contentFilter.$anythingBut === actualValue) {\n      return false;\n    }\n\n    return true;\n  }\n\n  if (\"$exists\" in contentFilter) {\n    if (contentFilter.$exists) {\n      return actualValue !== undefined;\n    }\n\n    return actualValue === undefined;\n  }\n\n  if (\"$gt\" in contentFilter) {\n    if (typeof actualValue !== \"number\") {\n      return false;\n    }\n\n    return actualValue > contentFilter.$gt;\n  }\n\n  if (\"$lt\" in contentFilter) {\n    if (typeof actualValue !== \"number\") {\n      return false;\n    }\n\n    return actualValue < contentFilter.$lt;\n  }\n\n  if (\"$gte\" in contentFilter) {\n    if (typeof actualValue !== \"number\") {\n      return false;\n    }\n\n    return actualValue >= contentFilter.$gte;\n  }\n\n  if (\"$lte\" in contentFilter) {\n    if (typeof actualValue !== \"number\") {\n      return false;\n    }\n\n    return actualValue <= contentFilter.$lte;\n  }\n\n  if (\"$between\" in contentFilter) {\n    if (typeof actualValue !== \"number\") {\n      return false;\n    }\n\n    return actualValue >= contentFilter.$between[0] && actualValue <= contentFilter.$between[1];\n  }\n\n  if (\"$includes\" in contentFilter) {\n    if (Array.isArray(actualValue)) {\n      return actualValue.includes(contentFilter.$includes);\n    }\n\n    return false;\n  }\n\n  // Use localCompare\n  if (\"$ignoreCaseEquals\" in contentFilter) {\n    if (typeof actualValue !== \"string\") {\n      return false;\n    }\n\n    return (\n      actualValue.localeCompare(contentFilter.$ignoreCaseEquals, undefined, {\n        sensitivity: \"accent\",\n      }) === 0\n    );\n  }\n\n  if (\"$isNull\" in contentFilter) {\n    if (contentFilter.$isNull) {\n      return actualValue === null;\n    }\n\n    return actualValue !== null;\n  }\n\n  if (\"$not\" in contentFilter) {\n    if (Array.isArray(actualValue)) {\n      return !actualValue.includes(contentFilter.$not);\n    } else if (typeof actualValue === 'number' || typeof actualValue === 'boolean' || typeof actualValue === 'string') {\n      return actualValue !== contentFilter.$not;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n", "export function omit<T extends Record<string, any>, K extends keyof T>(\n  obj: T,\n  ...keys: K[]\n): Omit<T, K> {\n  const result: Record<string, any> = {};\n\n  for (const key in obj) {\n    if (!keys.includes(key as unknown as K)) {\n      result[key] = obj[key];\n    }\n  }\n\n  return result as Omit<T, K>;\n}\n", "import { dependencies } from \"../../../package.json\"\n\nexport function detectDependencyVersion(dependency: string): string | undefined {\n  return (dependencies as Record<string, string>)[dependency]\n}", "import { Attributes, Span } from \"@opentelemetry/api\";\nimport { OFFLOAD_IO_PACKET_LENGTH_LIMIT, imposeAttributeLimits } from \"../limits\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { TriggerTracer } from \"../tracer\";\nimport { flattenAttributes } from \"./flattenAttributes\";\nimport { apiClientManager } from \"../apiClientManager-api\";\n\nexport type IOPacket = {\n  data?: string | undefined;\n  dataType: string;\n};\n\nexport async function parsePacket(value: IOPacket): Promise<any> {\n  if (!value.data) {\n    return undefined;\n  }\n\n  switch (value.dataType) {\n    case \"application/json\":\n      return JSON.parse(value.data);\n    case \"application/super+json\":\n      const { parse } = await loadSuperJSON();\n\n      return parse(value.data);\n    case \"text/plain\":\n      return value.data;\n    case \"application/store\":\n      throw new Error(\n        `Cannot parse an application/store packet (${value.data}). Needs to be imported first.`\n      );\n    default:\n      return value.data;\n  }\n}\n\nexport async function stringifyIO(value: any): Promise<IOPacket> {\n  if (value === undefined) {\n    return { dataType: \"application/json\" };\n  }\n\n  if (typeof value === \"string\") {\n    return { data: value, dataType: \"text/plain\" };\n  }\n\n  try {\n    const { stringify } = await loadSuperJSON();\n    const data = stringify(value);\n\n    return { data, dataType: \"application/super+json\" };\n  } catch {\n    return { data: value, dataType: \"application/json\" };\n  }\n}\n\nexport async function conditionallyExportPacket(\n  packet: IOPacket,\n  pathPrefix: string,\n  tracer?: TriggerTracer\n): Promise<IOPacket> {\n  if (apiClientManager.client) {\n    const { needsOffloading, size } = packetRequiresOffloading(packet);\n\n    if (needsOffloading) {\n      if (!tracer) {\n        return await exportPacket(packet, pathPrefix);\n      } else {\n        const result = await tracer.startActiveSpan(\n          \"store.uploadOutput\",\n          async (span) => {\n            return await exportPacket(packet, pathPrefix);\n          },\n          {\n            attributes: {\n              byteLength: size,\n              [SemanticInternalAttributes.STYLE_ICON]: \"cloud-upload\",\n            },\n          }\n        );\n\n        return result ?? packet;\n      }\n    }\n  }\n\n  return packet;\n}\n\nexport function packetRequiresOffloading(\n  packet: IOPacket,\n  lengthLimit?: number\n): {\n  needsOffloading: boolean;\n  size: number;\n} {\n  if (!packet.data) {\n    return {\n      needsOffloading: false,\n      size: 0,\n    };\n  }\n\n  const byteSize = Buffer.byteLength(packet.data, \"utf8\");\n\n  return {\n    needsOffloading: byteSize >= (lengthLimit ?? OFFLOAD_IO_PACKET_LENGTH_LIMIT),\n    size: byteSize,\n  };\n}\n\nasync function exportPacket(packet: IOPacket, pathPrefix: string): Promise<IOPacket> {\n  // Offload the output\n  const filename = `${pathPrefix}.${getPacketExtension(packet.dataType)}`;\n\n  const presignedResponse = await apiClientManager.client!.createUploadPayloadUrl(filename);\n\n  const uploadResponse = await fetch(presignedResponse.presignedUrl, {\n    method: \"PUT\",\n    headers: {\n      \"Content-Type\": packet.dataType,\n    },\n    body: packet.data,\n  });\n\n  if (!uploadResponse.ok) {\n    throw new Error(\n      `Failed to upload output to ${presignedResponse.presignedUrl}: ${uploadResponse.statusText}`\n    );\n  }\n\n  return {\n    data: filename,\n    dataType: \"application/store\",\n  };\n}\n\nexport async function conditionallyImportPacket(\n  packet: IOPacket,\n  tracer?: TriggerTracer\n): Promise<IOPacket> {\n  if (packet.dataType !== \"application/store\") {\n    return packet;\n  }\n\n  if (!tracer) {\n    return await importPacket(packet);\n  } else {\n    const result = await tracer.startActiveSpan(\n      \"store.downloadPayload\",\n      async (span) => {\n        return await importPacket(packet, span);\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"cloud-download\",\n        },\n      }\n    );\n\n    return result ?? packet;\n  }\n}\n\nasync function importPacket(packet: IOPacket, span?: Span): Promise<IOPacket> {\n  if (!packet.data) {\n    return packet;\n  }\n\n  if (!apiClientManager.client) {\n    return packet;\n  }\n\n  const presignedResponse = await apiClientManager.client.getPayloadUrl(packet.data);\n\n  const response = await fetch(presignedResponse.presignedUrl);\n\n  if (!response.ok) {\n    throw new Error(\n      `Failed to import packet ${presignedResponse.presignedUrl}: ${response.statusText}`\n    );\n  }\n\n  const data = await response.text();\n\n  span?.setAttribute(\"size\", Buffer.byteLength(data, \"utf8\"));\n\n  return {\n    data,\n    dataType: response.headers.get(\"content-type\") ?? \"application/json\",\n  };\n}\n\nexport async function createPacketAttributes(\n  packet: IOPacket,\n  dataKey: string,\n  dataTypeKey: string\n): Promise<Attributes | undefined> {\n  if (!packet.data) {\n    return;\n  }\n\n  switch (packet.dataType) {\n    case \"application/json\":\n      return {\n        ...flattenAttributes(packet, dataKey),\n        [dataTypeKey]: packet.dataType,\n      };\n    case \"application/super+json\":\n      const { parse } = await loadSuperJSON();\n\n      if (typeof packet.data === \"undefined\" || packet.data === null) {\n        return;\n      }\n\n      try {\n        const parsed = parse(packet.data) as any;\n        const jsonified = JSON.parse(JSON.stringify(parsed, safeReplacer));\n\n        const result = {\n          ...flattenAttributes(jsonified, dataKey),\n          [dataTypeKey]: \"application/json\",\n        };\n\n        return result;\n      } catch (e) {\n        return;\n      }\n\n    case \"application/store\":\n      return {\n        [dataKey]: packet.data,\n        [dataTypeKey]: packet.dataType,\n      };\n    case \"text/plain\":\n      return {\n        [dataKey]: packet.data,\n        [dataTypeKey]: packet.dataType,\n      };\n    default:\n      return;\n  }\n}\n\nexport async function createPacketAttributesAsJson(\n  data: any,\n  dataType: string\n): Promise<Attributes> {\n  if (\n    typeof data === \"string\" ||\n    typeof data === \"number\" ||\n    typeof data === \"boolean\" ||\n    data === null ||\n    data === undefined\n  ) {\n    return data;\n  }\n\n  switch (dataType) {\n    case \"application/json\":\n      return imposeAttributeLimits(flattenAttributes(data, undefined));\n    case \"application/super+json\":\n      const { deserialize } = await loadSuperJSON();\n\n      const deserialized = deserialize(data) as any;\n      const jsonify = safeJsonParse(JSON.stringify(deserialized, safeReplacer));\n\n      return imposeAttributeLimits(flattenAttributes(jsonify, undefined));\n    case \"application/store\":\n      return data;\n    default:\n      return {};\n  }\n}\n\nexport async function prettyPrintPacket(rawData: any, dataType?: string): Promise<string> {\n  if (rawData === undefined) {\n    return \"\";\n  }\n\n  if (dataType === \"application/super+json\") {\n    if (typeof rawData === \"string\") {\n      rawData = safeJsonParse(rawData);\n    }\n    const { deserialize } = await loadSuperJSON();\n\n    return await prettyPrintPacket(deserialize(rawData), \"application/json\");\n  }\n\n  if (dataType === \"application/json\") {\n    if (typeof rawData === \"string\") {\n      rawData = safeJsonParse(rawData);\n    }\n    return JSON.stringify(rawData, safeReplacer, 2);\n  }\n\n  if (typeof rawData === \"string\") {\n    return rawData;\n  }\n\n  return JSON.stringify(rawData, safeReplacer, 2);\n}\n\nfunction safeReplacer(key: string, value: any) {\n  // If it is a BigInt\n  if (typeof value === \"bigint\") {\n    return value.toString(); // Convert to string\n  }\n\n  // if it is a Regex\n  if (value instanceof RegExp) {\n    return value.toString(); // Convert to string\n  }\n\n  // if it is a Set\n  if (value instanceof Set) {\n    return Array.from(value); // Convert to array\n  }\n\n  // if it is a Map, convert it to an object\n  if (value instanceof Map) {\n    const obj: Record<string, any> = {};\n    value.forEach((v, k) => {\n      obj[k] = v;\n    });\n    return obj;\n  }\n\n  return value; // Otherwise return the value as is\n}\n\nfunction getPacketExtension(outputType: string): string {\n  switch (outputType) {\n    case \"application/json\":\n      return \"json\";\n    case \"application/super+json\":\n      return \"json\";\n    case \"text/plain\":\n      return \"txt\";\n    default:\n      return \"txt\";\n  }\n}\n\nasync function loadSuperJSON(): Promise<typeof import(\"superjson\")> {\n  return await import(\"superjson\");\n}\n\nfunction safeJsonParse(value: string): any {\n  try {\n    return JSON.parse(value);\n  } catch {\n    return;\n  }\n}\n\nexport async function replaceSuperJsonPayload(original: string, newPayload: string) {\n  const superjson = await loadSuperJSON();\n  const originalObject = superjson.parse(original);\n  const { meta } = superjson.serialize(originalObject);\n\n  const newSuperJson = {\n    json: JSON.parse(newPayload) as any,\n    meta,\n  };\n\n  return superjson.deserialize(newSuperJson);\n}\n", "import { SpanKind } from \"@opentelemetry/api\";\nimport { ConsoleInterceptor } from \"../consoleInterceptor\";\nimport { parseError, sanitizeError } from \"../errors\";\nimport { TracingSDK, recordSpanException } from \"../otel\";\nimport {\n  BackgroundWorkerProperties,\n  Config,\n  TaskRunContext,\n  TaskRunErrorCodes,\n  TaskRunExecution,\n  TaskRunExecutionResult,\n  TaskRunExecutionRetry,\n} from \"../schemas\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { taskContext } from \"../task-context-api\";\nimport { TriggerTracer } from \"../tracer\";\nimport { HandleErrorFunction, ProjectConfig, TaskMetadataWithFunctions } from \"../types\";\nimport {\n  conditionallyExportPacket,\n  conditionallyImportPacket,\n  createPacketAttributes,\n  parsePacket,\n  stringifyIO,\n} from \"../utils/ioSerialization\";\nimport { calculateNextRetryDelay } from \"../utils/retries\";\nimport { accessoryAttributes } from \"../utils/styleAttributes\";\nimport { UsageMeasurement } from \"../usage/types\";\nimport { ApiError, RateLimitError } from \"../apiClient/errors\";\n\nexport type TaskExecutorOptions = {\n  tracingSDK: TracingSDK;\n  tracer: TriggerTracer;\n  consoleInterceptor: ConsoleInterceptor;\n  projectConfig: Config;\n  importedConfig: ProjectConfig | undefined;\n  handleErrorFn: HandleErrorFunction | undefined;\n};\n\nexport class TaskExecutor {\n  private _tracingSDK: TracingSDK;\n  private _tracer: TriggerTracer;\n  private _consoleInterceptor: ConsoleInterceptor;\n  private _config: Config;\n  private _importedConfig: ProjectConfig | undefined;\n  private _handleErrorFn: HandleErrorFunction | undefined;\n\n  constructor(\n    public task: TaskMetadataWithFunctions,\n    options: TaskExecutorOptions\n  ) {\n    this._tracingSDK = options.tracingSDK;\n    this._tracer = options.tracer;\n    this._consoleInterceptor = options.consoleInterceptor;\n    this._config = options.projectConfig;\n    this._importedConfig = options.importedConfig;\n    this._handleErrorFn = options.handleErrorFn;\n  }\n\n  async execute(\n    execution: TaskRunExecution,\n    worker: BackgroundWorkerProperties,\n    traceContext: Record<string, unknown>,\n    usage: UsageMeasurement\n  ): Promise<{ result: TaskRunExecutionResult }> {\n    const ctx = TaskRunContext.parse(execution);\n    const attemptMessage = `Attempt ${execution.attempt.number}`;\n\n    const originalPacket = {\n      data: execution.run.payload,\n      dataType: execution.run.payloadType,\n    };\n\n    taskContext.setGlobalTaskContext({\n      ctx,\n      worker,\n    });\n\n    this._tracingSDK.asyncResourceDetector.resolveWithAttributes({\n      ...taskContext.attributes,\n      [SemanticInternalAttributes.SDK_VERSION]: this.task.packageVersion,\n      [SemanticInternalAttributes.SDK_LANGUAGE]: \"typescript\",\n    });\n\n    const result = await this._tracer.startActiveSpan(\n      attemptMessage,\n      async (span) => {\n        return await this._consoleInterceptor.intercept(console, async () => {\n          let parsedPayload: any;\n          let initOutput: any;\n\n          try {\n            const payloadPacket = await conditionallyImportPacket(originalPacket, this._tracer);\n\n            parsedPayload = await parsePacket(payloadPacket);\n\n            if (execution.attempt.number === 1) {\n              await this.#callOnStartFunctions(parsedPayload, ctx);\n            }\n\n            initOutput = await this.#callInitFunctions(parsedPayload, ctx);\n\n            const output = await this.#callRun(parsedPayload, ctx, initOutput);\n\n            await this.#callOnSuccessFunctions(parsedPayload, output, ctx, initOutput);\n\n            try {\n              const stringifiedOutput = await stringifyIO(output);\n\n              const finalOutput = await conditionallyExportPacket(\n                stringifiedOutput,\n                `${execution.attempt.id}/output`,\n                this._tracer\n              );\n\n              const attributes = await createPacketAttributes(\n                finalOutput,\n                SemanticInternalAttributes.OUTPUT,\n                SemanticInternalAttributes.OUTPUT_TYPE\n              );\n\n              if (attributes) {\n                span.setAttributes(attributes);\n              }\n\n              return {\n                ok: true,\n                id: execution.run.id,\n                output: finalOutput.data,\n                outputType: finalOutput.dataType,\n              } satisfies TaskRunExecutionResult;\n            } catch (stringifyError) {\n              recordSpanException(span, stringifyError);\n\n              return {\n                ok: false,\n                id: execution.run.id,\n                error: {\n                  type: \"INTERNAL_ERROR\",\n                  code: TaskRunErrorCodes.TASK_OUTPUT_ERROR,\n                  message:\n                    stringifyError instanceof Error\n                      ? stringifyError.message\n                      : typeof stringifyError === \"string\"\n                      ? stringifyError\n                      : undefined,\n                },\n              } satisfies TaskRunExecutionResult;\n            }\n          } catch (runError) {\n            try {\n              const handleErrorResult = await this.#handleError(\n                execution,\n                runError,\n                parsedPayload,\n                ctx\n              );\n\n              recordSpanException(span, handleErrorResult.error ?? runError);\n\n              if (handleErrorResult.status !== \"retry\") {\n                await this.#callOnFailureFunctions(\n                  parsedPayload,\n                  handleErrorResult.error ?? runError,\n                  ctx,\n                  initOutput\n                );\n              }\n\n              return {\n                id: execution.run.id,\n                ok: false,\n                error: sanitizeError(\n                  handleErrorResult.error\n                    ? parseError(handleErrorResult.error)\n                    : parseError(runError)\n                ),\n                retry: handleErrorResult.status === \"retry\" ? handleErrorResult.retry : undefined,\n                skippedRetrying: handleErrorResult.status === \"skipped\",\n              } satisfies TaskRunExecutionResult;\n            } catch (handleErrorError) {\n              recordSpanException(span, handleErrorError);\n\n              return {\n                ok: false,\n                id: execution.run.id,\n                error: {\n                  type: \"INTERNAL_ERROR\",\n                  code: TaskRunErrorCodes.HANDLE_ERROR_ERROR,\n                  message:\n                    handleErrorError instanceof Error\n                      ? handleErrorError.message\n                      : typeof handleErrorError === \"string\"\n                      ? handleErrorError\n                      : undefined,\n                },\n              } satisfies TaskRunExecutionResult;\n            }\n          } finally {\n            await this.#callTaskCleanup(parsedPayload, ctx, initOutput);\n          }\n        });\n      },\n      {\n        kind: SpanKind.CONSUMER,\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"attempt\",\n          ...accessoryAttributes({\n            items: [\n              {\n                text: ctx.task.filePath,\n              },\n              {\n                text: `${ctx.task.exportName}.run()`,\n              },\n            ],\n            style: \"codepath\",\n          }),\n        },\n      },\n      this._tracer.extractContext(traceContext)\n    );\n\n    return { result };\n  }\n\n  async #callRun(payload: unknown, ctx: TaskRunContext, init: unknown) {\n    const runFn = this.task.fns.run;\n    const middlewareFn = this.task.fns.middleware;\n\n    if (!runFn) {\n      throw new Error(\"Task does not have a run function\");\n    }\n\n    if (!middlewareFn) {\n      return runFn(payload, { ctx, init });\n    }\n\n    return middlewareFn(payload, { ctx, next: async () => runFn(payload, { ctx, init }) });\n  }\n\n  async #callInitFunctions(payload: unknown, ctx: TaskRunContext) {\n    await this.#callConfigInit(payload, ctx);\n\n    const initFn = this.task.fns.init;\n\n    if (!initFn) {\n      return {};\n    }\n\n    return this._tracer.startActiveSpan(\n      \"init\",\n      async (span) => {\n        return await initFn(payload, { ctx });\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"function\",\n        },\n      }\n    );\n  }\n\n  async #callConfigInit(payload: unknown, ctx: TaskRunContext) {\n    const initFn = this._importedConfig?.init;\n\n    if (!initFn) {\n      return {};\n    }\n\n    return this._tracer.startActiveSpan(\n      \"config.init\",\n      async (span) => {\n        return await initFn(payload, { ctx });\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"function\",\n        },\n      }\n    );\n  }\n\n  async #callOnSuccessFunctions(\n    payload: unknown,\n    output: any,\n    ctx: TaskRunContext,\n    initOutput: any\n  ) {\n    await this.#callOnSuccessFunction(\n      this.task.fns.onSuccess,\n      \"task.onSuccess\",\n      payload,\n      output,\n      ctx,\n      initOutput\n    );\n\n    await this.#callOnSuccessFunction(\n      this._importedConfig?.onSuccess,\n      \"config.onSuccess\",\n      payload,\n      output,\n      ctx,\n      initOutput\n    );\n  }\n\n  async #callOnSuccessFunction(\n    onSuccessFn: TaskMetadataWithFunctions[\"fns\"][\"onSuccess\"],\n    name: string,\n    payload: unknown,\n    output: any,\n    ctx: TaskRunContext,\n    initOutput: any\n  ) {\n    if (!onSuccessFn) {\n      return;\n    }\n\n    try {\n      await this._tracer.startActiveSpan(\n        name,\n        async (span) => {\n          return await onSuccessFn(payload, output, { ctx, init: initOutput });\n        },\n        {\n          attributes: {\n            [SemanticInternalAttributes.STYLE_ICON]: \"function\",\n          },\n        }\n      );\n    } catch {\n      // Ignore errors from onSuccess functions\n    }\n  }\n\n  async #callOnFailureFunctions(\n    payload: unknown,\n    error: unknown,\n    ctx: TaskRunContext,\n    initOutput: any\n  ) {\n    await this.#callOnFailureFunction(\n      this.task.fns.onFailure,\n      \"task.onFailure\",\n      payload,\n      error,\n      ctx,\n      initOutput\n    );\n\n    await this.#callOnFailureFunction(\n      this._importedConfig?.onFailure,\n      \"config.onFailure\",\n      payload,\n      error,\n      ctx,\n      initOutput\n    );\n  }\n\n  async #callOnFailureFunction(\n    onFailureFn: TaskMetadataWithFunctions[\"fns\"][\"onFailure\"],\n    name: string,\n    payload: unknown,\n    error: unknown,\n    ctx: TaskRunContext,\n    initOutput: any\n  ) {\n    if (!onFailureFn) {\n      return;\n    }\n\n    try {\n      return await this._tracer.startActiveSpan(\n        name,\n        async (span) => {\n          return await onFailureFn(payload, error, { ctx, init: initOutput });\n        },\n        {\n          attributes: {\n            [SemanticInternalAttributes.STYLE_ICON]: \"function\",\n          },\n        }\n      );\n    } catch (e) {\n      // Ignore errors from onFailure functions\n    }\n  }\n\n  async #callOnStartFunctions(payload: unknown, ctx: TaskRunContext) {\n    await this.#callOnStartFunction(\n      this._importedConfig?.onStart,\n      \"config.onStart\",\n      payload,\n      ctx,\n      {}\n    );\n\n    await this.#callOnStartFunction(this.task.fns.onStart, \"task.onStart\", payload, ctx, {});\n  }\n\n  async #callOnStartFunction(\n    onStartFn: TaskMetadataWithFunctions[\"fns\"][\"onStart\"],\n    name: string,\n    payload: unknown,\n    ctx: TaskRunContext,\n    initOutput: any\n  ) {\n    if (!onStartFn) {\n      return;\n    }\n\n    try {\n      await this._tracer.startActiveSpan(\n        name,\n        async (span) => {\n          return await onStartFn(payload, { ctx });\n        },\n        {\n          attributes: {\n            [SemanticInternalAttributes.STYLE_ICON]: \"function\",\n          },\n        }\n      );\n    } catch {\n      // Ignore errors from onStart functions\n    }\n  }\n\n  async #callTaskCleanup(payload: unknown, ctx: TaskRunContext, init: unknown) {\n    const cleanupFn = this.task.fns.cleanup;\n\n    if (!cleanupFn) {\n      return;\n    }\n\n    return this._tracer.startActiveSpan(\"cleanup\", async (span) => {\n      return await cleanupFn(payload, { ctx, init });\n    });\n  }\n\n  async #handleError(\n    execution: TaskRunExecution,\n    error: unknown,\n    payload: any,\n    ctx: TaskRunContext\n  ): Promise<\n    | { status: \"retry\"; retry: TaskRunExecutionRetry; error?: unknown }\n    | { status: \"skipped\"; error?: unknown } // skipped is different than noop, it means that the task was skipped from retrying, instead of just not retrying\n    | { status: \"noop\"; error?: unknown }\n  > {\n    const retriesConfig = this._importedConfig?.retries ?? this._config.retries;\n\n    const retry = this.task.retry ?? retriesConfig?.default;\n\n    if (!retry) {\n      return { status: \"noop\" };\n    }\n\n    if (error instanceof Error && error.name === \"AbortTaskRunError\") {\n      return { status: \"skipped\" };\n    }\n\n    if (execution.run.maxAttempts) {\n      retry.maxAttempts = Math.max(execution.run.maxAttempts, 1);\n    }\n\n    let delay = calculateNextRetryDelay(retry, execution.attempt.number);\n\n    if (\n      delay &&\n      error instanceof Error &&\n      error.name === \"TriggerApiError\" &&\n      (error as ApiError).status === 429\n    ) {\n      const rateLimitError = error as RateLimitError;\n\n      delay = rateLimitError.millisecondsUntilReset;\n    }\n\n    if (\n      execution.environment.type === \"DEVELOPMENT\" &&\n      typeof retriesConfig?.enabledInDev === \"boolean\" &&\n      !retriesConfig.enabledInDev\n    ) {\n      return { status: \"skipped\" };\n    }\n\n    return this._tracer.startActiveSpan(\n      \"handleError()\",\n      async (span) => {\n        const handleErrorResult = this.task.fns.handleError\n          ? await this.task.fns.handleError(payload, error, {\n              ctx,\n              retry,\n              retryDelayInMs: delay,\n              retryAt: delay ? new Date(Date.now() + delay) : undefined,\n            })\n          : this._importedConfig\n          ? await this._handleErrorFn?.(payload, error, {\n              ctx,\n              retry,\n              retryDelayInMs: delay,\n              retryAt: delay ? new Date(Date.now() + delay) : undefined,\n            })\n          : undefined;\n\n        // If handleErrorResult\n        if (!handleErrorResult) {\n          return typeof delay === \"undefined\"\n            ? { status: \"noop\" }\n            : { status: \"retry\", retry: { timestamp: Date.now() + delay, delay } };\n        }\n\n        if (handleErrorResult.skipRetrying) {\n          return { status: \"skipped\", error: handleErrorResult.error };\n        }\n\n        if (typeof handleErrorResult.retryAt !== \"undefined\") {\n          return {\n            status: \"retry\",\n            retry: {\n              timestamp: handleErrorResult.retryAt.getTime(),\n              delay: handleErrorResult.retryAt.getTime() - Date.now(),\n            },\n            error: handleErrorResult.error,\n          };\n        }\n\n        if (typeof handleErrorResult.retryDelayInMs === \"number\") {\n          return {\n            status: \"retry\",\n            retry: {\n              timestamp: Date.now() + handleErrorResult.retryDelayInMs,\n              delay: handleErrorResult.retryDelayInMs,\n            },\n            error: handleErrorResult.error,\n          };\n        }\n\n        if (handleErrorResult.retry && typeof handleErrorResult.retry === \"object\") {\n          const delay = calculateNextRetryDelay(handleErrorResult.retry, execution.attempt.number);\n\n          return typeof delay === \"undefined\"\n            ? { status: \"noop\", error: handleErrorResult.error }\n            : {\n                status: \"retry\",\n                retry: { timestamp: Date.now() + delay, delay },\n                error: handleErrorResult.error,\n              };\n        }\n\n        return { status: \"noop\", error: handleErrorResult.error };\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"exclamation-circle\",\n        },\n      }\n    );\n  }\n}\n", "import { z } from \"zod\";\nimport { TaskRunError } from \"./schemas/common\";\n\nexport class AbortTaskRunError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"AbortTaskRunError\";\n  }\n}\n\nexport function parseError(error: unknown): TaskRunError {\n  if (error instanceof Error) {\n    return {\n      type: \"BUILT_IN_ERROR\",\n      name: error.name,\n      message: error.message,\n      stackTrace: error.stack ?? \"\",\n    };\n  }\n\n  if (typeof error === \"string\") {\n    return {\n      type: \"STRING_ERROR\",\n      raw: error,\n    };\n  }\n\n  try {\n    return {\n      type: \"CUSTOM_ERROR\",\n      raw: JSON.stringify(error),\n    };\n  } catch (e) {\n    return {\n      type: \"CUSTOM_ERROR\",\n      raw: String(error),\n    };\n  }\n}\n\nexport function createErrorTaskError(error: TaskRunError): any {\n  switch (error.type) {\n    case \"BUILT_IN_ERROR\": {\n      const e = new Error(error.message);\n\n      e.name = error.name;\n      e.stack = error.stackTrace;\n\n      return e;\n    }\n    case \"STRING_ERROR\": {\n      return error.raw;\n    }\n    case \"CUSTOM_ERROR\": {\n      return JSON.parse(error.raw);\n    }\n    case \"INTERNAL_ERROR\": {\n      return new Error(`trigger.dev internal error (${error.code})`);\n    }\n  }\n}\n\nexport const SerializedError = z.object({\n  message: z.string(),\n  name: z.string().optional(),\n  stackTrace: z.string().optional(),\n});\n\nexport type SerializedError = z.infer<typeof SerializedError>;\n\nexport function createJsonErrorObject(error: TaskRunError): SerializedError {\n  switch (error.type) {\n    case \"BUILT_IN_ERROR\": {\n      return {\n        name: error.name,\n        message: error.message,\n        stackTrace: error.stackTrace,\n      };\n    }\n    case \"STRING_ERROR\": {\n      return {\n        message: error.raw,\n      };\n    }\n    case \"CUSTOM_ERROR\": {\n      return {\n        message: error.raw,\n      };\n    }\n    case \"INTERNAL_ERROR\": {\n      return {\n        message: `trigger.dev internal error (${error.code})`,\n      };\n    }\n  }\n}\n\n// Removes any null characters from the error message\nexport function sanitizeError(error: TaskRunError): TaskRunError {\n  switch (error.type) {\n    case \"BUILT_IN_ERROR\": {\n      return {\n        type: \"BUILT_IN_ERROR\",\n        message: error.message?.replace(/\\0/g, \"\"),\n        name: error.name?.replace(/\\0/g, \"\"),\n        stackTrace: error.stackTrace?.replace(/\\0/g, \"\"),\n      };\n    }\n    case \"STRING_ERROR\": {\n      return {\n        type: \"STRING_ERROR\",\n        raw: error.raw.replace(/\\0/g, \"\"),\n      };\n    }\n    case \"CUSTOM_ERROR\": {\n      return {\n        type: \"CUSTOM_ERROR\",\n        raw: error.raw.replace(/\\0/g, \"\"),\n      };\n    }\n    case \"INTERNAL_ERROR\": {\n      return {\n        type: \"INTERNAL_ERROR\",\n        code: error.code,\n        message: error.message?.replace(/\\0/g, \"\"),\n        stackTrace: error.stackTrace?.replace(/\\0/g, \"\"),\n      };\n    }\n  }\n}\n\nexport function correctErrorStackTrace(\n  stackTrace: string,\n  projectDir?: string,\n  options?: { removeFirstLine?: boolean; isDev?: boolean }\n) {\n  const [errorLine, ...traceLines] = stackTrace.split(\"\\n\");\n\n  return [\n    options?.removeFirstLine ? undefined : errorLine,\n    ...traceLines.map((line) => correctStackTraceLine(line, projectDir, options?.isDev)),\n  ]\n    .filter(Boolean)\n    .join(\"\\n\");\n}\n\nconst LINES_TO_IGNORE = [\n  /ConsoleInterceptor/,\n  /TriggerTracer/,\n  /TaskExecutor/,\n  /EXECUTE_TASK_RUN/,\n  /@trigger.dev\\/core/,\n  /packages\\/core\\/src\\/v3/,\n  /safeJsonProcess/,\n  /__entryPoint.ts/,\n  /ZodIpc/,\n  /startActiveSpan/,\n  /processTicksAndRejections/,\n];\n\nfunction correctStackTraceLine(line: string, projectDir?: string, isDev?: boolean) {\n  if (LINES_TO_IGNORE.some((regex) => regex.test(line))) {\n    return;\n  }\n\n  // Check to see if the path is inside the project directory\n  if (isDev && projectDir && !line.includes(projectDir)) {\n    return;\n  }\n\n  return line.trim();\n}\n\nexport function groupTaskMetadataIssuesByTask(tasks: any, issues: z.ZodIssue[]) {\n  return issues.reduce(\n    (acc, issue) => {\n      if (issue.path.length === 0) {\n        return acc;\n      }\n\n      const taskIndex = issue.path[1];\n\n      if (typeof taskIndex !== \"number\") {\n        return acc;\n      }\n\n      const task = tasks[taskIndex];\n\n      if (!task) {\n        return acc;\n      }\n\n      const restOfPath = issue.path.slice(2);\n\n      const taskId = task.id;\n      const taskName = task.exportName;\n      const filePath = task.filePath;\n\n      const key = taskIndex;\n\n      const existing = acc[key] ?? {\n        id: taskId,\n        exportName: taskName,\n        filePath,\n        issues: [] as Array<{ message: string; path?: string }>,\n      };\n\n      existing.issues.push({\n        message: issue.message,\n        path: restOfPath.length === 0 ? undefined : restOfPath.join(\".\"),\n      });\n\n      return {\n        ...acc,\n        [key]: existing,\n      };\n    },\n    {} as Record<\n      number,\n      {\n        id: any;\n        exportName: string;\n        filePath: string;\n        issues: Array<{ message: string; path?: string }>;\n      }\n    >\n  );\n}\n", "import { Span, SpanStatusCode } from \"@opentelemetry/api\";\n\nexport { TracingSDK, type TracingSDKConfig, type TracingDiagnosticLogLevel } from \"./tracingSDK\";\n\nexport function recordSpanException(span: Span, error: unknown) {\n  if (error instanceof Error) {\n    span.recordException(sanitizeSpanError(error));\n  } else if (typeof error === \"string\") {\n    span.recordException(error.replace(/\\0/g, \"\"));\n  } else {\n    span.recordException(JSON.stringify(error).replace(/\\0/g, \"\"));\n  }\n\n  span.setStatus({ code: SpanStatusCode.ERROR });\n}\n\nfunction sanitizeSpanError(error: Error) {\n  // Create a new error object with the same name, message and stack trace\n  const sanitizedError = new Error(error.message.replace(/\\0/g, \"\"));\n  sanitizedError.name = error.name.replace(/\\0/g, \"\");\n  sanitizedError.stack = error.stack?.replace(/\\0/g, \"\");\n\n  return sanitizedError;\n}\n", "import { DiagConsoleLogger, DiagLogLevel, TracerProvider, diag } from \"@opentelemetry/api\";\nimport { logs } from \"@opentelemetry/api-logs\";\nimport { OTLPLogExporter } from \"@opentelemetry/exporter-logs-otlp-http\";\nimport { OTLPTraceExporter } from \"@opentelemetry/exporter-trace-otlp-http\";\nimport {\n  registerInstrumentations,\n  type InstrumentationOption,\n} from \"@opentelemetry/instrumentation\";\nimport {\n  DetectorSync,\n  IResource,\n  Resource,\n  ResourceAttributes,\n  ResourceDetectionConfig,\n  detectResourcesSync,\n  processDetectorSync,\n} from \"@opentelemetry/resources\";\nimport {\n  BatchLogRecordProcessor,\n  LoggerProvider,\n  SimpleLogRecordProcessor,\n} from \"@opentelemetry/sdk-logs\";\nimport {\n  BatchSpanProcessor,\n  NodeTracerProvider,\n  SimpleSpanProcessor,\n  SpanExporter,\n} from \"@opentelemetry/sdk-trace-node\";\nimport { SemanticResourceAttributes } from \"@opentelemetry/semantic-conventions\";\nimport {\n  OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,\n  OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT,\n  OTEL_LINK_COUNT_LIMIT,\n  OTEL_LOG_ATTRIBUTE_COUNT_LIMIT,\n  OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n  OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,\n  OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n  OTEL_SPAN_EVENT_COUNT_LIMIT,\n} from \"../limits\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { TaskContextLogProcessor, TaskContextSpanProcessor } from \"../taskContext/otelProcessors\";\nimport { getEnvVar } from \"../utils/getEnv\";\nimport { version } from \"../../../package.json\";\n\nclass AsyncResourceDetector implements DetectorSync {\n  private _promise: Promise<ResourceAttributes>;\n  private _resolver?: (value: ResourceAttributes) => void;\n  private _resolved: boolean = false;\n\n  constructor() {\n    this._promise = new Promise((resolver) => {\n      this._resolver = resolver;\n    });\n  }\n\n  detect(_config?: ResourceDetectionConfig): Resource {\n    return new Resource({}, this._promise);\n  }\n\n  resolveWithAttributes(attributes: ResourceAttributes) {\n    if (!this._resolver) {\n      throw new Error(\"Resolver not available\");\n    }\n\n    if (this._resolved) {\n      return;\n    }\n\n    this._resolved = true;\n    this._resolver(attributes);\n  }\n}\n\nexport type TracingDiagnosticLogLevel =\n  | \"none\"\n  | \"error\"\n  | \"warn\"\n  | \"info\"\n  | \"debug\"\n  | \"verbose\"\n  | \"all\";\n\nexport type TracingSDKConfig = {\n  url: string;\n  forceFlushTimeoutMillis?: number;\n  resource?: IResource;\n  instrumentations?: InstrumentationOption[];\n  diagLogLevel?: TracingDiagnosticLogLevel;\n};\n\nexport class TracingSDK {\n  public readonly asyncResourceDetector = new AsyncResourceDetector();\n  private readonly _logProvider: LoggerProvider;\n  private readonly _spanExporter: SpanExporter;\n  private readonly _traceProvider: NodeTracerProvider;\n\n  public readonly getLogger: LoggerProvider[\"getLogger\"];\n  public readonly getTracer: TracerProvider[\"getTracer\"];\n\n  constructor(private readonly config: TracingSDKConfig) {\n    setLogLevel(config.diagLogLevel ?? \"none\");\n\n    const envResourceAttributesSerialized = getEnvVar(\"OTEL_RESOURCE_ATTRIBUTES\");\n    const envResourceAttributes = envResourceAttributesSerialized\n      ? JSON.parse(envResourceAttributesSerialized)\n      : {};\n\n    const commonResources = detectResourcesSync({\n      detectors: [this.asyncResourceDetector, processDetectorSync],\n    })\n      .merge(\n        new Resource({\n          [SemanticResourceAttributes.CLOUD_PROVIDER]: \"trigger.dev\",\n          [SemanticInternalAttributes.TRIGGER]: true,\n          [SemanticInternalAttributes.CLI_VERSION]: version,\n        })\n      )\n      .merge(config.resource ?? new Resource({}))\n      .merge(new Resource(envResourceAttributes));\n\n    const traceProvider = new NodeTracerProvider({\n      forceFlushTimeoutMillis: config.forceFlushTimeoutMillis,\n      resource: commonResources,\n      spanLimits: {\n        attributeCountLimit: OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,\n        attributeValueLengthLimit: OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n        eventCountLimit: OTEL_SPAN_EVENT_COUNT_LIMIT,\n        attributePerEventCountLimit: OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,\n        linkCountLimit: OTEL_LINK_COUNT_LIMIT,\n        attributePerLinkCountLimit: OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT,\n      },\n    });\n\n    const spanExporter = new OTLPTraceExporter({\n      url: `${config.url}/v1/traces`,\n      timeoutMillis: config.forceFlushTimeoutMillis,\n    });\n\n    traceProvider.addSpanProcessor(\n      new TaskContextSpanProcessor(\n        getEnvVar(\"OTEL_BATCH_PROCESSING_ENABLED\") === \"1\"\n          ? new BatchSpanProcessor(spanExporter, {\n              maxExportBatchSize: parseInt(getEnvVar(\"OTEL_SPAN_MAX_EXPORT_BATCH_SIZE\") ?? \"64\"),\n              scheduledDelayMillis: parseInt(\n                getEnvVar(\"OTEL_SPAN_SCHEDULED_DELAY_MILLIS\") ?? \"200\"\n              ),\n              exportTimeoutMillis: parseInt(\n                getEnvVar(\"OTEL_SPAN_EXPORT_TIMEOUT_MILLIS\") ?? \"30000\"\n              ),\n              maxQueueSize: parseInt(getEnvVar(\"OTEL_SPAN_MAX_QUEUE_SIZE\") ?? \"512\"),\n            })\n          : new SimpleSpanProcessor(spanExporter)\n      )\n    );\n\n    traceProvider.register();\n\n    registerInstrumentations({\n      instrumentations: config.instrumentations ?? [],\n      tracerProvider: traceProvider,\n    });\n\n    const logExporter = new OTLPLogExporter({\n      url: `${config.url}/v1/logs`,\n    });\n\n    // To start a logger, you first need to initialize the Logger provider.\n    const loggerProvider = new LoggerProvider({\n      resource: commonResources,\n      logRecordLimits: {\n        attributeCountLimit: OTEL_LOG_ATTRIBUTE_COUNT_LIMIT,\n        attributeValueLengthLimit: OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT,\n      },\n    });\n\n    loggerProvider.addLogRecordProcessor(\n      new TaskContextLogProcessor(\n        getEnvVar(\"OTEL_BATCH_PROCESSING_ENABLED\") === \"1\"\n          ? new BatchLogRecordProcessor(logExporter, {\n              maxExportBatchSize: parseInt(getEnvVar(\"OTEL_LOG_MAX_EXPORT_BATCH_SIZE\") ?? \"64\"),\n              scheduledDelayMillis: parseInt(getEnvVar(\"OTEL_LOG_SCHEDULED_DELAY_MILLIS\") ?? \"200\"),\n              exportTimeoutMillis: parseInt(getEnvVar(\"OTEL_LOG_EXPORT_TIMEOUT_MILLIS\") ?? \"30000\"),\n              maxQueueSize: parseInt(getEnvVar(\"OTEL_LOG_MAX_QUEUE_SIZE\") ?? \"512\"),\n            })\n          : new SimpleLogRecordProcessor(logExporter)\n      )\n    );\n\n    this._logProvider = loggerProvider;\n    this._spanExporter = spanExporter;\n    this._traceProvider = traceProvider;\n\n    logs.setGlobalLoggerProvider(loggerProvider);\n\n    this.getLogger = loggerProvider.getLogger.bind(loggerProvider);\n    this.getTracer = traceProvider.getTracer.bind(traceProvider);\n  }\n\n  public async flush() {\n    await Promise.all([this._traceProvider.forceFlush(), this._logProvider.forceFlush()]);\n  }\n\n  public async shutdown() {\n    await Promise.all([this._traceProvider.shutdown(), this._logProvider.shutdown()]);\n  }\n}\n\nfunction setLogLevel(level: TracingDiagnosticLogLevel) {\n  let diagLogLevel: DiagLogLevel;\n\n  switch (level) {\n    case \"none\":\n      diagLogLevel = DiagLogLevel.NONE;\n      break;\n    case \"error\":\n      diagLogLevel = DiagLogLevel.ERROR;\n      break;\n    case \"warn\":\n      diagLogLevel = DiagLogLevel.WARN;\n      break;\n    case \"info\":\n      diagLogLevel = DiagLogLevel.INFO;\n      break;\n    case \"debug\":\n      diagLogLevel = DiagLogLevel.DEBUG;\n      break;\n    case \"verbose\":\n      diagLogLevel = DiagLogLevel.VERBOSE;\n      break;\n    case \"all\":\n      diagLogLevel = DiagLogLevel.ALL;\n      break;\n    default:\n      diagLogLevel = DiagLogLevel.NONE;\n  }\n\n  diag.setLogger(new DiagConsoleLogger(), diagLogLevel);\n}\n", "import { AttributeValue, Attributes } from \"@opentelemetry/api\";\n\nexport const OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT = 256;\nexport const OTEL_LOG_ATTRIBUTE_COUNT_LIMIT = 256;\nexport const OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT = 1028;\nexport const OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT = 1028;\nexport const OTEL_SPAN_EVENT_COUNT_LIMIT = 10;\nexport const OTEL_LINK_COUNT_LIMIT = 2;\nexport const OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 10;\nexport const OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 10;\nexport const OFFLOAD_IO_PACKET_LENGTH_LIMIT = 128 * 1024;\n\nexport function imposeAttributeLimits(attributes: Attributes): Attributes {\n  const newAttributes: Attributes = {};\n\n  for (const [key, value] of Object.entries(attributes)) {\n    if (calculateAttributeValueLength(value) > OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) {\n      continue;\n    }\n\n    if (Object.keys(newAttributes).length >= OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) {\n      break;\n    }\n\n    newAttributes[key] = value;\n  }\n\n  return newAttributes;\n}\n\nfunction calculateAttributeValueLength(value: AttributeValue | undefined | null): number {\n  if (value === undefined || value === null) {\n    return 0;\n  }\n\n  if (typeof value === \"string\") {\n    return value.length;\n  }\n\n  if (typeof value === \"number\") {\n    return 8;\n  }\n\n  if (typeof value === \"boolean\") {\n    return 4;\n  }\n\n  if (Array.isArray(value)) {\n    return value.reduce((acc: number, v) => acc + calculateAttributeValueLength(v), 0);\n  }\n\n  return 0;\n}\n", "export const SemanticInternalAttributes = {\n  ENVIRONMENT_ID: \"ctx.environment.id\",\n  ENVIRONMENT_TYPE: \"ctx.environment.type\",\n  ORGANIZATION_ID: \"ctx.organization.id\",\n  ORGANIZATION_SLUG: \"ctx.organization.slug\",\n  ORGANIZATION_NAME: \"ctx.organization.name\",\n  PROJECT_ID: \"ctx.project.id\",\n  PROJECT_REF: \"ctx.project.ref\",\n  PROJECT_NAME: \"ctx.project.title\",\n  PROJECT_DIR: \"project.dir\",\n  ATTEMPT_ID: \"ctx.attempt.id\",\n  ATTEMPT_NUMBER: \"ctx.attempt.number\",\n  RUN_ID: \"ctx.run.id\",\n  RUN_IS_TEST: \"ctx.run.isTest\",\n  BATCH_ID: \"ctx.batch.id\",\n  TASK_SLUG: \"ctx.task.id\",\n  TASK_PATH: \"ctx.task.filePath\",\n  TASK_EXPORT_NAME: \"ctx.task.exportName\",\n  QUEUE_NAME: \"ctx.queue.name\",\n  QUEUE_ID: \"ctx.queue.id\",\n  MACHINE_PRESET_NAME: \"ctx.machine.name\",\n  MACHINE_PRESET_CPU: \"ctx.machine.cpu\",\n  MACHINE_PRESET_MEMORY: \"ctx.machine.memory\",\n  MACHINE_PRESET_CENTS_PER_MS: \"ctx.machine.centsPerMs\",\n  SPAN_PARTIAL: \"$span.partial\",\n  SPAN_ID: \"$span.span_id\",\n  OUTPUT: \"$output\",\n  OUTPUT_TYPE: \"$mime_type_output\",\n  STYLE: \"$style\",\n  STYLE_ICON: \"$style.icon\",\n  STYLE_VARIANT: \"$style.variant\",\n  STYLE_ACCESSORY: \"$style.accessory\",\n  METADATA: \"$metadata\",\n  TRIGGER: \"$trigger\",\n  PAYLOAD: \"$payload\",\n  PAYLOAD_TYPE: \"$mime_type_payload\",\n  SHOW: \"$show\",\n  SHOW_ACTIONS: \"$show.actions\",\n  WORKER_ID: \"worker.id\",\n  WORKER_VERSION: \"worker.version\",\n  CLI_VERSION: \"cli.version\",\n  SDK_VERSION: \"sdk.version\",\n  SDK_LANGUAGE: \"sdk.language\",\n  RETRY_AT: \"retry.at\",\n  RETRY_DELAY: \"retry.delay\",\n  RETRY_COUNT: \"retry.count\",\n  LINK_TITLE: \"$link.title\",\n  IDEMPOTENCY_KEY: \"ctx.run.idempotencyKey\",\n  USAGE_DURATION_MS: \"$usage.durationMs\",\n  USAGE_COST_IN_CENTS: \"$usage.costInCents\",\n  RATE_LIMIT_LIMIT: \"response.rateLimit.limit\",\n  RATE_LIMIT_REMAINING: \"response.rateLimit.remaining\",\n  RATE_LIMIT_RESET: \"response.rateLimit.reset\",\n};\n", "import { Attributes } from \"@opentelemetry/api\";\n\nexport const NULL_SENTINEL = \"$@null((\";\n\nexport function flattenAttributes(\n  obj: Record<string, unknown> | Array<unknown> | string | boolean | number | null | undefined,\n  prefix?: string\n): Attributes {\n  const result: Attributes = {};\n\n  // Check if obj is null or undefined\n  if (obj === undefined) {\n    return result;\n  }\n\n  if (obj === null) {\n    result[prefix || \"\"] = NULL_SENTINEL;\n    return result;\n  }\n\n  if (typeof obj === \"string\") {\n    result[prefix || \"\"] = obj;\n    return result;\n  }\n\n  if (typeof obj === \"number\") {\n    result[prefix || \"\"] = obj;\n    return result;\n  }\n\n  if (typeof obj === \"boolean\") {\n    result[prefix || \"\"] = obj;\n    return result;\n  }\n\n  for (const [key, value] of Object.entries(obj)) {\n    const newPrefix = `${prefix ? `${prefix}.` : \"\"}${Array.isArray(obj) ? `[${key}]` : key}`;\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        if (typeof value[i] === \"object\" && value[i] !== null) {\n          // update null check here as well\n          Object.assign(result, flattenAttributes(value[i], `${newPrefix}.[${i}]`));\n        } else {\n          if (value[i] === null) {\n            result[`${newPrefix}.[${i}]`] = NULL_SENTINEL;\n          } else {\n            result[`${newPrefix}.[${i}]`] = value[i];\n          }\n        }\n      }\n    } else if (isRecord(value)) {\n      // update null check here\n      Object.assign(result, flattenAttributes(value, newPrefix));\n    } else {\n      if (typeof value === \"number\" || typeof value === \"string\" || typeof value === \"boolean\") {\n        result[newPrefix] = value;\n      } else if (value === null) {\n        result[newPrefix] = NULL_SENTINEL;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\n\nexport function unflattenAttributes(\n  obj: Attributes\n): Record<string, unknown> | string | number | boolean | null | undefined {\n  if (typeof obj !== \"object\" || obj === null || Array.isArray(obj)) {\n    return obj;\n  }\n\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    Object.keys(obj).length === 1 &&\n    Object.keys(obj)[0] === \"\"\n  ) {\n    return rehydrateNull(obj[\"\"]) as any;\n  }\n\n  if (Object.keys(obj).length === 0) {\n    return;\n  }\n\n  const result: Record<string, unknown> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    const parts = key.split(\".\").reduce((acc, part) => {\n      if (part.includes(\"[\")) {\n        // Handling nested array indices\n        const subparts = part.split(/\\[|\\]/).filter((p) => p !== \"\");\n        acc.push(...subparts);\n      } else {\n        acc.push(part);\n      }\n      return acc;\n    }, [] as string[]);\n\n    let current: any = result;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const part = parts[i];\n      const nextPart = parts[i + 1];\n      const isArray = /^\\d+$/.test(nextPart);\n      if (isArray && !Array.isArray(current[part])) {\n        current[part] = [];\n      } else if (!isArray && current[part] === undefined) {\n        current[part] = {};\n      }\n      current = current[part];\n    }\n    const lastPart = parts[parts.length - 1];\n    current[lastPart] = rehydrateNull(value);\n  }\n\n  // Convert the result to an array if all top-level keys are numeric indices\n  if (Object.keys(result).every((k) => /^\\d+$/.test(k))) {\n    const maxIndex = Math.max(...Object.keys(result).map((k) => parseInt(k)));\n    const arrayResult = Array(maxIndex + 1);\n    for (const key in result) {\n      arrayResult[parseInt(key)] = result[key];\n    }\n    return arrayResult as any;\n  }\n\n  return result;\n}\n\nexport function primitiveValueOrflattenedAttributes(\n  obj: Record<string, unknown> | Array<unknown> | string | boolean | number | undefined,\n  prefix: string | undefined\n): Attributes | string | number | boolean | undefined {\n  if (\n    typeof obj === \"string\" ||\n    typeof obj === \"number\" ||\n    typeof obj === \"boolean\" ||\n    obj === null ||\n    obj === undefined\n  ) {\n    return obj;\n  }\n\n  const attributes = flattenAttributes(obj, prefix);\n\n  if (\n    prefix !== undefined &&\n    typeof attributes[prefix] !== \"undefined\" &&\n    attributes[prefix] !== null\n  ) {\n    return attributes[prefix] as unknown as Attributes;\n  }\n\n  return attributes;\n}\n\nfunction rehydrateNull(value: any): any {\n  if (value === NULL_SENTINEL) {\n    return null;\n  }\n\n  return value;\n}\n", "export const _globalThis = typeof globalThis === \"object\" ? globalThis : global;\n", "import { ApiClientConfiguration } from \"../apiClientManager/types\";\nimport { Clock } from \"../clock/clock\";\nimport type { RuntimeManager } from \"../runtime/manager\";\nimport { TaskCatalog } from \"../task-catalog/catalog\";\nimport { TaskContext } from \"../taskContext/types\";\nimport { UsageManager } from \"../usage/types\";\nimport { _globalThis } from \"./platform\";\n\nconst GLOBAL_TRIGGER_DOT_DEV_KEY = Symbol.for(`dev.trigger.ts.api`);\n\nconst _global = _globalThis as TriggerDotDevGlobal;\n\nexport function registerGlobal<Type extends keyof TriggerDotDevGlobalAPI>(\n  type: Type,\n  instance: TriggerDotDevGlobalAPI[Type],\n  allowOverride = false\n): boolean {\n  const api = (_global[GLOBAL_TRIGGER_DOT_DEV_KEY] = _global[GLOBAL_TRIGGER_DOT_DEV_KEY] ?? {});\n\n  if (!allowOverride && api[type]) {\n    // already registered an API of this type\n    const err = new Error(`trigger.dev: Attempted duplicate registration of API: ${type}`);\n    return false;\n  }\n\n  api[type] = instance;\n\n  return true;\n}\n\nexport function getGlobal<Type extends keyof TriggerDotDevGlobalAPI>(\n  type: Type\n): TriggerDotDevGlobalAPI[Type] | undefined {\n  return _global[GLOBAL_TRIGGER_DOT_DEV_KEY]?.[type];\n}\n\nexport function unregisterGlobal(type: keyof TriggerDotDevGlobalAPI) {\n  const api = _global[GLOBAL_TRIGGER_DOT_DEV_KEY];\n\n  if (api) {\n    delete api[type];\n  }\n}\n\ntype TriggerDotDevGlobal = {\n  [GLOBAL_TRIGGER_DOT_DEV_KEY]?: TriggerDotDevGlobalAPI;\n};\n\ntype TriggerDotDevGlobalAPI = {\n  runtime?: RuntimeManager;\n  logger?: any;\n  clock?: Clock;\n  usage?: UsageManager;\n  [\"task-catalog\"]?: TaskCatalog;\n  [\"task-context\"]?: TaskContext;\n  [\"api-client\"]?: ApiClientConfiguration;\n};\n", "import { Attributes } from \"@opentelemetry/api\";\nimport { BackgroundWorkerProperties, TaskRunContext } from \"../schemas\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport { TaskContext } from \"./types\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\n\nconst API_NAME = \"task-context\";\n\nexport class TaskContextAPI {\n  private static _instance?: TaskContextAPI;\n\n  private constructor() {}\n\n  public static getInstance(): TaskContextAPI {\n    if (!this._instance) {\n      this._instance = new TaskContextAPI();\n    }\n\n    return this._instance;\n  }\n\n  get isInsideTask(): boolean {\n    return this.#getTaskContext() !== undefined;\n  }\n\n  get ctx(): TaskRunContext | undefined {\n    return this.#getTaskContext()?.ctx;\n  }\n\n  get worker(): BackgroundWorkerProperties | undefined {\n    return this.#getTaskContext()?.worker;\n  }\n\n  get attributes(): Attributes {\n    if (this.ctx) {\n      return {\n        ...this.contextAttributes,\n        ...this.workerAttributes,\n      };\n    }\n\n    return {};\n  }\n\n  get workerAttributes(): Attributes {\n    if (this.worker) {\n      return {\n        [SemanticInternalAttributes.WORKER_ID]: this.worker.id,\n        [SemanticInternalAttributes.WORKER_VERSION]: this.worker.version,\n      };\n    }\n\n    return {};\n  }\n\n  get contextAttributes(): Attributes {\n    if (this.ctx) {\n      return {\n        [SemanticInternalAttributes.ATTEMPT_ID]: this.ctx.attempt.id,\n        [SemanticInternalAttributes.ATTEMPT_NUMBER]: this.ctx.attempt.number,\n        [SemanticInternalAttributes.TASK_SLUG]: this.ctx.task.id,\n        [SemanticInternalAttributes.TASK_PATH]: this.ctx.task.filePath,\n        [SemanticInternalAttributes.TASK_EXPORT_NAME]: this.ctx.task.exportName,\n        [SemanticInternalAttributes.QUEUE_NAME]: this.ctx.queue.name,\n        [SemanticInternalAttributes.QUEUE_ID]: this.ctx.queue.id,\n        [SemanticInternalAttributes.ENVIRONMENT_ID]: this.ctx.environment.id,\n        [SemanticInternalAttributes.ENVIRONMENT_TYPE]: this.ctx.environment.type,\n        [SemanticInternalAttributes.ORGANIZATION_ID]: this.ctx.organization.id,\n        [SemanticInternalAttributes.PROJECT_ID]: this.ctx.project.id,\n        [SemanticInternalAttributes.PROJECT_REF]: this.ctx.project.ref,\n        [SemanticInternalAttributes.PROJECT_NAME]: this.ctx.project.name,\n        [SemanticInternalAttributes.RUN_ID]: this.ctx.run.id,\n        [SemanticInternalAttributes.RUN_IS_TEST]: this.ctx.run.isTest,\n        [SemanticInternalAttributes.ORGANIZATION_SLUG]: this.ctx.organization.slug,\n        [SemanticInternalAttributes.ORGANIZATION_NAME]: this.ctx.organization.name,\n        [SemanticInternalAttributes.BATCH_ID]: this.ctx.batch?.id,\n        [SemanticInternalAttributes.IDEMPOTENCY_KEY]: this.ctx.run.idempotencyKey,\n        [SemanticInternalAttributes.MACHINE_PRESET_NAME]: this.ctx.machine?.name,\n        [SemanticInternalAttributes.MACHINE_PRESET_CPU]: this.ctx.machine?.cpu,\n        [SemanticInternalAttributes.MACHINE_PRESET_MEMORY]: this.ctx.machine?.memory,\n        [SemanticInternalAttributes.MACHINE_PRESET_CENTS_PER_MS]: this.ctx.machine?.centsPerMs,\n      };\n    }\n\n    return {};\n  }\n\n  public disable() {\n    unregisterGlobal(API_NAME);\n  }\n\n  public setGlobalTaskContext(taskContext: TaskContext): boolean {\n    return registerGlobal(API_NAME, taskContext);\n  }\n\n  #getTaskContext(): TaskContext | undefined {\n    return getGlobal(API_NAME);\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TaskContextAPI } from \"./taskContext\";\n/** Entrypoint for logger API */\nexport const taskContext = TaskContextAPI.getInstance();\n", "import { LogRecord, LogRecordProcessor } from \"@opentelemetry/sdk-logs\";\nimport { Span, SpanProcessor } from \"@opentelemetry/sdk-trace-base\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { Context } from \"@opentelemetry/api\";\nimport { flattenAttributes } from \"../utils/flattenAttributes\";\nimport { taskContext } from \"../task-context-api\";\n\nexport class TaskContextSpanProcessor implements SpanProcessor {\n  private _innerProcessor: SpanProcessor;\n\n  constructor(innerProcessor: SpanProcessor) {\n    this._innerProcessor = innerProcessor;\n  }\n\n  // Called when a span starts\n  onStart(span: Span, parentContext: Context): void {\n    if (taskContext.ctx) {\n      span.setAttributes(\n        flattenAttributes(\n          {\n            [SemanticInternalAttributes.ATTEMPT_ID]: taskContext.ctx.attempt.id,\n            [SemanticInternalAttributes.ATTEMPT_NUMBER]: taskContext.ctx.attempt.number,\n          },\n          SemanticInternalAttributes.METADATA\n        )\n      );\n    }\n\n    this._innerProcessor.onStart(span, parentContext);\n  }\n\n  // Delegate the rest of the methods to the wrapped processor\n\n  onEnd(span: Span): void {\n    this._innerProcessor.onEnd(span);\n  }\n\n  shutdown(): Promise<void> {\n    return this._innerProcessor.shutdown();\n  }\n\n  forceFlush(): Promise<void> {\n    return this._innerProcessor.forceFlush();\n  }\n}\n\nexport class TaskContextLogProcessor implements LogRecordProcessor {\n  private _innerProcessor: LogRecordProcessor;\n\n  constructor(innerProcessor: LogRecordProcessor) {\n    this._innerProcessor = innerProcessor;\n  }\n  forceFlush(): Promise<void> {\n    return this._innerProcessor.forceFlush();\n  }\n  onEmit(logRecord: LogRecord, context?: Context | undefined): void {\n    // Adds in the context attributes to the log record\n    if (taskContext.ctx) {\n      logRecord.setAttributes(\n        flattenAttributes(\n          {\n            [SemanticInternalAttributes.ATTEMPT_ID]: taskContext.ctx.attempt.id,\n            [SemanticInternalAttributes.ATTEMPT_NUMBER]: taskContext.ctx.attempt.number,\n          },\n          SemanticInternalAttributes.METADATA\n        )\n      );\n    }\n\n    this._innerProcessor.onEmit(logRecord, context);\n  }\n  shutdown(): Promise<void> {\n    return this._innerProcessor.shutdown();\n  }\n}\n", "export function getEnvVar(name: string): string | undefined {\n  // This could run in a non-Node.js environment (Bun, Deno, CF Worker, etc.), so don't just assume process.env is a thing\n  if (typeof process !== \"undefined\" && typeof process.env === \"object\" && process.env !== null) {\n    return process.env[name];\n  }\n}\n", "{\n  \"name\": \"@trigger.dev/core\",\n  \"version\": \"3.0.0-beta.56\",\n  \"description\": \"Core code used across the Trigger.dev SDK and platform\",\n  \"license\": \"MIT\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"module\": \"./dist/index.mjs\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"import\": {\n        \"types\": \"./dist/index.d.mts\",\n        \"default\": \"./dist/index.mjs\"\n      },\n      \"require\": \"./dist/index.js\",\n      \"types\": \"./dist/index.d.ts\"\n    },\n    \"./eventFilterMatches\": {\n      \"import\": {\n        \"types\": \"./dist/eventFilterMatches.d.mts\",\n        \"default\": \"./dist/eventFilterMatches.mjs\"\n      },\n      \"require\": \"./dist/eventFilterMatches.js\",\n      \"types\": \"./dist/eventFilterMatches.d.ts\"\n    },\n    \"./replacements\": {\n      \"import\": {\n        \"types\": \"./dist/replacements.d.mts\",\n        \"default\": \"./dist/replacements.mjs\"\n      },\n      \"require\": \"./dist/replacements.js\",\n      \"types\": \"./dist/replacements.d.ts\"\n    },\n    \"./requestFilterMatches\": {\n      \"import\": {\n        \"types\": \"./dist/requestFilterMatches.d.mts\",\n        \"default\": \"./dist/requestFilterMatches.mjs\"\n      },\n      \"require\": \"./dist/requestFilterMatches.js\",\n      \"types\": \"./dist/requestFilterMatches.d.ts\"\n    },\n    \"./retry\": {\n      \"import\": {\n        \"types\": \"./dist/retry.d.mts\",\n        \"default\": \"./dist/retry.mjs\"\n      },\n      \"require\": \"./dist/retry.js\",\n      \"types\": \"./dist/retry.d.ts\"\n    },\n    \"./utils\": {\n      \"import\": {\n        \"types\": \"./dist/utils.d.mts\",\n        \"default\": \"./dist/utils.mjs\"\n      },\n      \"require\": \"./dist/utils.js\",\n      \"types\": \"./dist/utils.d.ts\"\n    },\n    \"./schemas\": {\n      \"import\": {\n        \"types\": \"./dist/schemas/index.d.mts\",\n        \"default\": \"./dist/schemas/index.mjs\"\n      },\n      \"require\": \"./dist/schemas/index.js\",\n      \"types\": \"./dist/schemas/index.d.ts\"\n    },\n    \"./types\": {\n      \"import\": {\n        \"types\": \"./dist/types.d.mts\",\n        \"default\": \"./dist/types.mjs\"\n      },\n      \"require\": \"./dist/types.js\",\n      \"types\": \"./dist/types.d.ts\"\n    },\n    \"./versions\": {\n      \"import\": {\n        \"types\": \"./dist/versions.d.mts\",\n        \"default\": \"./dist/versions.mjs\"\n      },\n      \"require\": \"./dist/versions.js\",\n      \"types\": \"./dist/versions.d.ts\"\n    },\n    \"./v3\": {\n      \"import\": {\n        \"types\": \"./dist/v3/index.d.mts\",\n        \"default\": \"./dist/v3/index.mjs\"\n      },\n      \"require\": \"./dist/v3/index.js\",\n      \"types\": \"./dist/v3/index.d.ts\"\n    },\n    \"./v3/errors\": {\n      \"import\": {\n        \"types\": \"./dist/v3/errors.d.mts\",\n        \"default\": \"./dist/v3/errors.mjs\"\n      },\n      \"require\": \"./dist/v3/errors.js\",\n      \"types\": \"./dist/v3/errors.d.ts\"\n    },\n    \"./v3/logger-api\": {\n      \"import\": {\n        \"types\": \"./dist/v3/logger-api.d.mts\",\n        \"default\": \"./dist/v3/logger-api.mjs\"\n      },\n      \"require\": \"./dist/v3/logger-api.js\",\n      \"types\": \"./dist/v3/logger-api.d.ts\"\n    },\n    \"./v3/otel\": {\n      \"import\": {\n        \"types\": \"./dist/v3/otel/index.d.mts\",\n        \"default\": \"./dist/v3/otel/index.mjs\"\n      },\n      \"require\": \"./dist/v3/otel/index.js\",\n      \"types\": \"./dist/v3/otel/index.d.ts\"\n    },\n    \"./v3/semanticInternalAttributes\": {\n      \"import\": {\n        \"types\": \"./dist/v3/semanticInternalAttributes.d.mts\",\n        \"default\": \"./dist/v3/semanticInternalAttributes.mjs\"\n      },\n      \"require\": \"./dist/v3/semanticInternalAttributes.js\",\n      \"types\": \"./dist/v3/semanticInternalAttributes.d.ts\"\n    },\n    \"./v3/utils/durations\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/durations.d.mts\",\n        \"default\": \"./dist/v3/utils/durations.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/durations.js\",\n      \"types\": \"./dist/v3/utils/durations.d.ts\"\n    },\n    \"./v3/utils/flattenAttributes\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/flattenAttributes.d.mts\",\n        \"default\": \"./dist/v3/utils/flattenAttributes.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/flattenAttributes.js\",\n      \"types\": \"./dist/v3/utils/flattenAttributes.d.ts\"\n    },\n    \"./v3/utils/ioSerialization\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/ioSerialization.d.mts\",\n        \"default\": \"./dist/v3/utils/ioSerialization.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/ioSerialization.js\",\n      \"types\": \"./dist/v3/utils/ioSerialization.d.ts\"\n    },\n    \"./v3/utils/omit\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/omit.d.mts\",\n        \"default\": \"./dist/v3/utils/omit.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/omit.js\",\n      \"types\": \"./dist/v3/utils/omit.d.ts\"\n    },\n    \"./v3/utils/retries\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/retries.d.mts\",\n        \"default\": \"./dist/v3/utils/retries.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/retries.js\",\n      \"types\": \"./dist/v3/utils/retries.d.ts\"\n    },\n    \"./v3/utils/structuredLogger\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/structuredLogger.d.mts\",\n        \"default\": \"./dist/v3/utils/structuredLogger.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/structuredLogger.js\",\n      \"types\": \"./dist/v3/utils/structuredLogger.d.ts\"\n    },\n    \"./v3/zodfetch\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodfetch.d.mts\",\n        \"default\": \"./dist/v3/zodfetch.mjs\"\n      },\n      \"require\": \"./dist/v3/zodfetch.js\",\n      \"types\": \"./dist/v3/zodfetch.d.ts\"\n    },\n    \"./v3/zodMessageHandler\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodMessageHandler.d.mts\",\n        \"default\": \"./dist/v3/zodMessageHandler.mjs\"\n      },\n      \"require\": \"./dist/v3/zodMessageHandler.js\",\n      \"types\": \"./dist/v3/zodMessageHandler.d.ts\"\n    },\n    \"./v3/zodNamespace\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodNamespace.d.mts\",\n        \"default\": \"./dist/v3/zodNamespace.mjs\"\n      },\n      \"require\": \"./dist/v3/zodNamespace.js\",\n      \"types\": \"./dist/v3/zodNamespace.d.ts\"\n    },\n    \"./v3/zodSocket\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodSocket.d.mts\",\n        \"default\": \"./dist/v3/zodSocket.mjs\"\n      },\n      \"require\": \"./dist/v3/zodSocket.js\",\n      \"types\": \"./dist/v3/zodSocket.d.ts\"\n    },\n    \"./v3/zodIpc\": {\n      \"import\": {\n        \"types\": \"./dist/v3/zodIpc.d.mts\",\n        \"default\": \"./dist/v3/zodIpc.mjs\"\n      },\n      \"require\": \"./dist/v3/zodIpc.js\",\n      \"types\": \"./dist/v3/zodIpc.d.ts\"\n    },\n    \"./v3/utils/timers\": {\n      \"import\": {\n        \"types\": \"./dist/v3/utils/timers.d.mts\",\n        \"default\": \"./dist/v3/utils/timers.mjs\"\n      },\n      \"require\": \"./dist/v3/utils/timers.js\",\n      \"types\": \"./dist/v3/utils/timers.d.ts\"\n    },\n    \"./v3/dev\": {\n      \"import\": {\n        \"types\": \"./dist/v3/dev/index.d.mts\",\n        \"default\": \"./dist/v3/dev/index.mjs\"\n      },\n      \"require\": \"./dist/v3/dev/index.js\",\n      \"types\": \"./dist/v3/dev/index.d.ts\"\n    },\n    \"./v3/prod\": {\n      \"import\": {\n        \"types\": \"./dist/v3/prod/index.d.mts\",\n        \"default\": \"./dist/v3/prod/index.mjs\"\n      },\n      \"require\": \"./dist/v3/prod/index.js\",\n      \"types\": \"./dist/v3/prod/index.d.ts\"\n    },\n    \"./v3/workers\": {\n      \"import\": {\n        \"types\": \"./dist/v3/workers/index.d.mts\",\n        \"default\": \"./dist/v3/workers/index.mjs\"\n      },\n      \"require\": \"./dist/v3/workers/index.js\",\n      \"types\": \"./dist/v3/workers/index.d.ts\"\n    },\n    \"./v3/schemas\": {\n      \"import\": {\n        \"types\": \"./dist/v3/schemas/index.d.mts\",\n        \"default\": \"./dist/v3/schemas/index.mjs\"\n      },\n      \"require\": \"./dist/v3/schemas/index.js\",\n      \"types\": \"./dist/v3/schemas/index.d.ts\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"v3\": [\n        \"./dist/v3/index.d.ts\"\n      ],\n      \"v3/otel\": [\n        \"./dist/v3/otel/index.d.ts\"\n      ]\n    }\n  },\n  \"sideEffects\": false,\n  \"scripts\": {\n    \"clean\": \"rimraf dist\",\n    \"build\": \"npm run clean && npm run build:tsup\",\n    \"build:tsup\": \"tsup --dts-resolve\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"test\": \"jest\"\n  },\n  \"dependencies\": {\n    \"@google-cloud/precise-date\": \"^4.0.0\",\n    \"@opentelemetry/api\": \"^1.8.0\",\n    \"@opentelemetry/api-logs\": \"^0.48.0\",\n    \"@opentelemetry/exporter-logs-otlp-http\": \"^0.49.1\",\n    \"@opentelemetry/exporter-trace-otlp-http\": \"^0.49.1\",\n    \"@opentelemetry/instrumentation\": \"^0.49.1\",\n    \"@opentelemetry/resources\": \"^1.22.0\",\n    \"@opentelemetry/sdk-logs\": \"^0.49.1\",\n    \"@opentelemetry/sdk-node\": \"^0.49.1\",\n    \"@opentelemetry/sdk-trace-base\": \"^1.22.0\",\n    \"@opentelemetry/sdk-trace-node\": \"^1.22.0\",\n    \"@opentelemetry/semantic-conventions\": \"^1.22.0\",\n    \"humanize-duration\": \"^3.27.3\",\n    \"socket.io-client\": \"4.7.5\",\n    \"superjson\": \"^2.2.1\",\n    \"ulidx\": \"^2.2.1\",\n    \"zod\": \"3.22.3\",\n    \"zod-error\": \"1.5.0\",\n    \"zod-validation-error\": \"^1.5.0\"\n  },\n  \"devDependencies\": {\n    \"@trigger.dev/tsconfig\": \"workspace:*\",\n    \"@trigger.dev/tsup\": \"workspace:*\",\n    \"@types/humanize-duration\": \"^3.27.1\",\n    \"@types/jest\": \"^29.5.3\",\n    \"@types/node\": \"20.12.7\",\n    \"@types/readable-stream\": \"^4.0.14\",\n    \"jest\": \"^29.6.2\",\n    \"rimraf\": \"^3.0.2\",\n    \"socket.io\": \"4.7.4\",\n    \"ts-jest\": \"^29.1.1\",\n    \"tsup\": \"^8.0.1\",\n    \"typescript\": \"^5.3.0\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  }\n}", "import { z } from \"zod\";\nimport { BackgroundWorkerMetadata, ImageDetailsMetadata } from \"./resources\";\nimport { QueueOptions } from \"./schemas\";\nimport { SerializedError } from \"../errors\";\n\nexport const WhoAmIResponseSchema = z.object({\n  userId: z.string(),\n  email: z.string().email(),\n  dashboardUrl: z.string(),\n});\n\nexport type WhoAmIResponse = z.infer<typeof WhoAmIResponseSchema>;\n\nexport const GetProjectResponseBody = z.object({\n  id: z.string(),\n  externalRef: z.string(),\n  name: z.string(),\n  slug: z.string(),\n  createdAt: z.coerce.date(),\n  organization: z.object({\n    id: z.string(),\n    title: z.string(),\n    slug: z.string(),\n    createdAt: z.coerce.date(),\n  }),\n});\n\nexport type GetProjectResponseBody = z.infer<typeof GetProjectResponseBody>;\n\nexport const GetProjectsResponseBody = z.array(GetProjectResponseBody);\n\nexport type GetProjectsResponseBody = z.infer<typeof GetProjectsResponseBody>;\n\nexport const GetProjectEnvResponse = z.object({\n  apiKey: z.string(),\n  name: z.string(),\n  apiUrl: z.string(),\n});\n\nexport type GetProjectEnvResponse = z.infer<typeof GetProjectEnvResponse>;\n\nexport const CreateBackgroundWorkerRequestBody = z.object({\n  localOnly: z.boolean(),\n  metadata: BackgroundWorkerMetadata,\n  supportsLazyAttempts: z.boolean().optional(),\n});\n\nexport type CreateBackgroundWorkerRequestBody = z.infer<typeof CreateBackgroundWorkerRequestBody>;\n\nexport const CreateBackgroundWorkerResponse = z.object({\n  id: z.string(),\n  version: z.string(),\n  contentHash: z.string(),\n});\n\nexport type CreateBackgroundWorkerResponse = z.infer<typeof CreateBackgroundWorkerResponse>;\n\n//an array of 1, 2, or 3 strings\nconst RunTag = z.string().max(64, \"Tags must be less than 64 characters\");\nexport const RunTags = z.union([RunTag, RunTag.array()]);\n\nexport type RunTags = z.infer<typeof RunTags>;\n\nexport const TriggerTaskRequestBody = z.object({\n  payload: z.any(),\n  context: z.any(),\n  options: z\n    .object({\n      dependentAttempt: z.string().optional(),\n      dependentBatch: z.string().optional(),\n      lockToVersion: z.string().optional(),\n      queue: QueueOptions.optional(),\n      concurrencyKey: z.string().optional(),\n      idempotencyKey: z.string().optional(),\n      test: z.boolean().optional(),\n      payloadType: z.string().optional(),\n      delay: z.string().or(z.coerce.date()).optional(),\n      ttl: z.string().or(z.number().nonnegative().int()).optional(),\n      tags: RunTags.optional(),\n      maxAttempts: z.number().int().optional(),\n    })\n    .optional(),\n});\n\nexport type TriggerTaskRequestBody = z.infer<typeof TriggerTaskRequestBody>;\n\nexport const TriggerTaskResponse = z.object({\n  id: z.string(),\n});\n\nexport type TriggerTaskResponse = z.infer<typeof TriggerTaskResponse>;\n\nexport const BatchTriggerTaskRequestBody = z.object({\n  items: TriggerTaskRequestBody.array(),\n  dependentAttempt: z.string().optional(),\n});\n\nexport type BatchTriggerTaskRequestBody = z.infer<typeof BatchTriggerTaskRequestBody>;\n\nexport const BatchTriggerTaskResponse = z.object({\n  batchId: z.string(),\n  runs: z.string().array(),\n});\n\nexport type BatchTriggerTaskResponse = z.infer<typeof BatchTriggerTaskResponse>;\n\nexport const GetBatchResponseBody = z.object({\n  id: z.string(),\n  items: z.array(\n    z.object({\n      id: z.string(),\n      taskRunId: z.string(),\n      status: z.enum([\"PENDING\", \"CANCELED\", \"COMPLETED\", \"FAILED\"]),\n    })\n  ),\n});\n\nexport type GetBatchResponseBody = z.infer<typeof GetBatchResponseBody>;\n\nexport const AddTagsRequestBody = z.object({\n  tags: RunTags,\n});\n\nexport type AddTagsRequestBody = z.infer<typeof AddTagsRequestBody>;\n\nexport const RescheduleRunRequestBody = z.object({\n  delay: z.string().or(z.coerce.date()),\n});\n\nexport type RescheduleRunRequestBody = z.infer<typeof RescheduleRunRequestBody>;\n\nexport const GetEnvironmentVariablesResponseBody = z.object({\n  variables: z.record(z.string()),\n});\n\nexport type GetEnvironmentVariablesResponseBody = z.infer<\n  typeof GetEnvironmentVariablesResponseBody\n>;\n\nexport const StartDeploymentIndexingRequestBody = z.object({\n  imageReference: z.string(),\n  selfHosted: z.boolean().optional(),\n});\n\nexport type StartDeploymentIndexingRequestBody = z.infer<typeof StartDeploymentIndexingRequestBody>;\n\nexport const StartDeploymentIndexingResponseBody = z.object({\n  id: z.string(),\n  contentHash: z.string(),\n});\n\nexport type StartDeploymentIndexingResponseBody = z.infer<\n  typeof StartDeploymentIndexingResponseBody\n>;\n\nexport const ExternalBuildData = z.object({\n  buildId: z.string(),\n  buildToken: z.string(),\n  projectId: z.string(),\n});\n\nexport type ExternalBuildData = z.infer<typeof ExternalBuildData>;\n\nexport const InitializeDeploymentResponseBody = z.object({\n  id: z.string(),\n  contentHash: z.string(),\n  shortCode: z.string(),\n  version: z.string(),\n  imageTag: z.string(),\n  externalBuildData: ExternalBuildData.optional().nullable(),\n  registryHost: z.string().optional(),\n});\n\nexport type InitializeDeploymentResponseBody = z.infer<typeof InitializeDeploymentResponseBody>;\n\nexport const InitializeDeploymentRequestBody = z.object({\n  contentHash: z.string(),\n  userId: z.string().optional(),\n});\n\nexport type InitializeDeploymentRequestBody = z.infer<typeof InitializeDeploymentRequestBody>;\n\nexport const DeploymentErrorData = z.object({\n  name: z.string(),\n  message: z.string(),\n  stack: z.string().optional(),\n  stderr: z.string().optional(),\n});\n\nexport const GetDeploymentResponseBody = z.object({\n  id: z.string(),\n  status: z.enum([\n    \"PENDING\",\n    \"BUILDING\",\n    \"DEPLOYING\",\n    \"DEPLOYED\",\n    \"FAILED\",\n    \"CANCELED\",\n    \"TIMED_OUT\",\n  ]),\n  contentHash: z.string(),\n  shortCode: z.string(),\n  version: z.string(),\n  imageReference: z.string().optional(),\n  errorData: DeploymentErrorData.optional().nullable(),\n  worker: z\n    .object({\n      id: z.string(),\n      version: z.string(),\n      tasks: z.array(\n        z.object({\n          id: z.string(),\n          slug: z.string(),\n          filePath: z.string(),\n          exportName: z.string(),\n        })\n      ),\n    })\n    .optional(),\n});\n\nexport type GetDeploymentResponseBody = z.infer<typeof GetDeploymentResponseBody>;\n\nexport const CreateUploadPayloadUrlResponseBody = z.object({\n  presignedUrl: z.string(),\n});\n\nexport type CreateUploadPayloadUrlResponseBody = z.infer<typeof CreateUploadPayloadUrlResponseBody>;\n\nexport const ReplayRunResponse = z.object({\n  id: z.string(),\n});\n\nexport type ReplayRunResponse = z.infer<typeof ReplayRunResponse>;\n\nexport const CanceledRunResponse = z.object({\n  id: z.string(),\n});\n\nexport type CanceledRunResponse = z.infer<typeof CanceledRunResponse>;\n\nexport const ScheduleType = z.union([z.literal(\"DECLARATIVE\"), z.literal(\"IMPERATIVE\")]);\n\nexport const ScheduledTaskPayload = z.object({\n  /** The schedule id associated with this run (you can have many schedules for the same task).\n    You can use this to remove the schedule, update it, etc */\n  scheduleId: z.string(),\n  /** The type of schedule – `\"DECLARATIVE\"` or `\"IMPERATIVE\"`.\n   *\n   * **DECLARATIVE** – defined inline on your `schedules.task` using the `cron` property. They can only be created, updated or deleted by modifying the `cron` property on your task.\n   *\n   * **IMPERATIVE** – created using the `schedules.create` functions or in the dashboard.\n   */\n  type: ScheduleType,\n  /** When the task was scheduled to run.\n   * Note this will be slightly different from `new Date()` because it takes a few ms to run the task.\n   * \n   * This date is UTC. To output it as a string with a timezone you would do this: \n   * ```ts\n   * const formatted = payload.timestamp.toLocaleString(\"en-US\", {\n        timeZone: payload.timezone,\n    });\n    ```  */\n  timestamp: z.date(),\n  /** When the task was last run (it has been).\n    This can be undefined if it's never been run. This date is UTC. */\n  lastTimestamp: z.date().optional(),\n  /** You can optionally provide an external id when creating the schedule.\n    Usually you would use a userId or some other unique identifier.\n    This defaults to undefined if you didn't provide one. */\n  externalId: z.string().optional(),\n  /** The IANA timezone the schedule is set to. The default is UTC.\n   * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones\n   */\n  timezone: z.string(),\n  /** The next 5 dates this task is scheduled to run */\n  upcoming: z.array(z.date()),\n});\n\nexport type ScheduledTaskPayload = z.infer<typeof ScheduledTaskPayload>;\n\nexport const CreateScheduleOptions = z.object({\n  /** The id of the task you want to attach to. */\n  task: z.string(),\n  /**  The schedule in CRON format.\n   * \n   * ```txt\n*    *    *    *    *    *\n┬    ┬    ┬    ┬    ┬\n│    │    │    │    |\n│    │    │    │    └ day of week (0 - 7, 1L - 7L) (0 or 7 is Sun)\n│    │    │    └───── month (1 - 12)\n│    │    └────────── day of month (1 - 31, L)\n│    └─────────────── hour (0 - 23)\n└──────────────────── minute (0 - 59)\n   * ```\n\n\"L\" means the last. In the \"day of week\" field, 1L means the last Monday of the month. In the day of month field, L means the last day of the month.\n\n   */\n  cron: z.string(),\n  /** You can only create one schedule with this key. If you use it twice, the second call will update the schedule.\n   *\n   * This is required to prevent you from creating duplicate schedules. */\n  deduplicationKey: z.string(),\n  /** Optionally, you can specify your own IDs (like a user ID) and then use it inside the run function of your task.\n   *\n   * This allows you to have per-user CRON tasks.\n   */\n  externalId: z.string().optional(),\n  /** Optionally, you can specify a timezone in the IANA format. If unset it will use UTC.\n   * If specified then the CRON will be evaluated in that timezone and will respect daylight savings.\n   *\n   * If you set the CRON to `0 0 * * *` and the timezone to `America/New_York` then the task will run at midnight in New York time, no matter whether it's daylight savings or not.\n   *\n   * You can see the full list of supported timezones here: https://cloud.trigger.dev/timezones\n   *\n   * @example \"America/New_York\", \"Europe/London\", \"Asia/Tokyo\", \"Africa/Cairo\"\n   *\n   */\n  timezone: z.string().optional(),\n});\n\nexport type CreateScheduleOptions = z.infer<typeof CreateScheduleOptions>;\n\nexport const UpdateScheduleOptions = CreateScheduleOptions.omit({ deduplicationKey: true });\n\nexport type UpdateScheduleOptions = z.infer<typeof UpdateScheduleOptions>;\n\nexport const ScheduleGenerator = z.object({\n  type: z.literal(\"CRON\"),\n  expression: z.string(),\n  description: z.string(),\n});\n\nexport type ScheduleGenerator = z.infer<typeof ScheduleGenerator>;\n\nexport const ScheduleObject = z.object({\n  id: z.string(),\n  type: ScheduleType,\n  task: z.string(),\n  active: z.boolean(),\n  deduplicationKey: z.string().nullish(),\n  externalId: z.string().nullish(),\n  generator: ScheduleGenerator,\n  timezone: z.string(),\n  nextRun: z.coerce.date().nullish(),\n  environments: z.array(\n    z.object({\n      id: z.string(),\n      type: z.string(),\n      userName: z.string().nullish(),\n    })\n  ),\n});\n\nexport type ScheduleObject = z.infer<typeof ScheduleObject>;\n\nexport const DeletedScheduleObject = z.object({\n  id: z.string(),\n});\n\nexport type DeletedScheduleObject = z.infer<typeof DeletedScheduleObject>;\n\nexport const ListSchedulesResult = z.object({\n  data: z.array(ScheduleObject),\n  pagination: z.object({\n    currentPage: z.number(),\n    totalPages: z.number(),\n    count: z.number(),\n  }),\n});\n\nexport type ListSchedulesResult = z.infer<typeof ListSchedulesResult>;\n\nexport const ListScheduleOptions = z.object({\n  page: z.number().optional(),\n  perPage: z.number().optional(),\n});\n\nexport type ListScheduleOptions = z.infer<typeof ListScheduleOptions>;\n\nexport const TimezonesResult = z.object({\n  timezones: z.array(z.string()),\n});\n\nexport type TimezonesResult = z.infer<typeof TimezonesResult>;\n\nexport const RunStatus = z.enum([\n  /// Task hasn't been deployed yet but is waiting to be executed\n  \"WAITING_FOR_DEPLOY\",\n  /// Task is waiting to be executed by a worker\n  \"QUEUED\",\n  /// Task is currently being executed by a worker\n  \"EXECUTING\",\n  /// Task has failed and is waiting to be retried\n  \"REATTEMPTING\",\n  /// Task has been paused by the system, and will be resumed by the system\n  \"FROZEN\",\n  /// Task has been completed successfully\n  \"COMPLETED\",\n  /// Task has been canceled by the user\n  \"CANCELED\",\n  /// Task has been completed with errors\n  \"FAILED\",\n  /// Task has crashed and won't be retried, most likely the worker ran out of resources, e.g. memory or storage\n  \"CRASHED\",\n  /// Task was interrupted during execution, mostly this happens in development environments\n  \"INTERRUPTED\",\n  /// Task has failed to complete, due to an error in the system\n  \"SYSTEM_FAILURE\",\n  /// Task has been scheduled to run at a specific time\n  \"DELAYED\",\n  /// Task has expired and won't be executed\n  \"EXPIRED\",\n]);\n\nexport type RunStatus = z.infer<typeof RunStatus>;\n\nexport const AttemptStatus = z.enum([\n  \"PENDING\",\n  \"EXECUTING\",\n  \"PAUSED\",\n  \"COMPLETED\",\n  \"FAILED\",\n  \"CANCELED\",\n]);\n\nexport type AttemptStatus = z.infer<typeof AttemptStatus>;\n\nexport const RunEnvironmentDetails = z.object({\n  id: z.string(),\n  name: z.string(),\n  user: z.string().optional(),\n});\n\nexport type RunEnvironmentDetails = z.infer<typeof RunEnvironmentDetails>;\n\nexport const RunScheduleDetails = z.object({\n  id: z.string(),\n  externalId: z.string().optional(),\n  deduplicationKey: z.string().optional(),\n  generator: ScheduleGenerator,\n});\n\nexport type RunScheduleDetails = z.infer<typeof RunScheduleDetails>;\n\nconst CommonRunFields = {\n  id: z.string(),\n  status: RunStatus,\n  taskIdentifier: z.string(),\n  idempotencyKey: z.string().optional(),\n  version: z.string().optional(),\n  isQueued: z.boolean(),\n  isExecuting: z.boolean(),\n  isCompleted: z.boolean(),\n  isSuccess: z.boolean(),\n  isFailed: z.boolean(),\n  isCancelled: z.boolean(),\n  isTest: z.boolean(),\n  createdAt: z.coerce.date(),\n  updatedAt: z.coerce.date(),\n  startedAt: z.coerce.date().optional(),\n  finishedAt: z.coerce.date().optional(),\n  delayedUntil: z.coerce.date().optional(),\n  ttl: z.string().optional(),\n  expiredAt: z.coerce.date().optional(),\n  tags: z.string().array(),\n  costInCents: z.number(),\n  baseCostInCents: z.number(),\n  durationMs: z.number(),\n};\n\nexport const RetrieveRunResponse = z.object({\n  ...CommonRunFields,\n  payload: z.any().optional(),\n  payloadPresignedUrl: z.string().optional(),\n  output: z.any().optional(),\n  outputPresignedUrl: z.string().optional(),\n  schedule: RunScheduleDetails.optional(),\n  attempts: z.array(\n    z\n      .object({\n        id: z.string(),\n        status: AttemptStatus,\n        createdAt: z.coerce.date(),\n        updatedAt: z.coerce.date(),\n        startedAt: z.coerce.date().optional(),\n        completedAt: z.coerce.date().optional(),\n        error: SerializedError.optional(),\n      })\n      .optional()\n  ),\n});\n\nexport type RetrieveRunResponse = z.infer<typeof RetrieveRunResponse>;\n\nexport const ListRunResponseItem = z.object({\n  ...CommonRunFields,\n  env: RunEnvironmentDetails,\n});\n\nexport type ListRunResponseItem = z.infer<typeof ListRunResponseItem>;\n\nexport const ListRunResponse = z.object({\n  data: z.array(ListRunResponseItem),\n  pagination: z.object({\n    next: z.string().optional(),\n    previous: z.string().optional(),\n  }),\n});\n\nexport type ListRunResponse = z.infer<typeof ListRunResponse>;\n\nexport const CreateEnvironmentVariableRequestBody = z.object({\n  name: z.string(),\n  value: z.string(),\n});\n\nexport type CreateEnvironmentVariableRequestBody = z.infer<\n  typeof CreateEnvironmentVariableRequestBody\n>;\n\nexport const UpdateEnvironmentVariableRequestBody = z.object({\n  value: z.string(),\n});\n\nexport type UpdateEnvironmentVariableRequestBody = z.infer<\n  typeof UpdateEnvironmentVariableRequestBody\n>;\n\nexport const ImportEnvironmentVariablesRequestBody = z.object({\n  variables: z.record(z.string()),\n  override: z.boolean().optional(),\n});\n\nexport type ImportEnvironmentVariablesRequestBody = z.infer<\n  typeof ImportEnvironmentVariablesRequestBody\n>;\n\nexport const EnvironmentVariableResponseBody = z.object({\n  success: z.boolean(),\n});\n\nexport type EnvironmentVariableResponseBody = z.infer<typeof EnvironmentVariableResponseBody>;\n\nexport const EnvironmentVariableValue = z.object({\n  value: z.string(),\n});\n\nexport type EnvironmentVariableValue = z.infer<typeof EnvironmentVariableValue>;\n\nexport const EnvironmentVariable = z.object({\n  name: z.string(),\n  value: z.string(),\n});\n\nexport const EnvironmentVariables = z.array(EnvironmentVariable);\n\nexport type EnvironmentVariables = z.infer<typeof EnvironmentVariables>;\n", "import { z } from \"zod\";\nimport { QueueOptions, RetryOptions, ScheduleMetadata } from \"./schemas\";\nimport { MachineConfig } from \"./common\";\n\nexport const TaskResource = z.object({\n  id: z.string(),\n  filePath: z.string(),\n  exportName: z.string(),\n  queue: QueueOptions.optional(),\n  retry: RetryOptions.optional(),\n  machine: MachineConfig.optional(),\n  triggerSource: z.string().optional(),\n  schedule: ScheduleMetadata.optional(),\n});\n\nexport type TaskResource = z.infer<typeof TaskResource>;\n\nexport const BackgroundWorkerMetadata = z.object({\n  packageVersion: z.string(),\n  contentHash: z.string(),\n  cliPackageVersion: z.string().optional(),\n  tasks: z.array(TaskResource),\n});\n\nexport type BackgroundWorkerMetadata = z.infer<typeof BackgroundWorkerMetadata>;\n\nexport const ImageDetailsMetadata = z.object({\n  contentHash: z.string(),\n  imageTag: z.string(),\n});\n\nexport type ImageDetailsMetadata = z.infer<typeof ImageDetailsMetadata>;\n", "import { z } from \"zod\";\nimport { RequireKeys } from \"../types\";\nimport { MachineConfig, MachinePreset, TaskRunExecution } from \"./common\";\n\n/*\n    WARNING: Never import anything from ./messages here. If it's needed in both, put it here instead.\n*/\nexport const EnvironmentType = z.enum([\"PRODUCTION\", \"STAGING\", \"DEVELOPMENT\", \"PREVIEW\"]);\nexport type EnvironmentType = z.infer<typeof EnvironmentType>;\n\nexport const TaskRunExecutionPayload = z.object({\n  execution: TaskRunExecution,\n  traceContext: z.record(z.unknown()),\n  environment: z.record(z.string()).optional(),\n});\n\nexport type TaskRunExecutionPayload = z.infer<typeof TaskRunExecutionPayload>;\n\n// **IMPORTANT NOTE**: If you change this schema, make sure it is backwards compatible with the previous version as this also used when a worker signals to the coordinator that a TaskRun is complete.\n// Strategies for not breaking backwards compatibility:\n// 1. Add new fields as optional\n// 2. If a field is required, add a default value\nexport const ProdTaskRunExecution = TaskRunExecution.extend({\n  worker: z.object({\n    id: z.string(),\n    contentHash: z.string(),\n    version: z.string(),\n  }),\n  machine: MachinePreset.default({ name: \"small-1x\", cpu: 1, memory: 1, centsPerMs: 0 }),\n});\n\nexport type ProdTaskRunExecution = z.infer<typeof ProdTaskRunExecution>;\n\nexport const ProdTaskRunExecutionPayload = z.object({\n  execution: ProdTaskRunExecution,\n  traceContext: z.record(z.unknown()),\n  environment: z.record(z.string()).optional(),\n});\n\nexport type ProdTaskRunExecutionPayload = z.infer<typeof ProdTaskRunExecutionPayload>;\n\nexport const FixedWindowRateLimit = z.object({\n  type: z.literal(\"fixed-window\"),\n  limit: z.number(),\n  window: z.union([\n    z.object({\n      seconds: z.number(),\n    }),\n    z.object({\n      minutes: z.number(),\n    }),\n    z.object({\n      hours: z.number(),\n    }),\n  ]),\n});\n\nexport const SlidingWindowRateLimit = z.object({\n  type: z.literal(\"sliding-window\"),\n  limit: z.number(),\n  window: z.union([\n    z.object({\n      seconds: z.number(),\n    }),\n    z.object({\n      minutes: z.number(),\n    }),\n    z.object({\n      hours: z.number(),\n    }),\n  ]),\n});\n\nexport const RateLimitOptions = z.discriminatedUnion(\"type\", [\n  FixedWindowRateLimit,\n  SlidingWindowRateLimit,\n]);\n\nexport type RateLimitOptions = z.infer<typeof RateLimitOptions>;\n\nexport const RetryOptions = z.object({\n  /** The number of attempts before giving up */\n  maxAttempts: z.number().int().optional(),\n  /** The exponential factor to use when calculating the next retry time.\n   *\n   * Each subsequent retry will be calculated as `previousTimeout * factor`\n   */\n  factor: z.number().optional(),\n  /** The minimum time to wait before retrying */\n  minTimeoutInMs: z.number().int().optional(),\n  /** The maximum time to wait before retrying */\n  maxTimeoutInMs: z.number().int().optional(),\n  /** Randomize the timeout between retries.\n   *\n   * This can be useful to prevent the thundering herd problem where all retries happen at the same time.\n   */\n  randomize: z.boolean().optional(),\n});\n\nexport type RetryOptions = z.infer<typeof RetryOptions>;\n\nexport const QueueOptions = z.object({\n  /** You can define a shared queue and then pass the name in to your task.\n   * \n   * @example\n   * \n   * ```ts\n   * const myQueue = queue({\n      name: \"my-queue\",\n      concurrencyLimit: 1,\n    });\n\n    export const task1 = task({\n      id: \"task-1\",\n      queue: {\n        name: \"my-queue\",\n      },\n      run: async (payload: { message: string }) => {\n        // ...\n      },\n    });\n\n    export const task2 = task({\n      id: \"task-2\",\n      queue: {\n        name: \"my-queue\",\n      },\n      run: async (payload: { message: string }) => {\n        // ...\n      },\n    });\n   * ```\n   */\n  name: z.string().optional(),\n  /** An optional property that specifies the maximum number of concurrent run executions.\n   *\n   * If this property is omitted, the task can potentially use up the full concurrency of an environment. */\n  concurrencyLimit: z.number().int().min(0).max(1000).optional(),\n  /** @deprecated This feature is coming soon */\n  rateLimit: RateLimitOptions.optional(),\n});\n\nexport type QueueOptions = z.infer<typeof QueueOptions>;\n\nexport const ScheduleMetadata = z.object({\n  cron: z.string(),\n  timezone: z.string(),\n});\n\nexport const TaskMetadata = z.object({\n  id: z.string(),\n  packageVersion: z.string(),\n  queue: QueueOptions.optional(),\n  retry: RetryOptions.optional(),\n  machine: MachineConfig.optional(),\n  triggerSource: z.string().optional(),\n  schedule: ScheduleMetadata.optional(),\n});\n\nexport type TaskMetadata = z.infer<typeof TaskMetadata>;\n\nexport const TaskFileMetadata = z.object({\n  filePath: z.string(),\n  exportName: z.string(),\n});\n\nexport type TaskFileMetadata = z.infer<typeof TaskFileMetadata>;\n\nexport const TaskMetadataWithFilePath = z.object({\n  id: z.string(),\n  packageVersion: z.string(),\n  queue: QueueOptions.optional(),\n  retry: RetryOptions.optional(),\n  machine: MachineConfig.optional(),\n  triggerSource: z.string().optional(),\n  schedule: ScheduleMetadata.optional(),\n  filePath: z.string(),\n  exportName: z.string(),\n});\n\nexport type TaskMetadataWithFilePath = z.infer<typeof TaskMetadataWithFilePath>;\n\nexport const PostStartCauses = z.enum([\"index\", \"create\", \"restore\"]);\nexport type PostStartCauses = z.infer<typeof PostStartCauses>;\n\nexport const PreStopCauses = z.enum([\"terminate\"]);\nexport type PreStopCauses = z.infer<typeof PreStopCauses>;\n\nconst RegexSchema = z.custom<RegExp>((val) => {\n  try {\n    // Check to see if val is a regex\n    return typeof (val as RegExp).test === \"function\";\n  } catch {\n    return false;\n  }\n});\n\nexport const Config = z.object({\n  project: z.string(),\n  triggerDirectories: z.string().array().optional(),\n  triggerUrl: z.string().optional(),\n  projectDir: z.string().optional(),\n  tsconfigPath: z.string().optional(),\n  retries: z\n    .object({\n      enabledInDev: z.boolean().default(true),\n      default: RetryOptions.optional(),\n    })\n    .optional(),\n  additionalPackages: z.string().array().optional(),\n  additionalFiles: z.string().array().optional(),\n  dependenciesToBundle: z.array(z.union([z.string(), RegexSchema])).optional(),\n  logLevel: z.string().optional(),\n  enableConsoleLogging: z.boolean().optional(),\n  postInstall: z.string().optional(),\n  extraCACerts: z.string().optional(),\n});\n\nexport type Config = z.infer<typeof Config>;\nexport type ResolvedConfig = RequireKeys<\n  Config,\n  \"triggerDirectories\" | \"triggerUrl\" | \"projectDir\" | \"tsconfigPath\"\n>;\n\nexport const WaitReason = z.enum([\"WAIT_FOR_DURATION\", \"WAIT_FOR_TASK\", \"WAIT_FOR_BATCH\"]);\n\nexport type WaitReason = z.infer<typeof WaitReason>;\n\nexport const TaskRunExecutionLazyAttemptPayload = z.object({\n  runId: z.string(),\n  attemptCount: z.number().optional(),\n  messageId: z.string(),\n  isTest: z.boolean(),\n  traceContext: z.record(z.unknown()),\n  environment: z.record(z.string()).optional(),\n});\n\nexport type TaskRunExecutionLazyAttemptPayload = z.infer<typeof TaskRunExecutionLazyAttemptPayload>;\n", "import { z } from \"zod\";\n\n// Defaults to 0.5\nexport const MachineCpu = z.union([\n  z.literal(0.25),\n  z.literal(0.5),\n  z.literal(1),\n  z.literal(2),\n  z.literal(4),\n]);\n\nexport type MachineCpu = z.infer<typeof MachineCpu>;\n\n// Defaults to 1\nexport const MachineMemory = z.union([\n  z.literal(0.25),\n  z.literal(0.5),\n  z.literal(1),\n  z.literal(2),\n  z.literal(4),\n  z.literal(8),\n]);\n\nexport type MachineMemory = z.infer<typeof MachineMemory>;\n\n// Default is small-1x\nexport const MachinePresetName = z.enum([\n  \"micro\",\n  \"small-1x\",\n  \"small-2x\",\n  \"medium-1x\",\n  \"medium-2x\",\n  \"large-1x\",\n  \"large-2x\",\n]);\n\nexport type MachinePresetName = z.infer<typeof MachinePresetName>;\n\nexport const MachineConfig = z.object({\n  cpu: MachineCpu.optional(),\n  memory: MachineMemory.optional(),\n  preset: MachinePresetName.optional(),\n});\n\nexport type MachineConfig = z.infer<typeof MachineConfig>;\n\nexport const MachinePreset = z.object({\n  name: MachinePresetName,\n  cpu: z.number(),\n  memory: z.number(),\n  centsPerMs: z.number(),\n});\n\nexport type MachinePreset = z.infer<typeof MachinePreset>;\n\nexport const TaskRunBuiltInError = z.object({\n  type: z.literal(\"BUILT_IN_ERROR\"),\n  name: z.string(),\n  message: z.string(),\n  stackTrace: z.string(),\n});\n\nexport type TaskRunBuiltInError = z.infer<typeof TaskRunBuiltInError>;\n\nexport const TaskRunCustomErrorObject = z.object({\n  type: z.literal(\"CUSTOM_ERROR\"),\n  raw: z.string(),\n});\n\nexport type TaskRunCustomErrorObject = z.infer<typeof TaskRunCustomErrorObject>;\n\nexport const TaskRunStringError = z.object({\n  type: z.literal(\"STRING_ERROR\"),\n  raw: z.string(),\n});\n\nexport type TaskRunStringError = z.infer<typeof TaskRunStringError>;\n\nexport const TaskRunErrorCodes = {\n  COULD_NOT_FIND_EXECUTOR: \"COULD_NOT_FIND_EXECUTOR\",\n  COULD_NOT_FIND_TASK: \"COULD_NOT_FIND_TASK\",\n  CONFIGURED_INCORRECTLY: \"CONFIGURED_INCORRECTLY\",\n  TASK_ALREADY_RUNNING: \"TASK_ALREADY_RUNNING\",\n  TASK_EXECUTION_FAILED: \"TASK_EXECUTION_FAILED\",\n  TASK_EXECUTION_ABORTED: \"TASK_EXECUTION_ABORTED\",\n  TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE: \"TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE\",\n  TASK_PROCESS_SIGKILL_TIMEOUT: \"TASK_PROCESS_SIGKILL_TIMEOUT\",\n  TASK_RUN_CANCELLED: \"TASK_RUN_CANCELLED\",\n  TASK_OUTPUT_ERROR: \"TASK_OUTPUT_ERROR\",\n  HANDLE_ERROR_ERROR: \"HANDLE_ERROR_ERROR\",\n  GRACEFUL_EXIT_TIMEOUT: \"GRACEFUL_EXIT_TIMEOUT\",\n  TASK_RUN_CRASHED: \"TASK_RUN_CRASHED\",\n} as const;\n\nexport const TaskRunInternalError = z.object({\n  type: z.literal(\"INTERNAL_ERROR\"),\n  code: z.enum([\n    \"COULD_NOT_FIND_EXECUTOR\",\n    \"COULD_NOT_FIND_TASK\",\n    \"CONFIGURED_INCORRECTLY\",\n    \"TASK_ALREADY_RUNNING\",\n    \"TASK_EXECUTION_FAILED\",\n    \"TASK_EXECUTION_ABORTED\",\n    \"TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE\",\n    \"TASK_PROCESS_SIGKILL_TIMEOUT\",\n    \"TASK_RUN_CANCELLED\",\n    \"TASK_OUTPUT_ERROR\",\n    \"HANDLE_ERROR_ERROR\",\n    \"GRACEFUL_EXIT_TIMEOUT\",\n    \"TASK_RUN_HEARTBEAT_TIMEOUT\",\n    \"TASK_RUN_CRASHED\",\n  ]),\n  message: z.string().optional(),\n  stackTrace: z.string().optional(),\n});\n\nexport type TaskRunInternalError = z.infer<typeof TaskRunInternalError>;\n\nexport const TaskRunError = z.discriminatedUnion(\"type\", [\n  TaskRunBuiltInError,\n  TaskRunCustomErrorObject,\n  TaskRunStringError,\n  TaskRunInternalError,\n]);\n\nexport type TaskRunError = z.infer<typeof TaskRunError>;\n\nexport const TaskRun = z.object({\n  id: z.string(),\n  payload: z.string(),\n  payloadType: z.string(),\n  context: z.any(),\n  tags: z.array(z.string()),\n  isTest: z.boolean().default(false),\n  createdAt: z.coerce.date(),\n  startedAt: z.coerce.date().default(() => new Date()),\n  idempotencyKey: z.string().optional(),\n  maxAttempts: z.number().optional(),\n  durationMs: z.number().default(0),\n  costInCents: z.number().default(0),\n  baseCostInCents: z.number().default(0),\n  version: z.string().optional(),\n});\n\nexport type TaskRun = z.infer<typeof TaskRun>;\n\nexport const TaskRunExecutionTask = z.object({\n  id: z.string(),\n  filePath: z.string(),\n  exportName: z.string(),\n});\n\nexport type TaskRunExecutionTask = z.infer<typeof TaskRunExecutionTask>;\n\nexport const TaskRunExecutionAttempt = z.object({\n  id: z.string(),\n  number: z.number(),\n  startedAt: z.coerce.date(),\n  backgroundWorkerId: z.string(),\n  backgroundWorkerTaskId: z.string(),\n  status: z.string(),\n});\n\nexport type TaskRunExecutionAttempt = z.infer<typeof TaskRunExecutionAttempt>;\n\nexport const TaskRunExecutionEnvironment = z.object({\n  id: z.string(),\n  slug: z.string(),\n  type: z.enum([\"PRODUCTION\", \"STAGING\", \"DEVELOPMENT\", \"PREVIEW\"]),\n});\n\nexport type TaskRunExecutionEnvironment = z.infer<typeof TaskRunExecutionEnvironment>;\n\nexport const TaskRunExecutionOrganization = z.object({\n  id: z.string(),\n  slug: z.string(),\n  name: z.string(),\n});\n\nexport type TaskRunExecutionOrganization = z.infer<typeof TaskRunExecutionOrganization>;\n\nexport const TaskRunExecutionProject = z.object({\n  id: z.string(),\n  ref: z.string(),\n  slug: z.string(),\n  name: z.string(),\n});\n\nexport type TaskRunExecutionProject = z.infer<typeof TaskRunExecutionProject>;\n\nexport const TaskRunExecutionQueue = z.object({\n  id: z.string(),\n  name: z.string(),\n});\n\nexport type TaskRunExecutionQueue = z.infer<typeof TaskRunExecutionQueue>;\n\nexport const TaskRunExecutionBatch = z.object({\n  id: z.string(),\n});\n\nexport const TaskRunExecution = z.object({\n  task: TaskRunExecutionTask,\n  attempt: TaskRunExecutionAttempt,\n  run: TaskRun,\n  queue: TaskRunExecutionQueue,\n  environment: TaskRunExecutionEnvironment,\n  organization: TaskRunExecutionOrganization,\n  project: TaskRunExecutionProject,\n  batch: TaskRunExecutionBatch.optional(),\n  machine: MachinePreset.optional(),\n});\n\nexport type TaskRunExecution = z.infer<typeof TaskRunExecution>;\n\nexport const TaskRunContext = z.object({\n  task: TaskRunExecutionTask,\n  attempt: TaskRunExecutionAttempt.omit({\n    backgroundWorkerId: true,\n    backgroundWorkerTaskId: true,\n  }),\n  run: TaskRun.omit({ payload: true, payloadType: true }),\n  queue: TaskRunExecutionQueue,\n  environment: TaskRunExecutionEnvironment,\n  organization: TaskRunExecutionOrganization,\n  project: TaskRunExecutionProject,\n  batch: TaskRunExecutionBatch.optional(),\n  machine: MachinePreset.optional(),\n});\n\nexport type TaskRunContext = z.infer<typeof TaskRunContext>;\n\nexport const TaskRunExecutionRetry = z.object({\n  timestamp: z.number(),\n  delay: z.number(),\n  error: z.unknown().optional(),\n});\n\nexport type TaskRunExecutionRetry = z.infer<typeof TaskRunExecutionRetry>;\n\nexport const TaskRunExecutionUsage = z.object({\n  durationMs: z.number(),\n});\n\nexport type TaskRunExecutionUsage = z.infer<typeof TaskRunExecutionUsage>;\n\nexport const TaskRunFailedExecutionResult = z.object({\n  ok: z.literal(false),\n  id: z.string(),\n  error: TaskRunError,\n  retry: TaskRunExecutionRetry.optional(),\n  skippedRetrying: z.boolean().optional(),\n  usage: TaskRunExecutionUsage.optional(),\n});\n\nexport type TaskRunFailedExecutionResult = z.infer<typeof TaskRunFailedExecutionResult>;\n\nexport const TaskRunSuccessfulExecutionResult = z.object({\n  ok: z.literal(true),\n  id: z.string(),\n  output: z.string().optional(),\n  outputType: z.string(),\n  usage: TaskRunExecutionUsage.optional(),\n});\n\nexport type TaskRunSuccessfulExecutionResult = z.infer<typeof TaskRunSuccessfulExecutionResult>;\n\nexport const TaskRunExecutionResult = z.discriminatedUnion(\"ok\", [\n  TaskRunSuccessfulExecutionResult,\n  TaskRunFailedExecutionResult,\n]);\n\nexport type TaskRunExecutionResult = z.infer<typeof TaskRunExecutionResult>;\n\nexport const BatchTaskRunExecutionResult = z.object({\n  id: z.string(),\n  items: TaskRunExecutionResult.array(),\n});\n\nexport type BatchTaskRunExecutionResult = z.infer<typeof BatchTaskRunExecutionResult>;\n", "import { context, propagation } from \"@opentelemetry/api\";\nimport { z } from \"zod\";\nimport { version } from \"../../../package.json\";\nimport {\n  AddTagsRequestBody,\n  BatchTaskRunExecutionResult,\n  BatchTriggerTaskRequestBody,\n  BatchTriggerTaskResponse,\n  CanceledRunResponse,\n  CreateEnvironmentVariableRequestBody,\n  CreateScheduleOptions,\n  CreateUploadPayloadUrlResponseBody,\n  DeletedScheduleObject,\n  EnvironmentVariableResponseBody,\n  EnvironmentVariableValue,\n  EnvironmentVariables,\n  ListRunResponseItem,\n  ListScheduleOptions,\n  ReplayRunResponse,\n  RescheduleRunRequestBody,\n  RetrieveRunResponse,\n  ScheduleObject,\n  TaskRunExecutionResult,\n  TriggerTaskRequestBody,\n  TriggerTaskResponse,\n  UpdateEnvironmentVariableRequestBody,\n  UpdateScheduleOptions,\n} from \"../schemas\";\nimport { taskContext } from \"../task-context-api\";\nimport {\n  ApiRequestOptions,\n  CursorPagePromise,\n  ZodFetchOptions,\n  isRequestOptions,\n  zodfetch,\n  zodfetchCursorPage,\n  zodfetchOffsetLimitPage,\n} from \"./core\";\nimport { ApiError } from \"./errors\";\nimport {\n  CreateEnvironmentVariableParams,\n  ImportEnvironmentVariablesParams,\n  ListProjectRunsQueryParams,\n  ListRunsQueryParams,\n  UpdateEnvironmentVariableParams,\n} from \"./types\";\n\nexport type {\n  CreateEnvironmentVariableParams,\n  ImportEnvironmentVariablesParams,\n  UpdateEnvironmentVariableParams,\n};\n\nexport type TriggerOptions = {\n  spanParentAsLink?: boolean;\n};\n\nconst DEFAULT_ZOD_FETCH_OPTIONS: ZodFetchOptions = {\n  retry: {\n    maxAttempts: 3,\n    minTimeoutInMs: 1000,\n    maxTimeoutInMs: 30_000,\n    factor: 2,\n    randomize: false,\n  },\n};\n\nexport { isRequestOptions };\nexport type { ApiRequestOptions };\n\n/**\n * Trigger.dev v3 API client\n */\nexport class ApiClient {\n  private readonly baseUrl: string;\n  private readonly defaultRequestOptions: ZodFetchOptions;\n\n  constructor(\n    baseUrl: string,\n    private readonly accessToken: string,\n    requestOptions: ApiRequestOptions = {}\n  ) {\n    this.baseUrl = baseUrl.replace(/\\/$/, \"\");\n    this.defaultRequestOptions = mergeRequestOptions(DEFAULT_ZOD_FETCH_OPTIONS, requestOptions);\n  }\n\n  async getRunResult(\n    runId: string,\n    requestOptions?: ZodFetchOptions\n  ): Promise<TaskRunExecutionResult | undefined> {\n    try {\n      return await zodfetch(\n        TaskRunExecutionResult,\n        `${this.baseUrl}/api/v1/runs/${runId}/result`,\n        {\n          method: \"GET\",\n          headers: this.#getHeaders(false),\n        },\n        mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n      );\n    } catch (error) {\n      if (error instanceof ApiError) {\n        if (error.status === 404) {\n          return undefined;\n        }\n      }\n\n      throw error;\n    }\n  }\n\n  async getBatchResults(\n    batchId: string,\n    requestOptions?: ZodFetchOptions\n  ): Promise<BatchTaskRunExecutionResult | undefined> {\n    return await zodfetch(\n      BatchTaskRunExecutionResult,\n      `${this.baseUrl}/api/v1/batches/${batchId}/results`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  triggerTask(\n    taskId: string,\n    body: TriggerTaskRequestBody,\n    options?: TriggerOptions,\n    requestOptions?: ZodFetchOptions\n  ) {\n    const encodedTaskId = encodeURIComponent(taskId);\n\n    return zodfetch(\n      TriggerTaskResponse,\n      `${this.baseUrl}/api/v1/tasks/${encodedTaskId}/trigger`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(options?.spanParentAsLink ?? false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  batchTriggerTask(\n    taskId: string,\n    body: BatchTriggerTaskRequestBody,\n    options?: TriggerOptions,\n    requestOptions?: ZodFetchOptions\n  ) {\n    const encodedTaskId = encodeURIComponent(taskId);\n\n    return zodfetch(\n      BatchTriggerTaskResponse,\n      `${this.baseUrl}/api/v1/tasks/${encodedTaskId}/batch`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(options?.spanParentAsLink ?? false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  createUploadPayloadUrl(filename: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      CreateUploadPayloadUrlResponseBody,\n      `${this.baseUrl}/api/v1/packets/${filename}`,\n      {\n        method: \"PUT\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  getPayloadUrl(filename: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      CreateUploadPayloadUrlResponseBody,\n      `${this.baseUrl}/api/v1/packets/${filename}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  retrieveRun(runId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      RetrieveRunResponse,\n      `${this.baseUrl}/api/v3/runs/${runId}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listRuns(\n    query?: ListRunsQueryParams,\n    requestOptions?: ZodFetchOptions\n  ): CursorPagePromise<typeof ListRunResponseItem> {\n    const searchParams = createSearchQueryForListRuns(query);\n\n    return zodfetchCursorPage(\n      ListRunResponseItem,\n      `${this.baseUrl}/api/v1/runs`,\n      {\n        query: searchParams,\n        limit: query?.limit,\n        after: query?.after,\n        before: query?.before,\n      },\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listProjectRuns(\n    projectRef: string,\n    query?: ListProjectRunsQueryParams,\n    requestOptions?: ZodFetchOptions\n  ): CursorPagePromise<typeof ListRunResponseItem> {\n    const searchParams = createSearchQueryForListRuns(query);\n\n    if (query?.env) {\n      searchParams.append(\n        \"filter[env]\",\n        Array.isArray(query.env) ? query.env.join(\",\") : query.env\n      );\n    }\n\n    return zodfetchCursorPage(\n      ListRunResponseItem,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/runs`,\n      {\n        query: searchParams,\n        limit: query?.limit,\n        after: query?.after,\n        before: query?.before,\n      },\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  replayRun(runId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ReplayRunResponse,\n      `${this.baseUrl}/api/v1/runs/${runId}/replay`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  cancelRun(runId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      CanceledRunResponse,\n      `${this.baseUrl}/api/v2/runs/${runId}/cancel`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  rescheduleRun(runId: string, body: RescheduleRunRequestBody, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      RetrieveRunResponse,\n      `${this.baseUrl}/api/v1/runs/${runId}/reschedule`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  addTags(runId: string, body: AddTagsRequestBody, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      z.object({ message: z.string() }),\n      `${this.baseUrl}/api/v1/runs/${runId}/tags`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  createSchedule(options: CreateScheduleOptions, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(options),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listSchedules(options?: ListScheduleOptions, requestOptions?: ZodFetchOptions) {\n    const searchParams = new URLSearchParams();\n\n    if (options?.page) {\n      searchParams.append(\"page\", options.page.toString());\n    }\n\n    if (options?.perPage) {\n      searchParams.append(\"perPage\", options.perPage.toString());\n    }\n\n    return zodfetchOffsetLimitPage(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules`,\n      {\n        page: options?.page,\n        limit: options?.perPage,\n      },\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  retrieveSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  updateSchedule(\n    scheduleId: string,\n    options: UpdateScheduleOptions,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}`,\n      {\n        method: \"PUT\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(options),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  deactivateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}/deactivate`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  activateSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      ScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}/activate`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  deleteSchedule(scheduleId: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      DeletedScheduleObject,\n      `${this.baseUrl}/api/v1/schedules/${scheduleId}`,\n      {\n        method: \"DELETE\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  listEnvVars(projectRef: string, slug: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      EnvironmentVariables,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  importEnvVars(\n    projectRef: string,\n    slug: string,\n    body: ImportEnvironmentVariablesParams,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/import`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  retrieveEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      EnvironmentVariableValue,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`,\n      {\n        method: \"GET\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  createEnvVar(\n    projectRef: string,\n    slug: string,\n    body: CreateEnvironmentVariableRequestBody,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}`,\n      {\n        method: \"POST\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  updateEnvVar(\n    projectRef: string,\n    slug: string,\n    key: string,\n    body: UpdateEnvironmentVariableRequestBody,\n    requestOptions?: ZodFetchOptions\n  ) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`,\n      {\n        method: \"PUT\",\n        headers: this.#getHeaders(false),\n        body: JSON.stringify(body),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  deleteEnvVar(projectRef: string, slug: string, key: string, requestOptions?: ZodFetchOptions) {\n    return zodfetch(\n      EnvironmentVariableResponseBody,\n      `${this.baseUrl}/api/v1/projects/${projectRef}/envvars/${slug}/${key}`,\n      {\n        method: \"DELETE\",\n        headers: this.#getHeaders(false),\n      },\n      mergeRequestOptions(this.defaultRequestOptions, requestOptions)\n    );\n  }\n\n  #getHeaders(spanParentAsLink: boolean) {\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.accessToken}`,\n      \"trigger-version\": version,\n    };\n\n    // Only inject the context if we are inside a task\n    if (taskContext.isInsideTask) {\n      headers[\"x-trigger-worker\"] = \"true\";\n      propagation.inject(context.active(), headers);\n\n      if (spanParentAsLink) {\n        headers[\"x-trigger-span-parent-as-link\"] = \"1\";\n      }\n    }\n\n    return headers;\n  }\n}\n\nfunction createSearchQueryForListRuns(query?: ListRunsQueryParams): URLSearchParams {\n  const searchParams = new URLSearchParams();\n\n  if (query) {\n    if (query.status) {\n      searchParams.append(\n        \"filter[status]\",\n        Array.isArray(query.status) ? query.status.join(\",\") : query.status\n      );\n    }\n\n    if (query.taskIdentifier) {\n      searchParams.append(\n        \"filter[taskIdentifier]\",\n        Array.isArray(query.taskIdentifier) ? query.taskIdentifier.join(\",\") : query.taskIdentifier\n      );\n    }\n\n    if (query.version) {\n      searchParams.append(\n        \"filter[version]\",\n        Array.isArray(query.version) ? query.version.join(\",\") : query.version\n      );\n    }\n\n    if (query.bulkAction) {\n      searchParams.append(\"filter[bulkAction]\", query.bulkAction);\n    }\n\n    if (query.tag) {\n      searchParams.append(\n        \"filter[tag]\",\n        Array.isArray(query.tag) ? query.tag.join(\",\") : query.tag\n      );\n    }\n\n    if (query.schedule) {\n      searchParams.append(\"filter[schedule]\", query.schedule);\n    }\n\n    if (typeof query.isTest === \"boolean\") {\n      searchParams.append(\"filter[isTest]\", String(query.isTest));\n    }\n\n    if (query.from) {\n      searchParams.append(\n        \"filter[createdAt][from]\",\n        query.from instanceof Date ? query.from.getTime().toString() : query.from.toString()\n      );\n    }\n\n    if (query.to) {\n      searchParams.append(\n        \"filter[createdAt][to]\",\n        query.to instanceof Date ? query.to.getTime().toString() : query.to.toString()\n      );\n    }\n\n    if (query.period) {\n      searchParams.append(\"filter[createdAt][period]\", query.period);\n    }\n  }\n\n  return searchParams;\n}\n\nexport function mergeRequestOptions(\n  defaultOptions: ZodFetchOptions,\n  options?: ApiRequestOptions\n): ZodFetchOptions {\n  if (!options) {\n    return defaultOptions;\n  }\n\n  return {\n    ...defaultOptions,\n    ...options,\n    retry: {\n      ...defaultOptions.retry,\n      ...options.retry,\n    },\n  };\n}\n", "import { z } from \"zod\";\nimport { fromZodError } from \"zod-validation-error\";\nimport { RetryOptions } from \"../schemas\";\nimport { calculateNextRetryDelay } from \"../utils/retries\";\nimport { ApiConnectionError, ApiError } from \"./errors\";\n\nimport { Attributes, Span } from \"@opentelemetry/api\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { TriggerTracer } from \"../tracer\";\nimport { accessoryAttributes } from \"../utils/styleAttributes\";\nimport {\n  CursorPage,\n  CursorPageParams,\n  CursorPageResponse,\n  OffsetLimitPage,\n  OffsetLimitPageParams,\n  OffsetLimitPageResponse,\n} from \"./pagination\";\n\nexport const defaultRetryOptions = {\n  maxAttempts: 3,\n  factor: 2,\n  minTimeoutInMs: 1000,\n  maxTimeoutInMs: 60000,\n  randomize: false,\n} satisfies RetryOptions;\n\nexport type ZodFetchOptions = {\n  retry?: RetryOptions;\n  tracer?: TriggerTracer;\n  name?: string;\n  attributes?: Attributes;\n  icon?: string;\n  onResponseBody?: (body: unknown, span: Span) => void;\n};\n\nexport type ApiRequestOptions = Pick<ZodFetchOptions, \"retry\">;\ntype KeysEnum<T> = { [P in keyof Required<T>]: true };\n\n// This is required so that we can determine if a given object matches the ApiRequestOptions\n// type at runtime. While this requires duplication, it is enforced by the TypeScript\n// compiler such that any missing / extraneous keys will cause an error.\nconst requestOptionsKeys: KeysEnum<ApiRequestOptions> = {\n  retry: true,\n};\n\nexport const isRequestOptions = (obj: unknown): obj is ApiRequestOptions => {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    !isEmptyObj(obj) &&\n    Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k))\n  );\n};\n\ninterface FetchCursorPageParams extends CursorPageParams {\n  query?: URLSearchParams;\n}\n\ninterface FetchOffsetLimitPageParams extends OffsetLimitPageParams {\n  query?: URLSearchParams;\n}\n\nexport function zodfetch<TResponseBodySchema extends z.ZodTypeAny>(\n  schema: TResponseBodySchema,\n  url: string,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions\n): ApiPromise<z.output<TResponseBodySchema>> {\n  return new ApiPromise(_doZodFetch(schema, url, requestInit, options));\n}\n\nexport function zodfetchCursorPage<TItemSchema extends z.ZodTypeAny>(\n  schema: TItemSchema,\n  url: string,\n  params: FetchCursorPageParams,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions\n) {\n  const query = new URLSearchParams(params.query);\n\n  if (params.limit) {\n    query.set(\"page[size]\", String(params.limit));\n  }\n\n  if (params.after) {\n    query.set(\"page[after]\", params.after);\n  }\n\n  if (params.before) {\n    query.set(\"page[before]\", params.before);\n  }\n\n  const cursorPageSchema = z.object({\n    data: z.array(schema),\n    pagination: z.object({\n      next: z.string().optional(),\n      previous: z.string().optional(),\n    }),\n  });\n\n  const $url = new URL(url);\n  $url.search = query.toString();\n\n  const fetchResult = _doZodFetch(cursorPageSchema, $url.href, requestInit, options);\n\n  return new CursorPagePromise(fetchResult, schema, url, params, requestInit, options);\n}\n\nexport function zodfetchOffsetLimitPage<TItemSchema extends z.ZodTypeAny>(\n  schema: TItemSchema,\n  url: string,\n  params: FetchOffsetLimitPageParams,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions\n) {\n  const query = new URLSearchParams(params.query);\n\n  if (params.limit) {\n    query.set(\"perPage\", String(params.limit));\n  }\n\n  if (params.page) {\n    query.set(\"page\", String(params.page));\n  }\n\n  const offsetLimitPageSchema = z.object({\n    data: z.array(schema),\n    pagination: z.object({\n      currentPage: z.coerce.number(),\n      totalPages: z.coerce.number(),\n      count: z.coerce.number(),\n    }),\n  });\n\n  const $url = new URL(url);\n  $url.search = query.toString();\n\n  const fetchResult = _doZodFetch(offsetLimitPageSchema, $url.href, requestInit, options);\n\n  return new OffsetLimitPagePromise(fetchResult, schema, url, params, requestInit, options);\n}\n\ntype ZodFetchResult<T> = {\n  data: T;\n  response: Response;\n};\n\ntype PromiseOrValue<T> = T | Promise<T>;\n\nasync function traceZodFetch<T>(\n  params: {\n    url: string;\n    requestInit?: RequestInit;\n    options?: ZodFetchOptions;\n  },\n  callback: (span?: Span) => Promise<T>\n): Promise<T> {\n  if (!params.options?.tracer) {\n    return callback();\n  }\n\n  const url = new URL(params.url);\n  const method = params.requestInit?.method ?? \"GET\";\n  const name = params.options.name ?? `${method} ${url.pathname}`;\n\n  return await params.options.tracer.startActiveSpan(\n    name,\n    async (span) => {\n      return await callback(span);\n    },\n    {\n      attributes: {\n        [SemanticInternalAttributes.STYLE_ICON]: params.options?.icon ?? \"api\",\n        ...params.options.attributes,\n      },\n    }\n  );\n}\n\nasync function _doZodFetch<TResponseBodySchema extends z.ZodTypeAny>(\n  schema: TResponseBodySchema,\n  url: string,\n  requestInit?: PromiseOrValue<RequestInit>,\n  options?: ZodFetchOptions\n): Promise<ZodFetchResult<z.output<TResponseBodySchema>>> {\n  const $requestInit = await requestInit;\n\n  return traceZodFetch({ url, requestInit: $requestInit, options }, async (span) => {\n    const result = await _doZodFetchWithRetries(schema, url, $requestInit, options);\n\n    if (options?.onResponseBody && span) {\n      options.onResponseBody(result.data, span);\n    }\n\n    return result;\n  });\n}\n\nasync function _doZodFetchWithRetries<TResponseBodySchema extends z.ZodTypeAny>(\n  schema: TResponseBodySchema,\n  url: string,\n  requestInit?: RequestInit,\n  options?: ZodFetchOptions,\n  attempt = 1\n): Promise<ZodFetchResult<z.output<TResponseBodySchema>>> {\n  try {\n    const response = await fetch(url, requestInitWithCache(requestInit));\n\n    const responseHeaders = createResponseHeaders(response.headers);\n\n    if (!response.ok) {\n      const retryResult = shouldRetry(response, attempt, options?.retry);\n\n      if (retryResult.retry) {\n        await waitForRetry(url, attempt + 1, retryResult.delay, options, requestInit, response);\n\n        return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);\n      } else {\n        const errText = await response.text().catch((e) => castToError(e).message);\n        const errJSON = safeJsonParse(errText);\n        const errMessage = errJSON ? undefined : errText;\n\n        throw ApiError.generate(response.status, errJSON, errMessage, responseHeaders);\n      }\n    }\n\n    const jsonBody = await response.json();\n    const parsedResult = schema.safeParse(jsonBody);\n\n    if (parsedResult.success) {\n      return { data: parsedResult.data, response };\n    }\n\n    throw fromZodError(parsedResult.error);\n  } catch (error) {\n    if (error instanceof ApiError) {\n      throw error;\n    }\n\n    if (options?.retry) {\n      const retry = { ...defaultRetryOptions, ...options.retry };\n\n      const delay = calculateNextRetryDelay(retry, attempt);\n\n      if (delay) {\n        await waitForRetry(url, attempt + 1, delay, options, requestInit);\n\n        return await _doZodFetchWithRetries(schema, url, requestInit, options, attempt + 1);\n      }\n    }\n\n    throw new ApiConnectionError({ cause: castToError(error) });\n  }\n}\n\nfunction castToError(err: any): Error {\n  if (err instanceof Error) return err;\n  return new Error(err);\n}\n\ntype ShouldRetryResult =\n  | {\n      retry: false;\n    }\n  | {\n      retry: true;\n      delay: number;\n    };\n\nfunction shouldRetry(\n  response: Response,\n  attempt: number,\n  retryOptions?: RetryOptions\n): ShouldRetryResult {\n  function shouldRetryForOptions(): ShouldRetryResult {\n    const retry = { ...defaultRetryOptions, ...retryOptions };\n\n    const delay = calculateNextRetryDelay(retry, attempt);\n\n    if (delay) {\n      return { retry: true, delay };\n    } else {\n      return { retry: false };\n    }\n  }\n\n  // Note this is not a standard header.\n  const shouldRetryHeader = response.headers.get(\"x-should-retry\");\n\n  // If the server explicitly says whether or not to retry, obey.\n  if (shouldRetryHeader === \"true\") return shouldRetryForOptions();\n  if (shouldRetryHeader === \"false\") return { retry: false };\n\n  // Retry on request timeouts.\n  if (response.status === 408) return shouldRetryForOptions();\n\n  // Retry on lock timeouts.\n  if (response.status === 409) return shouldRetryForOptions();\n\n  // Retry on rate limits.\n  if (response.status === 429) {\n    if (\n      attempt >= (typeof retryOptions?.maxAttempts === \"number\" ? retryOptions?.maxAttempts : 3)\n    ) {\n      return { retry: false };\n    }\n\n    // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.\n    const resetAtUnixEpochMs = response.headers.get(\"x-ratelimit-reset\");\n\n    if (resetAtUnixEpochMs) {\n      const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);\n      const delay = resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 1000);\n\n      if (delay > 0) {\n        return { retry: true, delay };\n      }\n    }\n\n    return shouldRetryForOptions();\n  }\n\n  // Retry internal errors.\n  if (response.status >= 500) return shouldRetryForOptions();\n\n  return { retry: false };\n}\n\nfunction safeJsonParse(text: string): any {\n  try {\n    return JSON.parse(text);\n  } catch (e) {\n    return undefined;\n  }\n}\n\nfunction createResponseHeaders(headers: Response[\"headers\"]): Record<string, string> {\n  return new Proxy(\n    Object.fromEntries(\n      // @ts-ignore\n      headers.entries()\n    ),\n    {\n      get(target, name) {\n        const key = name.toString();\n        return target[key.toLowerCase()] || target[key];\n      },\n    }\n  );\n}\n\nfunction requestInitWithCache(requestInit?: RequestInit): RequestInit {\n  try {\n    const withCache: RequestInit = {\n      ...requestInit,\n      cache: \"no-cache\",\n    };\n\n    const _ = new Request(\"http://localhost\", withCache);\n\n    return withCache;\n  } catch (error) {\n    return requestInit ?? {};\n  }\n}\n\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nexport class ApiPromise<T> extends Promise<T> {\n  constructor(private responsePromise: Promise<ZodFetchResult<T>>) {\n    super((resolve) => {\n      // this is maybe a bit weird but this has to be a no-op to not implicitly\n      // parse the response body; instead .then, .catch, .finally are overridden\n      // to parse the response\n      resolve(null as any);\n    });\n  }\n\n  /**\n   * Gets the raw `Response` instance instead of parsing the response\n   * data.\n   *\n   * If you want to parse the response body but still get the `Response`\n   * instance, you can use {@link withResponse()}.\n   */\n  asResponse(): Promise<Response> {\n    return this.responsePromise.then((p) => p.response);\n  }\n\n  /**\n   * Gets the parsed response data and the raw `Response` instance.\n   *\n   * If you just want to get the raw `Response` instance without parsing it,\n   * you can use {@link asResponse()}.\n   */\n  async withResponse(): Promise<{ data: T; response: Response }> {\n    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n    return { data, response };\n  }\n\n  private parse(): Promise<T> {\n    return this.responsePromise.then((result) => result.data);\n  }\n\n  override then<TResult1 = T, TResult2 = never>(\n    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): Promise<TResult1 | TResult2> {\n    return this.parse().then(onfulfilled, onrejected);\n  }\n\n  override catch<TResult = never>(\n    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null\n  ): Promise<T | TResult> {\n    return this.parse().catch(onrejected);\n  }\n\n  override finally(onfinally?: (() => void) | undefined | null): Promise<T> {\n    return this.parse().finally(onfinally);\n  }\n}\n\nexport class CursorPagePromise<TItemSchema extends z.ZodTypeAny>\n  extends ApiPromise<CursorPage<z.output<TItemSchema>>>\n  implements AsyncIterable<z.output<TItemSchema>>\n{\n  constructor(\n    result: Promise<ZodFetchResult<CursorPageResponse<z.output<TItemSchema>>>>,\n    private schema: TItemSchema,\n    private url: string,\n    private params: FetchCursorPageParams,\n    private requestInit?: RequestInit,\n    private options?: ZodFetchOptions\n  ) {\n    super(\n      result.then((result) => ({\n        data: new CursorPage(result.data.data, result.data.pagination, this.#fetchPage.bind(this)),\n        response: result.response,\n      }))\n    );\n  }\n\n  #fetchPage(params: Omit<CursorPageParams, \"limit\">): Promise<CursorPage<z.output<TItemSchema>>> {\n    return zodfetchCursorPage(\n      this.schema,\n      this.url,\n      { ...this.params, ...params },\n      this.requestInit,\n      this.options\n    );\n  }\n\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n\nexport class OffsetLimitPagePromise<TItemSchema extends z.ZodTypeAny>\n  extends ApiPromise<OffsetLimitPage<z.output<TItemSchema>>>\n  implements AsyncIterable<z.output<TItemSchema>>\n{\n  constructor(\n    result: Promise<ZodFetchResult<OffsetLimitPageResponse<z.output<TItemSchema>>>>,\n    private schema: TItemSchema,\n    private url: string,\n    private params: FetchOffsetLimitPageParams,\n    private requestInit?: RequestInit,\n    private options?: ZodFetchOptions\n  ) {\n    super(\n      result.then((result) => ({\n        data: new OffsetLimitPage(\n          result.data.data,\n          result.data.pagination,\n          this.#fetchPage.bind(this)\n        ),\n        response: result.response,\n      }))\n    );\n  }\n\n  #fetchPage(\n    params: Omit<FetchOffsetLimitPageParams, \"limit\">\n  ): Promise<OffsetLimitPage<z.output<TItemSchema>>> {\n    return zodfetchOffsetLimitPage(\n      this.schema,\n      this.url,\n      { ...this.params, ...params },\n      this.requestInit,\n      this.options\n    );\n  }\n\n  /**\n   * Allow auto-paginating iteration on an unawaited list call, eg:\n   *\n   *    for await (const item of client.items.list()) {\n   *      console.log(item)\n   *    }\n   */\n  async *[Symbol.asyncIterator]() {\n    const page = await this;\n    for await (const item of page) {\n      yield item;\n    }\n  }\n}\n\nasync function waitForRetry(\n  url: string,\n  attempt: number,\n  delay: number,\n  options?: ZodFetchOptions,\n  requestInit?: RequestInit,\n  response?: Response\n): Promise<void> {\n  if (options?.tracer) {\n    const method = requestInit?.method ?? \"GET\";\n\n    return options.tracer.startActiveSpan(\n      response ? `wait after ${response.status}` : `wait after error`,\n      async (span) => {\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"wait\",\n          ...accessoryAttributes({\n            items: [\n              {\n                text: `retrying ${options?.name ?? method.toUpperCase()} in ${delay}ms`,\n                variant: \"normal\",\n              },\n            ],\n            style: \"codepath\",\n          }),\n        },\n      }\n    );\n  }\n\n  await new Promise((resolve) => setTimeout(resolve, delay));\n}\n\n// https://stackoverflow.com/a/34491287\nexport function isEmptyObj(obj: Object | null | undefined): boolean {\n  if (!obj) return true;\n  for (const _k in obj) return false;\n  return true;\n}\n\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nexport function hasOwn(obj: Object, key: string): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n", "import { calculateResetAt as calculateResetAtInternal } from \"../../retry\";\nimport { FetchRetryOptions, type RetryOptions } from \"../schemas\";\n\nexport const defaultRetryOptions = {\n  maxAttempts: 3,\n  factor: 2,\n  minTimeoutInMs: 1000,\n  maxTimeoutInMs: 60000,\n  randomize: true,\n} satisfies RetryOptions;\n\nexport const defaultFetchRetryOptions = {\n  byStatus: {\n    \"429,408,409,5xx\": {\n      strategy: \"backoff\",\n      ...defaultRetryOptions,\n    },\n  },\n  connectionError: defaultRetryOptions,\n  timeout: defaultRetryOptions,\n} satisfies FetchRetryOptions;\n\n/**\n *\n * @param options\n * @param attempt - The current attempt number. If the first attempt has failed, this will be 1.\n * @returns\n */\nexport function calculateNextRetryDelay(options: RetryOptions, attempt: number) {\n  const opts = { ...defaultRetryOptions, ...options };\n\n  if (attempt >= opts.maxAttempts) {\n    return;\n  }\n\n  const { factor, minTimeoutInMs, maxTimeoutInMs, randomize } = opts;\n\n  const random = randomize ? Math.random() + 1 : 1;\n\n  const timeout = Math.min(maxTimeoutInMs, random * minTimeoutInMs * Math.pow(factor, attempt - 1));\n\n  // Round to the nearest integer\n  return Math.round(timeout);\n}\n\nexport function calculateResetAt(\n  resets: string | undefined | null,\n  format:\n    | \"unix_timestamp\"\n    | \"iso_8601\"\n    | \"iso_8601_duration_openai_variant\"\n    | \"unix_timestamp_in_ms\",\n  now: number = Date.now()\n): number | undefined {\n  const resetAt = calculateResetAtInternal(resets, format, new Date(now));\n\n  return resetAt?.getTime();\n}\n", "export type APIHeaders = Record<string, string | null | undefined>;\n\nexport class ApiError extends Error {\n  readonly status: number | undefined;\n  readonly headers: APIHeaders | undefined;\n  readonly error: Object | undefined;\n\n  readonly code: string | null | undefined;\n  readonly param: string | null | undefined;\n  readonly type: string | undefined;\n\n  constructor(\n    status: number | undefined,\n    error: Object | undefined,\n    message: string | undefined,\n    headers: APIHeaders | undefined\n  ) {\n    super(`${ApiError.makeMessage(status, error, message)}`);\n    this.name = \"TriggerApiError\";\n    this.status = status;\n    this.headers = headers;\n\n    const data = error as Record<string, any>;\n    this.error = data;\n    this.code = data?.[\"code\"];\n    this.param = data?.[\"param\"];\n    this.type = data?.[\"type\"];\n  }\n\n  private static makeMessage(status: number | undefined, error: any, message: string | undefined) {\n    const msg = error?.message\n      ? typeof error.message === \"string\"\n        ? error.message\n        : JSON.stringify(error.message)\n      : error\n      ? JSON.stringify(error)\n      : message;\n\n    if (status && msg) {\n      return `${status} ${msg}`;\n    }\n    if (status) {\n      return `${status} status code (no body)`;\n    }\n    if (msg) {\n      return msg;\n    }\n    return \"(no status code or body)\";\n  }\n\n  static generate(\n    status: number | undefined,\n    errorResponse: Object | undefined,\n    message: string | undefined,\n    headers: APIHeaders | undefined\n  ) {\n    if (!status) {\n      return new ApiConnectionError({ cause: castToError(errorResponse) });\n    }\n\n    const error = (errorResponse as Record<string, any>)?.[\"error\"];\n\n    if (status === 400) {\n      return new BadRequestError(status, error, message, headers);\n    }\n\n    if (status === 401) {\n      return new AuthenticationError(status, error, message, headers);\n    }\n\n    if (status === 403) {\n      return new PermissionDeniedError(status, error, message, headers);\n    }\n\n    if (status === 404) {\n      return new NotFoundError(status, error, message, headers);\n    }\n\n    if (status === 409) {\n      return new ConflictError(status, error, message, headers);\n    }\n\n    if (status === 422) {\n      return new UnprocessableEntityError(status, error, message, headers);\n    }\n\n    if (status === 429) {\n      return new RateLimitError(status, error, message, headers);\n    }\n\n    if (status >= 500) {\n      return new InternalServerError(status, error, message, headers);\n    }\n\n    return new ApiError(status, error, message, headers);\n  }\n}\n\nexport class ApiConnectionError extends ApiError {\n  override readonly status: undefined = undefined;\n\n  constructor({ message, cause }: { message?: string; cause?: Error | undefined }) {\n    super(undefined, undefined, message || \"Connection error.\", undefined);\n    // in some environments the 'cause' property is already declared\n    // @ts-ignore\n    if (cause) this.cause = cause;\n  }\n}\n\nexport class BadRequestError extends ApiError {\n  override readonly status: 400 = 400;\n}\n\nexport class AuthenticationError extends ApiError {\n  override readonly status: 401 = 401;\n}\n\nexport class PermissionDeniedError extends ApiError {\n  override readonly status: 403 = 403;\n}\n\nexport class NotFoundError extends ApiError {\n  override readonly status: 404 = 404;\n}\n\nexport class ConflictError extends ApiError {\n  override readonly status: 409 = 409;\n}\n\nexport class UnprocessableEntityError extends ApiError {\n  override readonly status: 422 = 422;\n}\n\nexport class RateLimitError extends ApiError {\n  override readonly status: 429 = 429;\n\n  get millisecondsUntilReset(): number | undefined {\n    // x-ratelimit-reset is the unix timestamp in milliseconds when the rate limit will reset.\n    const resetAtUnixEpochMs = (this.headers ?? {})[\"x-ratelimit-reset\"];\n\n    if (typeof resetAtUnixEpochMs === \"string\") {\n      const resetAtUnixEpoch = parseInt(resetAtUnixEpochMs, 10);\n\n      if (isNaN(resetAtUnixEpoch)) {\n        return;\n      }\n\n      // Add between 0 and 2000ms to the reset time to add jitter\n      return Math.max(resetAtUnixEpoch - Date.now() + Math.floor(Math.random() * 2000), 0);\n    }\n  }\n}\n\nexport class InternalServerError extends ApiError {}\n\nfunction castToError(err: any): Error {\n  if (err instanceof Error) return err;\n  return new Error(err);\n}\n", "import { Attributes } from \"@opentelemetry/api\";\nimport { Accessory } from \"../schemas\";\nimport { flattenAttributes } from \"./flattenAttributes\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\n\nexport function accessoryAttributes(accessory: Accessory): Attributes {\n  return flattenAttributes(accessory, SemanticInternalAttributes.STYLE_ACCESSORY);\n}\n", "export interface CursorPageParams {\n  limit?: number;\n  after?: string;\n  before?: string;\n}\n\nexport interface OffsetLimitPageParams {\n  limit?: number;\n  page?: number;\n}\n\nexport interface PageResponse<Item> {\n  data: Array<Item>;\n}\n\nexport interface CursorPageResponse<Item> extends PageResponse<Item> {\n  pagination: {\n    next?: string;\n    previous?: string;\n  };\n}\n\nexport interface OffsetLimitPageResponse<Item> extends PageResponse<Item> {\n  pagination: {\n    currentPage: number;\n    totalPages: number;\n    count: number;\n  };\n}\n\nexport interface Page<Item> {\n  getPaginatedItems(): Item[];\n  hasNextPage(): boolean;\n  hasPreviousPage(): boolean;\n}\n\nexport class CursorPage<Item> implements CursorPageResponse<Item>, Page<Item>, AsyncIterable<Item> {\n  data: Array<Item>;\n  pagination: { next?: string; previous?: string };\n\n  constructor(\n    data: Array<Item>,\n    pagination: { next?: string; previous?: string },\n    private pageFetcher: (params: Omit<CursorPageParams, \"limit\">) => Promise<CursorPage<Item>>\n  ) {\n    this.data = data;\n    this.pagination = pagination;\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data ?? [];\n  }\n\n  hasNextPage(): boolean {\n    return !!this.pagination.next;\n  }\n\n  hasPreviousPage(): boolean {\n    return !!this.pagination.previous;\n  }\n\n  getNextPage(): Promise<CursorPage<Item>> {\n    if (!this.pagination.next) {\n      throw new Error(\"No next page available\");\n    }\n\n    return this.pageFetcher({ after: this.pagination.next });\n  }\n\n  getPreviousPage(): Promise<CursorPage<Item>> {\n    if (!this.pagination.previous) {\n      throw new Error(\"No previous page available\");\n    }\n\n    return this.pageFetcher({ before: this.pagination.previous });\n  }\n\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page: CursorPage<Item> = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n\nexport class OffsetLimitPage<Item>\n  implements OffsetLimitPageResponse<Item>, Page<Item>, AsyncIterable<Item>\n{\n  data: Array<Item>;\n  pagination: { currentPage: number; totalPages: number; count: number };\n\n  constructor(\n    data: Array<Item>,\n    pagination: { currentPage: number; totalPages: number; count: number },\n    private pageFetcher: (\n      params: Omit<OffsetLimitPageParams, \"limit\">\n    ) => Promise<OffsetLimitPage<Item>>\n  ) {\n    this.data = data;\n    this.pagination = pagination;\n  }\n\n  getPaginatedItems(): Item[] {\n    return this.data ?? [];\n  }\n\n  hasNextPage(): boolean {\n    return this.pagination.currentPage < this.pagination.totalPages;\n  }\n\n  hasPreviousPage(): boolean {\n    return this.pagination.currentPage > 1;\n  }\n\n  getNextPage(): Promise<OffsetLimitPage<Item>> {\n    if (!this.hasNextPage()) {\n      throw new Error(\"No next page available\");\n    }\n\n    return this.pageFetcher({\n      page: this.pagination.currentPage + 1,\n    });\n  }\n\n  getPreviousPage(): Promise<OffsetLimitPage<Item>> {\n    if (!this.hasPreviousPage()) {\n      throw new Error(\"No previous page available\");\n    }\n\n    return this.pageFetcher({\n      page: this.pagination.currentPage - 1,\n    });\n  }\n\n  async *iterPages() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let page: OffsetLimitPage<Item> = this;\n    yield page;\n    while (page.hasNextPage()) {\n      page = await page.getNextPage();\n      yield page;\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const page of this.iterPages()) {\n      for (const item of page.getPaginatedItems()) {\n        yield item;\n      }\n    }\n  }\n}\n", "import { ApiClient } from \"../apiClient\";\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport { getEnvVar } from \"../utils/getEnv\";\nimport { ApiClientConfiguration } from \"./types\";\n\nconst API_NAME = \"api-client\";\n\nexport class APIClientManagerAPI {\n  private static _instance?: APIClientManagerAPI;\n\n  private constructor() {}\n\n  public static getInstance(): APIClientManagerAPI {\n    if (!this._instance) {\n      this._instance = new APIClientManagerAPI();\n    }\n\n    return this._instance;\n  }\n\n  public disable() {\n    unregisterGlobal(API_NAME);\n  }\n\n  public setGlobalAPIClientConfiguration(config: ApiClientConfiguration): boolean {\n    return registerGlobal(API_NAME, config);\n  }\n\n  get baseURL(): string | undefined {\n    const store = this.#getConfig();\n    return store?.baseURL ?? getEnvVar(\"TRIGGER_API_URL\") ?? \"https://api.trigger.dev\";\n  }\n\n  get accessToken(): string | undefined {\n    const store = this.#getConfig();\n    return store?.secretKey ?? getEnvVar(\"TRIGGER_SECRET_KEY\") ?? getEnvVar(\"TRIGGER_ACCESS_TOKEN\");\n  }\n\n  get client(): ApiClient | undefined {\n    if (!this.baseURL || !this.accessToken) {\n      return undefined;\n    }\n\n    return new ApiClient(this.baseURL, this.accessToken);\n  }\n\n  #getConfig(): ApiClientConfiguration | undefined {\n    return getGlobal(API_NAME);\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { APIClientManagerAPI } from \"./apiClientManager\";\n/** Entrypoint for logger API */\nexport const apiClientManager = APIClientManagerAPI.getInstance();\n\nexport type { ApiClientConfiguration } from \"./apiClientManager/types\";\n", "import { Attributes, Span } from \"@opentelemetry/api\";\nimport { OFFLOAD_IO_PACKET_LENGTH_LIMIT, imposeAttributeLimits } from \"../limits\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { TriggerTracer } from \"../tracer\";\nimport { flattenAttributes } from \"./flattenAttributes\";\nimport { apiClientManager } from \"../apiClientManager-api\";\n\nexport type IOPacket = {\n  data?: string | undefined;\n  dataType: string;\n};\n\nexport async function parsePacket(value: IOPacket): Promise<any> {\n  if (!value.data) {\n    return undefined;\n  }\n\n  switch (value.dataType) {\n    case \"application/json\":\n      return JSON.parse(value.data);\n    case \"application/super+json\":\n      const { parse } = await loadSuperJSON();\n\n      return parse(value.data);\n    case \"text/plain\":\n      return value.data;\n    case \"application/store\":\n      throw new Error(\n        `Cannot parse an application/store packet (${value.data}). Needs to be imported first.`\n      );\n    default:\n      return value.data;\n  }\n}\n\nexport async function stringifyIO(value: any): Promise<IOPacket> {\n  if (value === undefined) {\n    return { dataType: \"application/json\" };\n  }\n\n  if (typeof value === \"string\") {\n    return { data: value, dataType: \"text/plain\" };\n  }\n\n  try {\n    const { stringify } = await loadSuperJSON();\n    const data = stringify(value);\n\n    return { data, dataType: \"application/super+json\" };\n  } catch {\n    return { data: value, dataType: \"application/json\" };\n  }\n}\n\nexport async function conditionallyExportPacket(\n  packet: IOPacket,\n  pathPrefix: string,\n  tracer?: TriggerTracer\n): Promise<IOPacket> {\n  if (apiClientManager.client) {\n    const { needsOffloading, size } = packetRequiresOffloading(packet);\n\n    if (needsOffloading) {\n      if (!tracer) {\n        return await exportPacket(packet, pathPrefix);\n      } else {\n        const result = await tracer.startActiveSpan(\n          \"store.uploadOutput\",\n          async (span) => {\n            return await exportPacket(packet, pathPrefix);\n          },\n          {\n            attributes: {\n              byteLength: size,\n              [SemanticInternalAttributes.STYLE_ICON]: \"cloud-upload\",\n            },\n          }\n        );\n\n        return result ?? packet;\n      }\n    }\n  }\n\n  return packet;\n}\n\nexport function packetRequiresOffloading(\n  packet: IOPacket,\n  lengthLimit?: number\n): {\n  needsOffloading: boolean;\n  size: number;\n} {\n  if (!packet.data) {\n    return {\n      needsOffloading: false,\n      size: 0,\n    };\n  }\n\n  const byteSize = Buffer.byteLength(packet.data, \"utf8\");\n\n  return {\n    needsOffloading: byteSize >= (lengthLimit ?? OFFLOAD_IO_PACKET_LENGTH_LIMIT),\n    size: byteSize,\n  };\n}\n\nasync function exportPacket(packet: IOPacket, pathPrefix: string): Promise<IOPacket> {\n  // Offload the output\n  const filename = `${pathPrefix}.${getPacketExtension(packet.dataType)}`;\n\n  const presignedResponse = await apiClientManager.client!.createUploadPayloadUrl(filename);\n\n  const uploadResponse = await fetch(presignedResponse.presignedUrl, {\n    method: \"PUT\",\n    headers: {\n      \"Content-Type\": packet.dataType,\n    },\n    body: packet.data,\n  });\n\n  if (!uploadResponse.ok) {\n    throw new Error(\n      `Failed to upload output to ${presignedResponse.presignedUrl}: ${uploadResponse.statusText}`\n    );\n  }\n\n  return {\n    data: filename,\n    dataType: \"application/store\",\n  };\n}\n\nexport async function conditionallyImportPacket(\n  packet: IOPacket,\n  tracer?: TriggerTracer\n): Promise<IOPacket> {\n  if (packet.dataType !== \"application/store\") {\n    return packet;\n  }\n\n  if (!tracer) {\n    return await importPacket(packet);\n  } else {\n    const result = await tracer.startActiveSpan(\n      \"store.downloadPayload\",\n      async (span) => {\n        return await importPacket(packet, span);\n      },\n      {\n        attributes: {\n          [SemanticInternalAttributes.STYLE_ICON]: \"cloud-download\",\n        },\n      }\n    );\n\n    return result ?? packet;\n  }\n}\n\nasync function importPacket(packet: IOPacket, span?: Span): Promise<IOPacket> {\n  if (!packet.data) {\n    return packet;\n  }\n\n  if (!apiClientManager.client) {\n    return packet;\n  }\n\n  const presignedResponse = await apiClientManager.client.getPayloadUrl(packet.data);\n\n  const response = await fetch(presignedResponse.presignedUrl);\n\n  if (!response.ok) {\n    throw new Error(\n      `Failed to import packet ${presignedResponse.presignedUrl}: ${response.statusText}`\n    );\n  }\n\n  const data = await response.text();\n\n  span?.setAttribute(\"size\", Buffer.byteLength(data, \"utf8\"));\n\n  return {\n    data,\n    dataType: response.headers.get(\"content-type\") ?? \"application/json\",\n  };\n}\n\nexport async function createPacketAttributes(\n  packet: IOPacket,\n  dataKey: string,\n  dataTypeKey: string\n): Promise<Attributes | undefined> {\n  if (!packet.data) {\n    return;\n  }\n\n  switch (packet.dataType) {\n    case \"application/json\":\n      return {\n        ...flattenAttributes(packet, dataKey),\n        [dataTypeKey]: packet.dataType,\n      };\n    case \"application/super+json\":\n      const { parse } = await loadSuperJSON();\n\n      if (typeof packet.data === \"undefined\" || packet.data === null) {\n        return;\n      }\n\n      try {\n        const parsed = parse(packet.data) as any;\n        const jsonified = JSON.parse(JSON.stringify(parsed, safeReplacer));\n\n        const result = {\n          ...flattenAttributes(jsonified, dataKey),\n          [dataTypeKey]: \"application/json\",\n        };\n\n        return result;\n      } catch (e) {\n        return;\n      }\n\n    case \"application/store\":\n      return {\n        [dataKey]: packet.data,\n        [dataTypeKey]: packet.dataType,\n      };\n    case \"text/plain\":\n      return {\n        [dataKey]: packet.data,\n        [dataTypeKey]: packet.dataType,\n      };\n    default:\n      return;\n  }\n}\n\nexport async function createPacketAttributesAsJson(\n  data: any,\n  dataType: string\n): Promise<Attributes> {\n  if (\n    typeof data === \"string\" ||\n    typeof data === \"number\" ||\n    typeof data === \"boolean\" ||\n    data === null ||\n    data === undefined\n  ) {\n    return data;\n  }\n\n  switch (dataType) {\n    case \"application/json\":\n      return imposeAttributeLimits(flattenAttributes(data, undefined));\n    case \"application/super+json\":\n      const { deserialize } = await loadSuperJSON();\n\n      const deserialized = deserialize(data) as any;\n      const jsonify = safeJsonParse(JSON.stringify(deserialized, safeReplacer));\n\n      return imposeAttributeLimits(flattenAttributes(jsonify, undefined));\n    case \"application/store\":\n      return data;\n    default:\n      return {};\n  }\n}\n\nexport async function prettyPrintPacket(rawData: any, dataType?: string): Promise<string> {\n  if (rawData === undefined) {\n    return \"\";\n  }\n\n  if (dataType === \"application/super+json\") {\n    if (typeof rawData === \"string\") {\n      rawData = safeJsonParse(rawData);\n    }\n    const { deserialize } = await loadSuperJSON();\n\n    return await prettyPrintPacket(deserialize(rawData), \"application/json\");\n  }\n\n  if (dataType === \"application/json\") {\n    if (typeof rawData === \"string\") {\n      rawData = safeJsonParse(rawData);\n    }\n    return JSON.stringify(rawData, safeReplacer, 2);\n  }\n\n  if (typeof rawData === \"string\") {\n    return rawData;\n  }\n\n  return JSON.stringify(rawData, safeReplacer, 2);\n}\n\nfunction safeReplacer(key: string, value: any) {\n  // If it is a BigInt\n  if (typeof value === \"bigint\") {\n    return value.toString(); // Convert to string\n  }\n\n  // if it is a Regex\n  if (value instanceof RegExp) {\n    return value.toString(); // Convert to string\n  }\n\n  // if it is a Set\n  if (value instanceof Set) {\n    return Array.from(value); // Convert to array\n  }\n\n  // if it is a Map, convert it to an object\n  if (value instanceof Map) {\n    const obj: Record<string, any> = {};\n    value.forEach((v, k) => {\n      obj[k] = v;\n    });\n    return obj;\n  }\n\n  return value; // Otherwise return the value as is\n}\n\nfunction getPacketExtension(outputType: string): string {\n  switch (outputType) {\n    case \"application/json\":\n      return \"json\";\n    case \"application/super+json\":\n      return \"json\";\n    case \"text/plain\":\n      return \"txt\";\n    default:\n      return \"txt\";\n  }\n}\n\nasync function loadSuperJSON(): Promise<typeof import(\"superjson\")> {\n  return await import(\"superjson\");\n}\n\nfunction safeJsonParse(value: string): any {\n  try {\n    return JSON.parse(value);\n  } catch {\n    return;\n  }\n}\n\nexport async function replaceSuperJsonPayload(original: string, newPayload: string) {\n  const superjson = await loadSuperJSON();\n  const originalObject = superjson.parse(original);\n  const { meta } = superjson.serialize(originalObject);\n\n  const newSuperJson = {\n    json: JSON.parse(newPayload) as any,\n    meta,\n  };\n\n  return superjson.deserialize(newSuperJson);\n}\n", "import { PreciseDate } from \"@google-cloud/precise-date\";\nimport { Clock, ClockTime } from \"./clock\";\n\nexport type PreciseWallClockOptions = {\n  origin?: ClockTime;\n  now?: PreciseDate;\n};\n\nexport class PreciseWallClock implements Clock {\n  private _origin: {\n    clockTime: ClockTime;\n    preciseDate: PreciseDate;\n  };\n\n  get #originClockTime() {\n    return this._origin.clockTime;\n  }\n\n  get #originPreciseDate() {\n    return this._origin.preciseDate;\n  }\n\n  constructor(options: PreciseWallClockOptions = {}) {\n    this._origin = {\n      clockTime: options.origin ?? process.hrtime(),\n      preciseDate: options.now ?? new PreciseDate(),\n    };\n  }\n\n  preciseNow(): [number, number] {\n    const elapsedHrTime = process.hrtime(this.#originClockTime);\n    const elapsedNanoseconds = BigInt(elapsedHrTime[0]) * BigInt(1e9) + BigInt(elapsedHrTime[1]);\n\n    const preciseDate = new PreciseDate(this.#originPreciseDate.getFullTime() + elapsedNanoseconds);\n    const dateStruct = preciseDate.toStruct();\n\n    return [dateStruct.seconds, dateStruct.nanos];\n  }\n\n  reset() {\n    this._origin = {\n      clockTime: process.hrtime(),\n      preciseDate: new PreciseDate(),\n    };\n  }\n}\n", "import { Attributes, Span, SpanOptions } from \"@opentelemetry/api\";\nimport { Logger, SeverityNumber } from \"@opentelemetry/api-logs\";\nimport { iconStringForSeverity } from \"../icons\";\nimport { SemanticInternalAttributes } from \"../semanticInternalAttributes\";\nimport { TriggerTracer } from \"../tracer\";\nimport { flattenAttributes } from \"../utils/flattenAttributes\";\nimport { ClockTime } from \"../clock/clock\";\nimport { clock } from \"../clock-api\";\n\nexport type LogLevel = \"none\" | \"error\" | \"warn\" | \"info\" | \"debug\" | \"log\";\n\nexport const logLevels: Array<LogLevel> = [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\nexport type TaskLoggerConfig = {\n  logger: Logger;\n  tracer: TriggerTracer;\n  level: LogLevel;\n};\n\nexport interface TaskLogger {\n  debug(message: string, properties?: Record<string, unknown>): void;\n  log(message: string, properties?: Record<string, unknown>): void;\n  info(message: string, properties?: Record<string, unknown>): void;\n  warn(message: string, properties?: Record<string, unknown>): void;\n  error(message: string, properties?: Record<string, unknown>): void;\n  trace<T>(name: string, fn: (span: Span) => Promise<T>, options?: SpanOptions): Promise<T>;\n}\n\nexport class OtelTaskLogger implements TaskLogger {\n  private readonly _level: number;\n\n  constructor(private readonly _config: TaskLoggerConfig) {\n    this._level = logLevels.indexOf(_config.level);\n  }\n\n  debug(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 4) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"debug\", SeverityNumber.DEBUG, properties);\n  }\n\n  log(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 3) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"log\", SeverityNumber.INFO, properties);\n  }\n\n  info(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 3) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"info\", SeverityNumber.INFO, properties);\n  }\n\n  warn(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 2) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"warn\", SeverityNumber.WARN, properties);\n  }\n\n  error(message: string, properties?: Record<string, unknown>) {\n    if (this._level < 1) return; // [\"none\", \"error\", \"warn\", \"info\", \"debug\"];\n\n    this.#emitLog(message, this.#getTimestampInHrTime(), \"error\", SeverityNumber.ERROR, properties);\n  }\n\n  #emitLog(\n    message: string,\n    timestamp: ClockTime,\n    severityText: string,\n    severityNumber: SeverityNumber,\n    properties?: Record<string, unknown>\n  ) {\n    let attributes: Attributes = { ...flattenAttributes(safeJsonProcess(properties)) };\n\n    const icon = iconStringForSeverity(severityNumber);\n    if (icon !== undefined) {\n      attributes[SemanticInternalAttributes.STYLE_ICON] = icon;\n    }\n\n    this._config.logger.emit({\n      severityNumber,\n      severityText,\n      body: message,\n      attributes,\n      timestamp,\n    });\n  }\n\n  trace<T>(name: string, fn: (span: Span) => Promise<T>, options?: SpanOptions): Promise<T> {\n    return this._config.tracer.startActiveSpan(name, fn, options);\n  }\n\n  #getTimestampInHrTime(): ClockTime {\n    return clock.preciseNow();\n  }\n}\n\nexport class NoopTaskLogger implements TaskLogger {\n  debug() {}\n  log() {}\n  info() {}\n  warn() {}\n  error() {}\n  trace<T>(name: string, fn: (span: Span) => Promise<T>): Promise<T> {\n    return fn({} as Span);\n  }\n}\n\nfunction safeJsonProcess(value?: Record<string, unknown>): Record<string, unknown> | undefined {\n  try {\n    return JSON.parse(JSON.stringify(value, jsonErrorReplacer));\n  } catch {\n    return value;\n  }\n}\n\nfunction jsonErrorReplacer(key: string, value: unknown) {\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: value.message,\n      stack: value.stack,\n    };\n  }\n\n  return value;\n}\n", "import { SeverityNumber } from \"@opentelemetry/api-logs\";\n\nexport function iconStringForSeverity(severityNumber: SeverityNumber) {\n  switch (severityNumber) {\n    case SeverityNumber.UNSPECIFIED:\n      return undefined;\n    case SeverityNumber.TRACE:\n    case SeverityNumber.TRACE2:\n    case SeverityNumber.TRACE3:\n    case SeverityNumber.TRACE4:\n      return \"trace\";\n    case SeverityNumber.DEBUG:\n    case SeverityNumber.DEBUG2:\n    case SeverityNumber.DEBUG3:\n    case SeverityNumber.DEBUG4:\n      return \"debug\";\n    case SeverityNumber.INFO:\n    case SeverityNumber.INFO2:\n    case SeverityNumber.INFO3:\n    case SeverityNumber.INFO4:\n      return \"info\";\n    case SeverityNumber.WARN:\n    case SeverityNumber.WARN2:\n    case SeverityNumber.WARN3:\n    case SeverityNumber.WARN4:\n      return \"warn\";\n    case SeverityNumber.ERROR:\n    case SeverityNumber.ERROR2:\n    case SeverityNumber.ERROR3:\n    case SeverityNumber.ERROR4:\n      return \"error\";\n    case SeverityNumber.FATAL:\n    case SeverityNumber.FATAL2:\n    case SeverityNumber.FATAL3:\n    case SeverityNumber.FATAL4:\n      return \"fatal\";\n  }\n}\n", "import { PreciseDate } from \"@google-cloud/precise-date\";\nimport { Clock } from \"./clock\";\n\nexport class SimpleClock implements Clock {\n  preciseNow(): [number, number] {\n    const now = new PreciseDate();\n    const nowStruct = now.toStruct();\n\n    return [nowStruct.seconds, nowStruct.nanos];\n  }\n\n  reset() {\n    // do nothing\n  }\n}\n", "const API_NAME = \"clock\";\n\nimport { getGlobal, registerGlobal } from \"../utils/globals\";\nimport type { Clock, ClockTime } from \"./clock\";\nimport { SimpleClock } from \"./simpleClock\";\n\nconst SIMPLE_CLOCK = new SimpleClock();\n\nexport class ClockAPI {\n  private static _instance?: ClockAPI;\n\n  private constructor() {}\n\n  public static getInstance(): ClockAPI {\n    if (!this._instance) {\n      this._instance = new ClockAPI();\n    }\n\n    return this._instance;\n  }\n\n  public setGlobalClock(clock: Clock): boolean {\n    return registerGlobal(API_NAME, clock);\n  }\n\n  public preciseNow(): ClockTime {\n    return this.#getClock().preciseNow();\n  }\n\n  public reset(): void {\n    this.#getClock().reset();\n  }\n\n  #getClock(): Clock {\n    return getGlobal(API_NAME) ?? SIMPLE_CLOCK;\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { ClockAPI } from \"./clock\";\n/** Entrypoint for clock API */\nexport const clock = ClockAPI.getInstance();\n", "import type * as logsAPI from \"@opentelemetry/api-logs\";\nimport { SeverityNumber } from \"@opentelemetry/api-logs\";\nimport util from \"node:util\";\nimport { iconStringForSeverity } from \"./icons\";\nimport { SemanticInternalAttributes } from \"./semanticInternalAttributes\";\nimport { flattenAttributes } from \"./utils/flattenAttributes\";\nimport { ClockTime } from \"./clock/clock\";\nimport { clock } from \"./clock-api\";\n\nexport class ConsoleInterceptor {\n  constructor(\n    private readonly logger: logsAPI.Logger,\n    private readonly sendToStdIO: boolean\n  ) {}\n\n  // Intercept the console and send logs to the OpenTelemetry logger\n  // during the execution of the callback\n  async intercept<T>(console: Console, callback: () => Promise<T>): Promise<T> {\n    // Save the original console methods\n    const originalConsole = {\n      log: console.log,\n      info: console.info,\n      warn: console.warn,\n      error: console.error,\n      debug: console.debug,\n    };\n\n    // Override the console methods\n    console.log = this.log.bind(this);\n    console.info = this.info.bind(this);\n    console.warn = this.warn.bind(this);\n    console.error = this.error.bind(this);\n    console.debug = this.debug.bind(this);\n\n    try {\n      return await callback();\n    } finally {\n      // Restore the original console methods\n      console.log = originalConsole.log;\n      console.info = originalConsole.info;\n      console.warn = originalConsole.warn;\n      console.error = originalConsole.error;\n      console.debug = originalConsole.debug;\n    }\n  }\n\n  debug(...args: unknown[]): void {\n    this.#handleLog(SeverityNumber.DEBUG, this.#getTimestampInHrTime(), \"Debug\", ...args);\n  }\n\n  log(...args: unknown[]): void {\n    this.#handleLog(SeverityNumber.INFO, this.#getTimestampInHrTime(), \"Log\", ...args);\n  }\n\n  info(...args: unknown[]): void {\n    this.#handleLog(SeverityNumber.INFO, this.#getTimestampInHrTime(), \"Info\", ...args);\n  }\n\n  warn(...args: unknown[]): void {\n    this.#handleLog(SeverityNumber.WARN, this.#getTimestampInHrTime(), \"Warn\", ...args);\n  }\n\n  error(...args: unknown[]): void {\n    this.#handleLog(SeverityNumber.ERROR, this.#getTimestampInHrTime(), \"Error\", ...args);\n  }\n\n  #handleLog(\n    severityNumber: SeverityNumber,\n    timestamp: ClockTime,\n    severityText: string,\n    ...args: unknown[]\n  ): void {\n    const body = util.format(...args);\n\n    if (this.sendToStdIO) {\n      if (severityNumber === SeverityNumber.ERROR) {\n        process.stderr.write(body);\n      } else {\n        process.stdout.write(body);\n      }\n    }\n\n    const parsed = tryParseJSON(body);\n\n    if (parsed.ok) {\n      this.logger.emit({\n        severityNumber,\n        severityText,\n        body: getLogMessage(parsed.value, severityText),\n        attributes: { ...this.#getAttributes(severityNumber), ...flattenAttributes(parsed.value) },\n        timestamp,\n      });\n\n      return;\n    }\n\n    this.logger.emit({\n      severityNumber,\n      severityText,\n      body,\n      attributes: this.#getAttributes(severityNumber),\n      timestamp,\n    });\n  }\n\n  #getTimestampInHrTime(): ClockTime {\n    return clock.preciseNow();\n  }\n\n  #getAttributes(severityNumber: SeverityNumber): logsAPI.LogAttributes {\n    const icon = iconStringForSeverity(severityNumber);\n    let result: logsAPI.LogAttributes = {};\n\n    if (icon !== undefined) {\n      result[SemanticInternalAttributes.STYLE_ICON] = icon;\n    }\n\n    return result;\n  }\n}\n\nfunction getLogMessage(value: Record<string, unknown>, fallback: string): string {\n  if (typeof value[\"message\"] === \"string\") {\n    return value[\"message\"];\n  }\n\n  if (typeof value[\"msg\"] === \"string\") {\n    return value[\"msg\"];\n  }\n\n  if (typeof value[\"body\"] === \"string\") {\n    return value[\"body\"];\n  }\n\n  if (typeof value[\"error\"] === \"string\") {\n    return value[\"error\"];\n  }\n\n  return fallback;\n}\n\nfunction tryParseJSON(\n  value: string\n): { ok: true; value: Record<string, unknown> } | { ok: false; value: string } {\n  try {\n    const parsed = JSON.parse(value);\n\n    if (typeof parsed === \"object\" && parsed !== null && !Array.isArray(parsed)) {\n      return { ok: true, value: parsed };\n    }\n\n    return { ok: false, value };\n  } catch (e) {\n    return { ok: false, value };\n  }\n}\n", "import { TaskFileMetadata, TaskMetadata, TaskMetadataWithFilePath } from \"../schemas\";\nimport { TaskMetadataWithFunctions } from \"../types\";\nimport { TaskCatalog } from \"./catalog\";\n\nexport class StandardTaskCatalog implements TaskCatalog {\n  private _taskMetadata: Map<string, TaskMetadata> = new Map();\n  private _taskFunctions: Map<string, TaskMetadataWithFunctions[\"fns\"]> = new Map();\n  private _taskFileMetadata: Map<string, TaskFileMetadata> = new Map();\n\n  registerTaskMetadata(task: TaskMetadataWithFunctions): void {\n    const { fns, ...metadata } = task;\n\n    this._taskMetadata.set(task.id, metadata);\n    this._taskFunctions.set(task.id, fns);\n  }\n\n  updateTaskMetadata(id: string, updates: Partial<TaskMetadataWithFunctions>): void {\n    const existingMetadata = this._taskMetadata.get(id);\n\n    if (existingMetadata) {\n      this._taskMetadata.set(id, {\n        ...existingMetadata,\n        ...updates,\n      });\n    }\n\n    if (updates.fns) {\n      const existingFunctions = this._taskFunctions.get(id);\n\n      if (existingFunctions) {\n        this._taskFunctions.set(id, {\n          ...existingFunctions,\n          ...updates.fns,\n        });\n      }\n    }\n  }\n\n  registerTaskFileMetadata(id: string, metadata: TaskFileMetadata): void {\n    this._taskFileMetadata.set(id, metadata);\n  }\n\n  // Return all the tasks, without the functions\n  getAllTaskMetadata(): Array<TaskMetadataWithFilePath> {\n    const result: Array<TaskMetadataWithFilePath> = [];\n\n    for (const [id, metadata] of this._taskMetadata) {\n      const fileMetadata = this._taskFileMetadata.get(id);\n\n      if (!fileMetadata) {\n        continue;\n      }\n\n      result.push({\n        ...metadata,\n        ...fileMetadata,\n      });\n    }\n\n    return result;\n  }\n\n  getTaskMetadata(id: string): TaskMetadataWithFilePath | undefined {\n    const metadata = this._taskMetadata.get(id);\n    const fileMetadata = this._taskFileMetadata.get(id);\n\n    if (!metadata || !fileMetadata) {\n      return undefined;\n    }\n\n    return {\n      ...metadata,\n      ...fileMetadata,\n    };\n  }\n\n  getTask(id: string): TaskMetadataWithFunctions | undefined {\n    const metadata = this._taskMetadata.get(id);\n    const fileMetadata = this._taskFileMetadata.get(id);\n    const fns = this._taskFunctions.get(id);\n\n    if (!metadata || !fns || !fileMetadata) {\n      return undefined;\n    }\n\n    return {\n      ...metadata,\n      ...fileMetadata,\n      fns,\n    };\n  }\n\n  taskExists(id: string): boolean {\n    return this._taskMetadata.has(id);\n  }\n\n  disable() {\n    // noop\n  }\n}\n", "import { UsageManager, UsageMeasurement, UsageSample } from \"./types\";\n\nexport class NoopUsageManager implements UsageManager {\n  disable(): void {\n    // Noop\n  }\n\n  start(): UsageMeasurement {\n    return {\n      sample: () => ({ cpuTime: 0, wallTime: 0 }),\n    };\n  }\n\n  stop(measurement: UsageMeasurement): UsageSample {\n    return measurement.sample();\n  }\n\n  pauseAsync<T>(cb: () => Promise<T>): Promise<T> {\n    return cb();\n  }\n\n  sample(): UsageSample | undefined {\n    return undefined;\n  }\n}\n", "const API_NAME = \"usage\";\n\nimport { getGlobal, registerGlobal, unregisterGlobal } from \"../utils/globals\";\nimport type { UsageManager, UsageMeasurement, UsageSample } from \"./types\";\nimport { NoopUsageManager } from \"./noopUsageManager\";\n\nconst NOOP_USAGE_MANAGER = new NoopUsageManager();\n\nexport class UsageAPI implements UsageManager {\n  private static _instance?: UsageAPI;\n\n  private constructor() {}\n\n  public static getInstance(): UsageAPI {\n    if (!this._instance) {\n      this._instance = new UsageAPI();\n    }\n\n    return this._instance;\n  }\n\n  public setGlobalUsageManager(manager: UsageManager): boolean {\n    return registerGlobal(API_NAME, manager);\n  }\n\n  public disable() {\n    this.#getUsageManager().disable();\n    unregisterGlobal(API_NAME);\n  }\n\n  public start(): UsageMeasurement {\n    return this.#getUsageManager().start();\n  }\n\n  public stop(measurement: UsageMeasurement): UsageSample {\n    return this.#getUsageManager().stop(measurement);\n  }\n\n  public pauseAsync<T>(cb: () => Promise<T>): Promise<T> {\n    return this.#getUsageManager().pauseAsync(cb);\n  }\n\n  public sample(): UsageSample | undefined {\n    return this.#getUsageManager().sample();\n  }\n\n  #getUsageManager(): UsageManager {\n    return getGlobal(API_NAME) ?? NOOP_USAGE_MANAGER;\n  }\n}\n", "// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { UsageAPI } from \"./usage/api\";\n/** Entrypoint for usage API */\nexport const usage = UsageAPI.getInstance();\n", "/**\n * Contains two parts: the first part is the seconds, the second part is the nanoseconds.\n *\n */\nexport type ClockTime = [number, number];\n\nexport interface Clock {\n  preciseNow(): ClockTime;\n  reset(): void;\n}\n\nexport function calculateDurationInMs(start: ClockTime, end: ClockTime): number {\n  const [startSeconds, startNanoseconds] = start;\n  const [endSeconds, endNanoseconds] = end;\n\n  const seconds = endSeconds - startSeconds;\n  const nanoseconds = endNanoseconds - startNanoseconds;\n\n  return Math.floor(seconds * 1000 + nanoseconds / 1000000);\n}\n", "import { UsageManager, UsageMeasurement, UsageSample } from \"./types\";\nimport { clock } from \"../clock-api\";\nimport { ClockTime, calculateDurationInMs } from \"../clock/clock\";\n\nclass DevUsageMeasurement implements UsageMeasurement {\n  private _pauses: Map<string, { start: ClockTime; end?: ClockTime }> = new Map();\n  private _endedAt: ClockTime | undefined;\n\n  constructor(\n    public readonly id: string,\n    private startedAt: ClockTime = clock.preciseNow()\n  ) {}\n\n  stop() {\n    this._endedAt = clock.preciseNow();\n  }\n\n  sample(): UsageSample {\n    const endedAt = this._endedAt ?? clock.preciseNow();\n\n    const wallTime = this.startedAt ? calculateDurationInMs(this.startedAt, endedAt) : 0;\n\n    if (wallTime === 0) {\n      return { cpuTime: 0, wallTime: 0 };\n    }\n\n    const totalPauses = Array.from(this._pauses.values()).reduce((total, pause) => {\n      return total + calculateDurationInMs(pause.start, pause.end ?? endedAt);\n    }, 0);\n\n    const cpuTime = wallTime - totalPauses;\n\n    return {\n      wallTime,\n      cpuTime,\n    };\n  }\n\n  registerPause(pauseId: string, start: ClockTime, end?: ClockTime) {\n    this._pauses.set(pauseId, { start, end });\n  }\n}\n\nexport class DevUsageManager implements UsageManager {\n  private _firstMeasurement?: DevUsageMeasurement;\n  private _currentMeasurements: Map<string, DevUsageMeasurement> = new Map();\n  private _pauses: Map<string, { start: ClockTime; end?: ClockTime }> = new Map();\n\n  disable(): void {}\n\n  sample(): UsageSample | undefined {\n    return this._firstMeasurement?.sample();\n  }\n\n  start(): DevUsageMeasurement {\n    // generate a random ID\n    const id = generateRandomString();\n\n    const measurement = new DevUsageMeasurement(id);\n\n    if (!this._firstMeasurement) {\n      this._firstMeasurement = measurement;\n    }\n\n    this._currentMeasurements.set(id, measurement);\n\n    return measurement;\n  }\n\n  stop(measurement: DevUsageMeasurement): UsageSample {\n    measurement.stop();\n\n    const sample = measurement.sample();\n\n    this._currentMeasurements.delete(measurement.id);\n\n    return sample;\n  }\n\n  async pauseAsync<T>(cb: () => Promise<T>): Promise<T> {\n    const pauseId = generateRandomString();\n\n    const pauseStart = clock.preciseNow();\n\n    try {\n      this._pauses.set(pauseId, { start: pauseStart });\n\n      for (const measurement of this._currentMeasurements.values()) {\n        measurement.registerPause(pauseId, pauseStart);\n      }\n\n      return await cb();\n    } finally {\n      const pauseEnd = clock.preciseNow();\n\n      this._pauses.set(pauseId, { start: pauseStart, end: pauseEnd });\n\n      for (const measurement of this._currentMeasurements.values()) {\n        measurement.registerPause(pauseId, pauseStart, pauseEnd);\n      }\n    }\n  }\n}\n\nfunction generateRandomString() {\n  let result = \"\";\n  const characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const charactersLength = characters.length;\n\n  for (var i = 0; i < 16; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n\n  return result;\n}\n", "import { setInterval } from \"node:timers/promises\";\nimport { UsageManager, UsageMeasurement, UsageSample } from \"./types\";\nimport { UsageClient } from \"./usageClient\";\n\nexport type ProdUsageManagerOptions = {\n  heartbeatIntervalMs?: number;\n  url?: string;\n  jwt?: string;\n};\n\nexport class ProdUsageManager implements UsageManager {\n  private _measurement: UsageMeasurement | undefined;\n  private _abortController: AbortController | undefined;\n  private _lastSample: UsageSample | undefined;\n  private _usageClient: UsageClient | undefined;\n\n  constructor(\n    private readonly delegageUsageManager: UsageManager,\n    private readonly options: ProdUsageManagerOptions\n  ) {\n    if (this.options.url && this.options.jwt) {\n      this._usageClient = new UsageClient(this.options.url, this.options.jwt);\n    }\n  }\n\n  get isReportingEnabled() {\n    return typeof this._usageClient !== \"undefined\";\n  }\n\n  disable(): void {\n    this.delegageUsageManager.disable();\n    this._abortController?.abort();\n  }\n\n  sample(): UsageSample | undefined {\n    return this._measurement?.sample();\n  }\n\n  start(): UsageMeasurement {\n    if (!this.isReportingEnabled || !this.options.heartbeatIntervalMs) {\n      return this.delegageUsageManager.start();\n    }\n\n    if (!this._measurement) {\n      this._measurement = this.delegageUsageManager.start();\n\n      this.#startReportingHeartbeat().catch(console.error);\n\n      return this._measurement;\n    }\n\n    return this.delegageUsageManager.start();\n  }\n\n  stop(measurement: UsageMeasurement): UsageSample {\n    return this.delegageUsageManager.stop(measurement);\n  }\n\n  async pauseAsync<T>(cb: () => Promise<T>): Promise<T> {\n    return this.delegageUsageManager.pauseAsync(cb);\n  }\n\n  async #startReportingHeartbeat() {\n    if (!this._measurement || !this.isReportingEnabled || !this.options.heartbeatIntervalMs) {\n      return;\n    }\n\n    this._abortController = new AbortController();\n\n    for await (const _ of setInterval(this.options.heartbeatIntervalMs)) {\n      if (this._abortController.signal.aborted) {\n        break;\n      }\n\n      await this.#reportUsage();\n    }\n  }\n\n  async flush() {\n    return await this.#reportUsage();\n  }\n\n  async #reportUsage() {\n    if (!this._measurement) {\n      return;\n    }\n\n    if (!this.isReportingEnabled) {\n      return;\n    }\n\n    const client = this._usageClient;\n\n    if (!client) {\n      return;\n    }\n\n    const sample = this._measurement.sample();\n\n    const cpuTimeSinceLastSample = this._lastSample\n      ? sample.cpuTime - this._lastSample.cpuTime\n      : sample.cpuTime;\n\n    this._lastSample = sample;\n\n    if (cpuTimeSinceLastSample <= 0) {\n      return;\n    }\n\n    await client.sendUsageEvent({ durationMs: cpuTimeSinceLastSample });\n  }\n}\n", "import { apiClientManager } from \"../apiClientManager-api\";\n\nexport type UsageClientOptions = {\n  token: string;\n  baseUrl: string;\n};\n\nexport type UsageEvent = {\n  durationMs: number;\n};\n\nexport class UsageClient {\n  constructor(\n    private readonly url: string,\n    private jwt: string\n  ) {}\n\n  async sendUsageEvent(event: UsageEvent): Promise<void> {\n    try {\n      const response = await fetch(this.url, {\n        method: \"POST\",\n        body: JSON.stringify(event),\n        headers: {\n          \"content-type\": \"application/json\",\n          \"x-trigger-jwt\": this.jwt,\n          accept: \"application/json\",\n          authorization: `Bearer ${apiClientManager.accessToken}`, // this is used to renew the JWT\n        },\n      });\n\n      if (response.ok) {\n        const renewedJwt = response.headers.get(\"x-trigger-jwt\");\n\n        if (renewedJwt) {\n          this.jwt = renewedJwt;\n        }\n      }\n    } catch (error) {\n      console.error(`Failed to send usage event: ${error}`);\n    }\n  }\n}\n", "import { setInterval, setTimeout } from \"node:timers/promises\";\n\nexport async function unboundedTimeout<T = void>(\n  delay: number = 0,\n  value?: T,\n  options?: Parameters<typeof setTimeout>[2]\n): Promise<T> {\n  const maxDelay = 2147483647; // Highest value that will fit in a 32-bit signed integer\n\n  const fullTimeouts = Math.floor(delay / maxDelay);\n  const remainingDelay = delay % maxDelay;\n\n  let lastTimeoutResult = await setTimeout(remainingDelay, value, options);\n\n  for (let i = 0; i < fullTimeouts; i++) {\n    lastTimeoutResult = await setTimeout(maxDelay, value, options);\n  }\n\n  return lastTimeoutResult;\n}\n\nexport async function checkpointSafeTimeout(delay: number = 0): Promise<void> {\n  const scanIntervalMs = 1000;\n\n  // Every scanIntervalMs, check if delay has elapsed\n  for await (const start of setInterval(scanIntervalMs, Date.now())) {\n    if (Date.now() - start > delay) {\n      break;\n    }\n  }\n}\n", "import {\n  BatchTaskRunExecutionResult,\n  TaskRunContext,\n  TaskRunExecution,\n  TaskRunExecutionResult,\n} from \"../schemas\";\nimport { RuntimeManager } from \"./manager\";\nimport { unboundedTimeout } from \"../utils/timers\";\n\nexport class DevRuntimeManager implements RuntimeManager {\n  _taskWaits: Map<string, { resolve: (value: TaskRunExecutionResult) => void }> = new Map();\n\n  _batchWaits: Map<\n    string,\n    { resolve: (value: BatchTaskRunExecutionResult) => void; reject: (err?: any) => void }\n  > = new Map();\n\n  _pendingCompletionNotifications: Map<string, TaskRunExecutionResult> = new Map();\n\n  disable(): void {\n    // do nothing\n  }\n\n  async waitForDuration(ms: number): Promise<void> {\n    await unboundedTimeout(ms);\n  }\n\n  async waitUntil(date: Date): Promise<void> {\n    return this.waitForDuration(date.getTime() - Date.now());\n  }\n\n  async waitForTask(params: { id: string; ctx: TaskRunContext }): Promise<TaskRunExecutionResult> {\n    const pendingCompletion = this._pendingCompletionNotifications.get(params.id);\n\n    if (pendingCompletion) {\n      this._pendingCompletionNotifications.delete(params.id);\n\n      return pendingCompletion;\n    }\n\n    const promise = new Promise<TaskRunExecutionResult>((resolve) => {\n      this._taskWaits.set(params.id, { resolve });\n    });\n\n    return await promise;\n  }\n\n  async waitForBatch(params: {\n    id: string;\n    runs: string[];\n    ctx: TaskRunContext;\n  }): Promise<BatchTaskRunExecutionResult> {\n    if (!params.runs.length) {\n      return Promise.resolve({ id: params.id, items: [] });\n    }\n\n    const promise = Promise.all(\n      params.runs.map((runId) => {\n        return new Promise<TaskRunExecutionResult>((resolve, reject) => {\n          const pendingCompletion = this._pendingCompletionNotifications.get(runId);\n\n          if (pendingCompletion) {\n            this._pendingCompletionNotifications.delete(runId);\n\n            resolve(pendingCompletion);\n\n            return;\n          }\n\n          this._taskWaits.set(runId, { resolve });\n        });\n      })\n    );\n\n    const results = await promise;\n\n    return {\n      id: params.id,\n      items: results,\n    };\n  }\n\n  resumeTask(completion: TaskRunExecutionResult, runId: string): void {\n    const wait = this._taskWaits.get(runId);\n\n    if (!wait) {\n      // We need to store the completion in case the task is awaited later\n      this._pendingCompletionNotifications.set(runId, completion);\n\n      return;\n    }\n\n    wait.resolve(completion);\n\n    this._taskWaits.delete(runId);\n  }\n}\n", "import { z } from \"zod\";\nimport { StructuredLogger } from \"./utils/structuredLogger\";\n\nexport class ZodSchemaParsedError extends Error {\n  constructor(\n    public error: z.ZodError,\n    public payload: unknown\n  ) {\n    super(error.message);\n  }\n}\n\nexport type ZodMessageValueSchema<TDiscriminatedUnion extends z.ZodDiscriminatedUnion<any, any>> =\n  | z.ZodFirstPartySchemaTypes\n  | TDiscriminatedUnion;\n\nexport interface ZodMessageCatalogSchema {\n  [key: string]: ZodMessageValueSchema<any>;\n}\n\nexport type ZodMessageHandlers<TCatalogSchema extends ZodMessageCatalogSchema> = Partial<{\n  [K in keyof TCatalogSchema]: (payload: z.infer<TCatalogSchema[K]>) => Promise<any>;\n}>;\n\nexport type ZodMessageHandlerOptions<TMessageCatalog extends ZodMessageCatalogSchema> = {\n  schema: TMessageCatalog;\n  messages?: ZodMessageHandlers<TMessageCatalog>;\n  logger?: StructuredLogger;\n};\n\nexport type MessageFromSchema<\n  K extends keyof TMessageCatalog,\n  TMessageCatalog extends ZodMessageCatalogSchema,\n> = {\n  type: K;\n  payload: z.input<TMessageCatalog[K]>;\n};\n\nexport type MessageFromCatalog<TMessageCatalog extends ZodMessageCatalogSchema> = {\n  [K in keyof TMessageCatalog]: MessageFromSchema<K, TMessageCatalog>;\n}[keyof TMessageCatalog];\n\nexport const ZodMessageSchema = z.object({\n  version: z.literal(\"v1\").default(\"v1\"),\n  type: z.string(),\n  payload: z.unknown(),\n});\n\nexport interface EventEmitterLike {\n  on(eventName: string | symbol, listener: (...args: any[]) => void): this;\n}\n\nexport class ZodMessageHandler<TMessageCatalog extends ZodMessageCatalogSchema> {\n  #schema: TMessageCatalog;\n  #handlers: ZodMessageHandlers<TMessageCatalog> | undefined;\n  #logger: StructuredLogger | Console;\n\n  constructor(options: ZodMessageHandlerOptions<TMessageCatalog>) {\n    this.#schema = options.schema;\n    this.#handlers = options.messages;\n    this.#logger = options.logger ?? console;\n  }\n\n  public async handleMessage(message: unknown): Promise<\n    | {\n        success: true;\n        data: unknown;\n      }\n    | {\n        success: false;\n        error: string;\n      }\n  > {\n    const parsedMessage = this.parseMessage(message);\n\n    if (!parsedMessage.success) {\n      this.#logger.error(parsedMessage.error, { message });\n\n      return {\n        success: false,\n        error: parsedMessage.error,\n      };\n    }\n\n    if (!this.#handlers) {\n      this.#logger.error(\"No handlers provided\", { message });\n\n      return {\n        success: false,\n        error: \"No handlers provided\",\n      };\n    }\n\n    const handler = this.#handlers[parsedMessage.data.type];\n\n    if (!handler) {\n      const error = `No handler for message type: ${String(parsedMessage.data.type)}`;\n\n      this.#logger.error(error, { message });\n\n      return {\n        success: false,\n        error,\n      };\n    }\n\n    const ack = await handler(parsedMessage.data.payload);\n\n    return {\n      success: true,\n      data: ack,\n    };\n  }\n\n  public parseMessage(message: unknown):\n    | {\n        success: true;\n        data: MessageFromCatalog<TMessageCatalog>;\n      }\n    | {\n        success: false;\n        error: string;\n      } {\n    const parsedMessage = ZodMessageSchema.safeParse(message);\n\n    if (!parsedMessage.success) {\n      return {\n        success: false,\n        error: `Failed to parse message: ${JSON.stringify(parsedMessage.error)}`,\n      };\n    }\n\n    const schema = this.#schema[parsedMessage.data.type];\n\n    if (!schema) {\n      return {\n        success: false,\n        error: `Unknown message type: ${parsedMessage.data.type}`,\n      };\n    }\n\n    const parsedPayload = schema.safeParse(parsedMessage.data.payload);\n\n    if (!parsedPayload.success) {\n      return {\n        success: false,\n        error: `Failed to parse message payload: ${JSON.stringify(parsedPayload.error)}`,\n      };\n    }\n\n    return {\n      success: true,\n      data: {\n        type: parsedMessage.data.type,\n        payload: parsedPayload.data,\n      },\n    };\n  }\n\n  public registerHandlers(emitter: EventEmitterLike, logger?: StructuredLogger) {\n    const log = logger ?? console;\n\n    if (!this.#handlers) {\n      log.info(\"No handlers provided\");\n      return;\n    }\n\n    for (const eventName of Object.keys(this.#schema)) {\n      emitter.on(eventName, async (message: any, callback?: any): Promise<void> => {\n        log.info(`handling ${eventName}`, {\n          payload: message,\n          hasCallback: !!callback,\n        });\n\n        let ack: Awaited<ReturnType<ZodMessageHandler<TMessageCatalog>[\"handleMessage\"]>>;\n\n        // FIXME: this only works if the message doesn't have genuine payload prop\n        if (\"payload\" in message) {\n          ack = await this.handleMessage({ type: eventName, ...message });\n        } else {\n          // Handle messages not sent by ZodMessageSender\n          const { version, ...payload } = message;\n          ack = await this.handleMessage({ type: eventName, version, payload });\n        }\n\n        if (callback && typeof callback === \"function\") {\n          if (!ack.success) {\n            // We don't know the callback type, so we can't do anything else - not all callbacks may accept a success prop\n            log.error(\"Failed to handle message, skipping callback\", { message, error: ack.error });\n            return;\n          }\n\n          callback(ack.data);\n        }\n      });\n    }\n  }\n}\n\ntype ZodMessageSenderCallback<TMessageCatalog extends ZodMessageCatalogSchema> = (message: {\n  type: keyof TMessageCatalog;\n  payload: z.infer<TMessageCatalog[keyof TMessageCatalog]>;\n  version: \"v1\";\n}) => Promise<void>;\n\nexport type ZodMessageSenderOptions<TMessageCatalog extends ZodMessageCatalogSchema> = {\n  schema: TMessageCatalog;\n  sender: ZodMessageSenderCallback<TMessageCatalog>;\n};\n\nexport class ZodMessageSender<TMessageCatalog extends ZodMessageCatalogSchema> {\n  #schema: TMessageCatalog;\n  #sender: ZodMessageSenderCallback<TMessageCatalog>;\n\n  constructor(options: ZodMessageSenderOptions<TMessageCatalog>) {\n    this.#schema = options.schema;\n    this.#sender = options.sender;\n  }\n\n  public async send<K extends keyof TMessageCatalog>(\n    type: K,\n    payload: z.input<TMessageCatalog[K]>\n  ) {\n    const schema = this.#schema[type];\n\n    if (!schema) {\n      throw new Error(`Unknown message type: ${type as string}`);\n    }\n\n    const parsedPayload = schema.safeParse(payload);\n\n    if (!parsedPayload.success) {\n      throw new ZodSchemaParsedError(parsedPayload.error, payload);\n    }\n\n    try {\n      await this.#sender({ type, payload, version: \"v1\" });\n    } catch (error) {\n      console.error(\"[ZodMessageSender] Failed to send message\", error);\n    }\n  }\n\n  public async forwardMessage(message: unknown) {\n    const parsedMessage = ZodMessageSchema.safeParse(message);\n\n    if (!parsedMessage.success) {\n      throw new Error(`Failed to parse message: ${JSON.stringify(parsedMessage.error)}`);\n    }\n\n    const schema = this.#schema[parsedMessage.data.type];\n\n    if (!schema) {\n      throw new Error(`Unknown message type: ${parsedMessage.data.type}`);\n    }\n\n    const parsedPayload = schema.safeParse(parsedMessage.data.payload);\n\n    if (!parsedPayload.success) {\n      throw new Error(`Failed to parse message payload: ${JSON.stringify(parsedPayload.error)}`);\n    }\n\n    try {\n      await this.#sender({\n        type: parsedMessage.data.type,\n        payload: parsedPayload.data,\n        version: \"v1\",\n      });\n    } catch (error) {\n      console.error(\"[ZodMessageSender] Failed to forward message\", error);\n    }\n  }\n}\n\nexport type MessageCatalogToSocketIoEvents<TCatalog extends ZodMessageCatalogSchema> = {\n  [K in keyof TCatalog]: (message: z.infer<TCatalog[K]>) => void;\n};\n", "// src/workers/dev/worker-facade.ts\nimport {\n  clock,\n  taskCatalog\n} from \"@trigger.dev/core/v3\";\nimport {\n  TaskExecutor,\n  DurableClock,\n  getEnvVar,\n  logLevels,\n  OtelTaskLogger,\n  ConsoleInterceptor,\n  usage,\n  DevUsageManager\n} from \"@trigger.dev/core/v3/workers\";\nimport {\n  TaskRunErrorCodes,\n  TriggerTracer,\n  logger,\n  runtime,\n  workerToChildMessages\n} from \"@trigger.dev/core/v3\";\nimport { DevRuntimeManager } from \"@trigger.dev/core/v3/dev\";\nimport {\n  ZodMessageHandler,\n  ZodSchemaParsedError\n} from \"@trigger.dev/core/v3/zodMessageHandler\";\nimport { tracingSDK, otelTracer, otelLogger, sender } from \"/Users/leonelribeiro/.npm/_npx/615bebf0b780b73f/node_modules/trigger.dev/dist/workers/dev/worker-setup.js\";;\nimport * as importedConfigExports from \"/Users/leonelribeiro/Documents/GitHub/TodoistIntegration/trigger.config.ts\"; const importedConfig = importedConfigExports.config; const handleError = importedConfigExports.handleError;;\nvar durableClock = new DurableClock();\nclock.setGlobalClock(durableClock);\nusage.setGlobalUsageManager(new DevUsageManager());\nvar tracer = new TriggerTracer({ tracer: otelTracer, logger: otelLogger });\nvar consoleInterceptor = new ConsoleInterceptor(\n  otelLogger,\n  typeof __PROJECT_CONFIG__.enableConsoleLogging === \"boolean\" ? __PROJECT_CONFIG__.enableConsoleLogging : true\n);\nvar devRuntimeManager = new DevRuntimeManager();\nruntime.setGlobalRuntimeManager(devRuntimeManager);\nvar triggerLogLevel = getEnvVar(\"TRIGGER_LOG_LEVEL\");\nvar configLogLevel = triggerLogLevel ? triggerLogLevel : importedConfig ? importedConfig.logLevel : __PROJECT_CONFIG__.logLevel;\nvar otelTaskLogger = new OtelTaskLogger({\n  logger: otelLogger,\n  tracer,\n  level: logLevels.includes(configLogLevel) ? configLogLevel : \"info\"\n});\nlogger.setGlobalTaskLogger(otelTaskLogger);\nvar TaskFileImports = {};\nvar TaskFiles = {};\nimport * as src_trigger_todoist from \"./src/trigger/todoist.ts\"; TaskFileImports[\"src_trigger_todoist\"] = src_trigger_todoist; TaskFiles[\"src_trigger_todoist\"] = {\"triggerDir\":\"/Users/leonelribeiro/Documents/GitHub/TodoistIntegration/src/trigger\",\"importPath\":\"src/trigger/todoist.ts\",\"importName\":\"src_trigger_todoist\",\"filePath\":\"src/trigger/todoist.ts\"};;\n(() => {\n  for (const [importName, taskFile] of Object.entries(TaskFiles)) {\n    const fileImports = TaskFileImports[importName];\n    for (const [exportName, task] of Object.entries(fileImports ?? {})) {\n      if (typeof task === \"object\" && task !== null && \"id\" in task && typeof task.id === \"string\") {\n        if (taskCatalog.taskExists(task.id)) {\n          taskCatalog.registerTaskFileMetadata(task.id, {\n            exportName,\n            filePath: taskFile.filePath\n          });\n        }\n      }\n    }\n  }\n})();\nvar _execution;\nvar _isRunning = false;\nvar handler = new ZodMessageHandler({\n  schema: workerToChildMessages,\n  messages: {\n    EXECUTE_TASK_RUN: async ({ execution, traceContext, metadata }) => {\n      if (_isRunning) {\n        console.error(\"Worker is already running a task\");\n        await sender.send(\"TASK_RUN_COMPLETED\", {\n          execution,\n          result: {\n            ok: false,\n            id: execution.run.id,\n            error: {\n              type: \"INTERNAL_ERROR\",\n              code: TaskRunErrorCodes.TASK_ALREADY_RUNNING\n            },\n            usage: {\n              durationMs: 0\n            }\n          }\n        });\n        return;\n      }\n      process.title = `trigger-dev-worker: ${execution.task.id} ${execution.run.id}`;\n      const task = taskCatalog.getTask(execution.task.id);\n      if (!task) {\n        console.error(`Could not find task ${execution.task.id}`);\n        await sender.send(\"TASK_RUN_COMPLETED\", {\n          execution,\n          result: {\n            ok: false,\n            id: execution.run.id,\n            error: {\n              type: \"INTERNAL_ERROR\",\n              code: TaskRunErrorCodes.COULD_NOT_FIND_EXECUTOR\n            },\n            usage: {\n              durationMs: 0\n            }\n          }\n        });\n        return;\n      }\n      const executor = new TaskExecutor(task, {\n        tracer,\n        tracingSDK,\n        consoleInterceptor,\n        projectConfig: __PROJECT_CONFIG__,\n        importedConfig,\n        handleErrorFn: handleError\n      });\n      try {\n        _execution = execution;\n        _isRunning = true;\n        const measurement = usage.start();\n        const { result } = await executor.execute(execution, metadata, traceContext, measurement);\n        const usageSample = usage.stop(measurement);\n        return sender.send(\"TASK_RUN_COMPLETED\", {\n          execution,\n          result: {\n            ...result,\n            usage: {\n              durationMs: usageSample.cpuTime\n            }\n          }\n        });\n      } finally {\n        _execution = void 0;\n        _isRunning = false;\n      }\n    },\n    TASK_RUN_COMPLETED_NOTIFICATION: async (payload) => {\n      switch (payload.version) {\n        case \"v1\": {\n          devRuntimeManager.resumeTask(payload.completion, payload.execution.run.id);\n          break;\n        }\n        case \"v2\": {\n          devRuntimeManager.resumeTask(payload.completion, payload.completion.id);\n          break;\n        }\n      }\n    },\n    CLEANUP: async ({ flush, kill }) => {\n      if (kill) {\n        await tracingSDK.flush();\n        await sender.send(\"READY_TO_DISPOSE\", void 0);\n      } else {\n        if (flush) {\n          await tracingSDK.flush();\n        }\n      }\n    }\n  }\n});\nprocess.on(\"message\", async (msg) => {\n  await handler.handleMessage(msg);\n});\nvar TASK_METADATA = taskCatalog.getAllTaskMetadata();\nsender.send(\"TASKS_READY\", { tasks: TASK_METADATA }).catch((err) => {\n  if (err instanceof ZodSchemaParsedError) {\n    sender.send(\"TASKS_FAILED_TO_PARSE\", { zodIssues: err.error.issues, tasks: TASK_METADATA });\n  } else {\n    console.error(\"Failed to send TASKS_READY message\", err);\n  }\n});\nprocess.title = \"trigger-dev-worker\";\nasync function asyncHeartbeat(initialDelayInSeconds = 30, intervalInSeconds = 30) {\n  async function _doHeartbeat() {\n    while (true) {\n      if (_isRunning && _execution) {\n        try {\n          await sender.send(\"TASK_HEARTBEAT\", { id: _execution.attempt.id });\n        } catch (err) {\n          console.error(\"Failed to send HEARTBEAT message\", err);\n        }\n      }\n      await new Promise((resolve) => setTimeout(resolve, 1e3 * intervalInSeconds));\n    }\n  }\n  await new Promise((resolve) => setTimeout(resolve, 1e3 * initialDelayInSeconds));\n  return _doHeartbeat();\n}\nasyncHeartbeat().catch((err) => {\n  console.error(\"Failed to start asyncHeartbeat\", err);\n});\n", "// src/workers/dev/worker-setup.ts\nimport { childToWorkerMessages, taskCatalog } from \"@trigger.dev/core/v3\";\nimport {\n  StandardTaskCatalog,\n  TracingSDK\n} from \"@trigger.dev/core/v3/workers\";\nimport { ZodMessageSender } from \"@trigger.dev/core/v3/zodMessageHandler\";\nimport \"source-map-support/register.js\";\n\n// package.json\nvar version = \"3.0.0-beta.56\";\n\n// src/workers/dev/worker-setup.ts\nimport * as setupImportedConfigExports from \"/Users/leonelribeiro/Documents/GitHub/TodoistIntegration/trigger.config.ts\"; const setupImportedConfig = setupImportedConfigExports.config;;\nvar tracingSDK = new TracingSDK({\n  url: process.env.OTEL_EXPORTER_OTLP_ENDPOINT ?? \"http://0.0.0.0:4318\",\n  instrumentations: setupImportedConfig?.instrumentations ?? [],\n  diagLogLevel: process.env.OTEL_LOG_LEVEL ?? \"none\",\n  forceFlushTimeoutMillis: 5e3\n});\nvar otelTracer = tracingSDK.getTracer(\"trigger-dev-worker\", version);\nvar otelLogger = tracingSDK.getLogger(\"trigger-dev-worker\", version);\nvar sender = new ZodMessageSender({\n  schema: childToWorkerMessages,\n  sender: async (message) => {\n    process.send?.(message);\n  }\n});\ntaskCatalog.setGlobalTaskCatalog(new StandardTaskCatalog());\nexport {\n  otelLogger,\n  otelTracer,\n  sender,\n  tracingSDK\n};\n", "import type { TriggerConfig } from \"@trigger.dev/sdk/v3\";\n\nexport const config: TriggerConfig = {\n  project: \"proj_nswxjnjiwnxxnvstnrjf\",\n  logLevel: \"log\",\n  retries: {\n    enabledInDev: true,\n    default: {\n      maxAttempts: 3,\n      minTimeoutInMs: 1000,\n      maxTimeoutInMs: 10000,\n      factor: 2,\n      randomize: true,\n    },\n  },\n};\n", "import { TriggerClient } from \"@trigger.dev/sdk\";\nimport axios from \"axios\";\nimport dotenv from \"dotenv\";\n\ndotenv.config();\n\nconst TODOIST_API_TOKEN = process.env.TODOIST_API_TOKEN;\n\nconst client = new TriggerClient({\n  id: \"todoist-integration\",\n});\n\n// Webhook definition\nclient.defineJob({\n  id: \"todoist-task-handler\",\n  trigger: client.webhooks.onReceive(\"todoist-task-webhook\"),\n  run: async (payload) => {\n    const { action, taskName, taskId } = payload.data;\n\n    if (action === \"add\") {\n      await addTaskToTodoist(taskName);\n    } else if (action === \"complete\") {\n      await completeTodoistTask(taskId);\n    } else {\n      console.log(\"Unknown action\");\n    }\n  },\n});\n\nconst addTaskToTodoist = async (taskName) => {\n  try {\n    const response = await axios.post(\n      \"https://api.todoist.com/rest/v2/tasks\",\n      { content: taskName },\n      { headers: { Authorization: `Bearer ${TODOIST_API_TOKEN}` } }\n    );\n    console.log(\"Task added successfully:\", response.data);\n  } catch (error) {\n    console.error(\"Error adding task:\", error);\n  }\n};\n\nconst completeTodoistTask = async (taskId) => {\n  try {\n    await axios.post(\n      `https://api.todoist.com/rest/v2/tasks/${taskId}/close`,\n      {},\n      { headers: { Authorization: `Bearer ${TODOIST_API_TOKEN}` } }\n    );\n    console.log(\"Task completed successfully:\", taskId);\n  } catch (error) {\n    console.error(\"Error completing task in Todoist:\", error);\n  }\n};\n", "import { ulid } from \"ulidx\";\nimport { z } from \"zod\";\nimport { Prettify } from \"../types\";\nimport { addMissingVersionField } from \"./addMissingVersionField\";\nimport { ErrorWithStackSchema, SchemaErrorSchema } from \"./errors\";\nimport { EventFilterSchema, EventRuleSchema } from \"./eventFilter\";\nimport { ConnectionAuthSchema, IntegrationConfigSchema } from \"./integrations\";\nimport { DeserializedJsonSchema, SerializableJsonSchema } from \"./json\";\nimport { DisplayPropertySchema, StyleSchema } from \"./properties\";\nimport {\n  CronMetadataSchema,\n  IntervalMetadataSchema,\n  RegisterDynamicSchedulePayloadSchema,\n  ScheduleMetadataSchema,\n} from \"./schedules\";\nimport { CachedTaskSchema, ServerTaskSchema, TaskSchema } from \"./tasks\";\nimport { EventSpecificationSchema, TriggerMetadataSchema } from \"./triggers\";\nimport { RunStatusSchema } from \"./runs\";\nimport { JobRunStatusRecordSchema } from \"./statuses\";\nimport { RequestFilterSchema } from \"./requestFilter\";\n\nexport const UpdateTriggerSourceBodyV1Schema = z.object({\n  registeredEvents: z.array(z.string()),\n  secret: z.string().optional(),\n  data: SerializableJsonSchema.optional(),\n});\nexport type UpdateTriggerSourceBodyV1 = z.infer<typeof UpdateTriggerSourceBodyV1Schema>;\n\nexport const UpdateTriggerSourceBodyV2Schema = z.object({\n  secret: z.string().optional(),\n  data: SerializableJsonSchema.optional(),\n  options: z\n    .object({\n      event: z.array(z.string()),\n    })\n    .and(z.record(z.string(), z.array(z.string())).optional()),\n});\nexport type UpdateTriggerSourceBodyV2 = z.infer<typeof UpdateTriggerSourceBodyV2Schema>;\n\nexport const UpdateWebhookBodySchema = z.discriminatedUnion(\"active\", [\n  z.object({\n    active: z.literal(false),\n  }),\n  z.object({\n    active: z.literal(true),\n    config: z.record(z.string().array()),\n  }),\n]);\n\nexport type UpdateWebhookBody = z.infer<typeof UpdateWebhookBodySchema>;\n\nexport const RegisterHTTPTriggerSourceBodySchema = z.object({\n  type: z.literal(\"HTTP\"),\n  url: z.string().url(),\n});\n\nexport const RegisterSMTPTriggerSourceBodySchema = z.object({\n  type: z.literal(\"SMTP\"),\n});\n\nexport const RegisterSQSTriggerSourceBodySchema = z.object({\n  type: z.literal(\"SQS\"),\n});\n\nexport const RegisterSourceChannelBodySchema = z.discriminatedUnion(\"type\", [\n  RegisterHTTPTriggerSourceBodySchema,\n  RegisterSMTPTriggerSourceBodySchema,\n  RegisterSQSTriggerSourceBodySchema,\n]);\n\nexport const REGISTER_WEBHOOK = \"dev.trigger.webhook.register\";\nexport const DELIVER_WEBHOOK_REQUEST = \"dev.trigger.webhook.deliver\";\n\nexport const RegisterWebhookSourceSchema = z.object({\n  key: z.string(),\n  params: z.any(),\n  config: z.any(),\n  active: z.boolean(),\n  secret: z.string(),\n  url: z.string(),\n  data: DeserializedJsonSchema.optional(),\n  clientId: z.string().optional(),\n});\n\nexport type RegisterWebhookSource = z.infer<typeof RegisterWebhookSourceSchema>;\n\nexport const RegisterWebhookPayloadSchema = z.object({\n  active: z.boolean(),\n  params: z.any().optional(),\n  config: z.object({\n    current: z.record(z.string().array()),\n    desired: z.record(z.string().array()),\n  }),\n  // from HTTP Endpoint\n  url: z.string(),\n  secret: z.string(),\n});\n\nexport type RegisterWebhookPayload = z.infer<typeof RegisterWebhookPayloadSchema>;\n\nexport const REGISTER_SOURCE_EVENT_V1 = \"dev.trigger.source.register\";\nexport const REGISTER_SOURCE_EVENT_V2 = \"dev.trigger.source.register.v2\";\n\nexport const RegisterTriggerSourceSchema = z.object({\n  key: z.string(),\n  params: z.any(),\n  active: z.boolean(),\n  secret: z.string(),\n  data: DeserializedJsonSchema.optional(),\n  channel: RegisterSourceChannelBodySchema,\n  clientId: z.string().optional(),\n});\n\nexport type RegisterTriggerSource = z.infer<typeof RegisterTriggerSourceSchema>;\n\nconst SourceEventOptionSchema = z.object({\n  name: z.string(),\n  value: z.string(),\n});\n\nexport type SourceEventOption = z.infer<typeof SourceEventOptionSchema>;\n\nexport const RegisterSourceEventSchemaV1 = z.object({\n  /** The id of the source */\n  id: z.string(),\n  source: RegisterTriggerSourceSchema,\n  events: z.array(z.string()),\n  missingEvents: z.array(z.string()),\n  orphanedEvents: z.array(z.string()),\n  dynamicTriggerId: z.string().optional(),\n});\n\nexport type RegisterSourceEventV1 = z.infer<typeof RegisterSourceEventSchemaV1>;\n\nconst RegisteredOptionsDiffSchema = z.object({\n  desired: z.array(z.string()),\n  missing: z.array(z.string()),\n  orphaned: z.array(z.string()),\n});\n\nexport type RegisteredOptionsDiff = Prettify<z.infer<typeof RegisteredOptionsDiffSchema>>;\n\nconst RegisterSourceEventOptionsSchema = z\n  .object({\n    event: RegisteredOptionsDiffSchema,\n  })\n  .and(z.record(z.string(), RegisteredOptionsDiffSchema));\n\nexport type RegisterSourceEventOptions = z.infer<typeof RegisterSourceEventOptionsSchema>;\n\nexport const RegisterSourceEventSchemaV2 = z.object({\n  /** The id of the source */\n  id: z.string(),\n  source: RegisterTriggerSourceSchema,\n  options: RegisterSourceEventOptionsSchema,\n  dynamicTriggerId: z.string().optional(),\n});\n\nexport type RegisterSourceEventV2 = z.infer<typeof RegisterSourceEventSchemaV2>;\n\nexport const TriggerSourceSchema = z.object({\n  id: z.string(),\n  key: z.string(),\n});\n\nconst HttpSourceResponseMetadataSchema = DeserializedJsonSchema;\nexport type HttpSourceResponseMetadata = z.infer<typeof HttpSourceResponseMetadataSchema>;\n\nexport const HandleTriggerSourceSchema = z.object({\n  key: z.string(),\n  secret: z.string(),\n  data: z.any(),\n  params: z.any(),\n  auth: ConnectionAuthSchema.optional(),\n  metadata: HttpSourceResponseMetadataSchema.optional(),\n});\n\nexport type HandleTriggerSource = z.infer<typeof HandleTriggerSourceSchema>;\n\nexport type TriggerSource = z.infer<typeof TriggerSourceSchema>;\n\nexport const HttpSourceRequestHeadersSchema = z.object({\n  \"x-ts-key\": z.string(),\n  \"x-ts-dynamic-id\": z.string().optional(),\n  \"x-ts-secret\": z.string(),\n  \"x-ts-data\": z.string().transform((s) => JSON.parse(s)),\n  \"x-ts-params\": z.string().transform((s) => JSON.parse(s)),\n  \"x-ts-http-url\": z.string(),\n  \"x-ts-http-method\": z.string(),\n  \"x-ts-http-headers\": z.string().transform((s) => z.record(z.string()).parse(JSON.parse(s))),\n  \"x-ts-auth\": z\n    .string()\n    .optional()\n    .transform((s) => {\n      if (s === undefined) return;\n      const json = JSON.parse(s);\n      return ConnectionAuthSchema.parse(json);\n    }),\n  \"x-ts-metadata\": z\n    .string()\n    .optional()\n    .transform((s) => {\n      if (s === undefined) return;\n      const json = JSON.parse(s);\n      return DeserializedJsonSchema.parse(json);\n    }),\n});\n\nexport type HttpSourceRequestHeaders = z.output<typeof HttpSourceRequestHeadersSchema>;\n\nexport const HttpEndpointRequestHeadersSchema = z.object({\n  \"x-ts-key\": z.string(),\n  \"x-ts-http-url\": z.string(),\n  \"x-ts-http-method\": z.string(),\n  \"x-ts-http-headers\": z.string().transform((s) => z.record(z.string()).parse(JSON.parse(s))),\n});\n\nexport const WebhookSourceRequestHeadersSchema = z.object({\n  \"x-ts-key\": z.string(),\n  \"x-ts-dynamic-id\": z.string().optional(),\n  \"x-ts-secret\": z.string(),\n  \"x-ts-params\": z.string().transform((s) => JSON.parse(s)),\n  \"x-ts-http-url\": z.string(),\n  \"x-ts-http-method\": z.string(),\n  \"x-ts-http-headers\": z.string().transform((s) => z.record(z.string()).parse(JSON.parse(s))),\n});\n\nexport type WebhookSourceRequestHeaders = z.output<typeof WebhookSourceRequestHeadersSchema>;\n\nexport const PongSuccessResponseSchema = z.object({\n  ok: z.literal(true),\n  triggerVersion: z.string().optional(),\n  triggerSdkVersion: z.string().optional(),\n});\n\nexport const PongErrorResponseSchema = z.object({\n  ok: z.literal(false),\n  error: z.string(),\n  triggerVersion: z.string().optional(),\n  triggerSdkVersion: z.string().optional(),\n});\n\nexport const PongResponseSchema = z.discriminatedUnion(\"ok\", [\n  PongSuccessResponseSchema,\n  PongErrorResponseSchema,\n]);\n\nexport type PongResponse = z.infer<typeof PongResponseSchema>;\n\nexport const ValidateSuccessResponseSchema = z.object({\n  ok: z.literal(true),\n  endpointId: z.string(),\n  triggerVersion: z.string().optional(),\n});\n\nexport const ValidateErrorResponseSchema = z.object({\n  ok: z.literal(false),\n  error: z.string(),\n  triggerVersion: z.string().optional(),\n});\n\nexport const ValidateResponseSchema = z.discriminatedUnion(\"ok\", [\n  ValidateSuccessResponseSchema,\n  ValidateErrorResponseSchema,\n]);\n\nexport type ValidateResponse = z.infer<typeof ValidateResponseSchema>;\n\nexport const QueueOptionsSchema = z.object({\n  name: z.string(),\n  maxConcurrent: z.number().optional(),\n});\n\nexport type QueueOptions = z.infer<typeof QueueOptionsSchema>;\n\nexport const ConcurrencyLimitOptionsSchema = z.object({\n  id: z.string(),\n  limit: z.number(),\n});\n\nexport const JobMetadataSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  version: z.string(),\n  event: EventSpecificationSchema,\n  trigger: TriggerMetadataSchema,\n  integrations: z.record(IntegrationConfigSchema),\n  internal: z.boolean().default(false),\n  enabled: z.boolean(),\n  startPosition: z.enum([\"initial\", \"latest\"]),\n  preprocessRuns: z.boolean(),\n  concurrencyLimit: ConcurrencyLimitOptionsSchema.or(z.number().int().positive()).optional(),\n});\n\nexport type JobMetadata = z.infer<typeof JobMetadataSchema>;\n\nconst SourceMetadataV1Schema = z.object({\n  version: z.literal(\"1\"),\n  channel: z.enum([\"HTTP\", \"SQS\", \"SMTP\"]),\n  integration: IntegrationConfigSchema,\n  key: z.string(),\n  params: z.any(),\n  events: z.array(z.string()),\n  registerSourceJob: z\n    .object({\n      id: z.string(),\n      version: z.string(),\n    })\n    .optional(),\n});\n\nexport type SourceMetadataV1 = z.infer<typeof SourceMetadataV1Schema>;\n\nexport const SourceMetadataV2Schema = z.object({\n  version: z.literal(\"2\"),\n  channel: z.enum([\"HTTP\", \"SQS\", \"SMTP\"]),\n  integration: IntegrationConfigSchema,\n  key: z.string(),\n  params: z.any(),\n  options: z.record(z.array(z.string())),\n  registerSourceJob: z\n    .object({\n      id: z.string(),\n      version: z.string(),\n    })\n    .optional(),\n});\n\nexport type SourceMetadataV2 = z.infer<typeof SourceMetadataV2Schema>;\n\nconst SourceMetadataSchema = z.preprocess(\n  addMissingVersionField,\n  z.discriminatedUnion(\"version\", [SourceMetadataV1Schema, SourceMetadataV2Schema])\n);\n\ntype SourceMetadata = Prettify<z.infer<typeof SourceMetadataSchema>>;\n\nexport const WebhookMetadataSchema = z.object({\n  key: z.string(),\n  params: z.any(),\n  config: z.record(z.array(z.string())),\n  integration: IntegrationConfigSchema,\n  httpEndpoint: z.object({\n    id: z.string(),\n  }),\n});\n\nexport type WebhookMetadata = z.infer<typeof WebhookMetadataSchema>;\n\nexport const WebhookContextMetadataSchema = z.object({\n  params: z.any(),\n  config: z.record(z.string().array()),\n  secret: z.string(),\n});\n\nexport type WebhookContextMetadata = z.infer<typeof WebhookContextMetadataSchema>;\n\nexport const DynamicTriggerEndpointMetadataSchema = z.object({\n  id: z.string(),\n  jobs: z.array(JobMetadataSchema.pick({ id: true, version: true })),\n  registerSourceJob: z\n    .object({\n      id: z.string(),\n      version: z.string(),\n    })\n    .optional(),\n});\n\nexport type DynamicTriggerEndpointMetadata = z.infer<typeof DynamicTriggerEndpointMetadataSchema>;\n\nconst HttpEndpointMetadataSchema = z.object({\n  id: z.string(),\n  version: z.string(),\n  enabled: z.boolean(),\n  title: z.string().optional(),\n  icon: z.string().optional(),\n  properties: z.array(DisplayPropertySchema).optional(),\n  event: EventSpecificationSchema,\n  immediateResponseFilter: RequestFilterSchema.optional(),\n  skipTriggeringRuns: z.boolean().optional(),\n  source: z.string(),\n});\n\nexport type HttpEndpointMetadata = z.infer<typeof HttpEndpointMetadataSchema>;\n\nexport const IndexEndpointResponseSchema = z.object({\n  jobs: z.array(JobMetadataSchema),\n  sources: z.array(SourceMetadataSchema),\n  webhooks: z.array(WebhookMetadataSchema).optional(),\n  dynamicTriggers: z.array(DynamicTriggerEndpointMetadataSchema),\n  dynamicSchedules: z.array(RegisterDynamicSchedulePayloadSchema),\n  httpEndpoints: z.array(HttpEndpointMetadataSchema).optional(),\n});\n\nexport type IndexEndpointResponse = z.infer<typeof IndexEndpointResponseSchema>;\n\nexport const EndpointIndexErrorSchema = z.object({\n  message: z.string(),\n  raw: z.any().optional(),\n});\n\nexport type EndpointIndexError = z.infer<typeof EndpointIndexErrorSchema>;\n\nconst IndexEndpointStatsSchema = z.object({\n  jobs: z.number(),\n  sources: z.number(),\n  webhooks: z.number().optional(),\n  dynamicTriggers: z.number(),\n  dynamicSchedules: z.number(),\n  disabledJobs: z.number().default(0),\n  httpEndpoints: z.number().default(0),\n});\n\nexport type IndexEndpointStats = z.infer<typeof IndexEndpointStatsSchema>;\n\nexport function parseEndpointIndexStats(stats: unknown): IndexEndpointStats | undefined {\n  if (stats === null || stats === undefined) {\n    return;\n  }\n  return IndexEndpointStatsSchema.parse(stats);\n}\n\nexport const GetEndpointIndexResponseSchema = z.discriminatedUnion(\"status\", [\n  z.object({\n    status: z.literal(\"PENDING\"),\n    updatedAt: z.coerce.date(),\n  }),\n  z.object({\n    status: z.literal(\"STARTED\"),\n    updatedAt: z.coerce.date(),\n  }),\n  z.object({\n    status: z.literal(\"SUCCESS\"),\n    stats: IndexEndpointStatsSchema,\n    updatedAt: z.coerce.date(),\n  }),\n  z.object({\n    status: z.literal(\"FAILURE\"),\n    error: EndpointIndexErrorSchema,\n    updatedAt: z.coerce.date(),\n  }),\n]);\n\nexport type GetEndpointIndexResponse = z.infer<typeof GetEndpointIndexResponseSchema>;\n\nexport const EndpointHeadersSchema = z.object({\n  \"trigger-version\": z.string().optional(),\n  \"trigger-sdk-version\": z.string().optional(),\n});\n\nexport const ExecuteJobRunMetadataSchema = z.object({\n  successSubscription: z.boolean().optional(),\n  failedSubscription: z.boolean().optional(),\n});\n\nexport const ExecuteJobHeadersSchema = EndpointHeadersSchema.extend({\n  \"x-trigger-run-metadata\": z\n    .preprocess((val) => typeof val === \"string\" && JSON.parse(val), ExecuteJobRunMetadataSchema)\n    .optional(),\n});\n\nexport const RawEventSchema = z.object({\n  /** The `name` property must exactly match any subscriptions you want to\n      trigger. */\n  name: z.string(),\n  /** The `payload` property will be sent to any matching Jobs and will appear\n      as the `payload` param of the `run()` function. You can leave this\n      parameter out if you just want to trigger a Job without any input data. */\n  payload: z.any(),\n  /** The optional `context` property will be sent to any matching Jobs and will\n      be passed through as the `context.event.context` param of the `run()`\n      function. This is optional but can be useful if you want to pass through\n      some additional context to the Job. */\n  context: z.any().optional(),\n  /** The `id` property uniquely identify this particular event. If unset it\n      will be set automatically using `ulid`. */\n  id: z.string().default(() => ulid()),\n  /** This is optional, it defaults to the current timestamp. Usually you would\n      only set this if you have a timestamp that you wish to pass through, e.g.\n      you receive a timestamp from a service and you want the same timestamp to\n      be used in your Job. */\n  timestamp: z.coerce.date().optional(),\n  /** This is optional, it defaults to \"trigger.dev\". It can be useful to set\n      this as you can filter events using this in the `eventTrigger()`. */\n  source: z.string().optional(),\n  /** This is optional, it defaults to \"JSON\". If your event is actually a request,\n      with a url, headers, method and rawBody you can use \"REQUEST\" */\n  payloadType: z.union([z.literal(\"JSON\"), z.literal(\"REQUEST\")]).optional(),\n});\n\nexport type RawEvent = z.infer<typeof RawEventSchema>;\n\n/** The event you wish to send to Trigger a Job */\nexport type SendEvent = z.input<typeof RawEventSchema>;\n\n/** The event that was sent */\nexport const ApiEventLogSchema = z.object({\n  /** The `id` of the event that was sent.\n   */\n  id: z.string(),\n  /** The `name` of the event that was sent. */\n  name: z.string(),\n  /** The `payload` of the event that was sent */\n  payload: DeserializedJsonSchema,\n  /** The `context` of the event that was sent. Is `undefined` if no context was\n      set when sending the event. */\n  context: DeserializedJsonSchema.optional().nullable(),\n  /** The `timestamp` of the event that was sent */\n  timestamp: z.coerce.date(),\n  /** The timestamp when the event will be delivered to any matching Jobs. Is\n      `undefined` if `deliverAt` or `deliverAfter` wasn't set when sending the\n      event. */\n  deliverAt: z.coerce.date().optional().nullable(),\n  /** The timestamp when the event was delivered. Is `undefined` if `deliverAt`\n      or `deliverAfter` were set when sending the event. */\n  deliveredAt: z.coerce.date().optional().nullable(),\n  /** The timestamp when the event was cancelled. Is `undefined` if the event\n   * wasn't cancelled. */\n  cancelledAt: z.coerce.date().optional().nullable(),\n});\n\nexport type ApiEventLog = z.infer<typeof ApiEventLogSchema>;\n\n/** Options to control the delivery of the event */\nexport const SendEventOptionsSchema = z.object({\n  /** An optional Date when you want the event to trigger Jobs. The event will\n      be sent to the platform immediately but won't be acted upon until the\n      specified time. */\n  deliverAt: z.coerce.date().optional(),\n  /** An optional number of seconds you want to wait for the event to trigger\n      any relevant Jobs. The event will be sent to the platform immediately but\n      won't be delivered until after the elapsed number of seconds. */\n  deliverAfter: z.number().int().optional(),\n  /** This optional param will be used by Trigger.dev Connect, which\n      is coming soon. */\n  accountId: z.string().optional(),\n});\n\nexport const SendEventBodySchema = z.object({\n  event: RawEventSchema,\n  options: SendEventOptionsSchema.optional(),\n});\n\nexport const SendBulkEventsBodySchema = z.object({\n  events: RawEventSchema.array(),\n  options: SendEventOptionsSchema.optional(),\n});\n\nexport type SendEventBody = z.infer<typeof SendEventBodySchema>;\nexport type SendEventOptions = z.infer<typeof SendEventOptionsSchema>;\n\nexport const DeliverEventResponseSchema = z.object({\n  deliveredAt: z.string().datetime(),\n});\n\nexport type DeliverEventResponse = z.infer<typeof DeliverEventResponseSchema>;\n\nexport const RuntimeEnvironmentTypeSchema = z.enum([\n  \"PRODUCTION\",\n  \"STAGING\",\n  \"DEVELOPMENT\",\n  \"PREVIEW\",\n]);\n\nexport type RuntimeEnvironmentType = z.infer<typeof RuntimeEnvironmentTypeSchema>;\n\nexport const RunSourceContextSchema = z.object({\n  id: z.string(),\n  metadata: z.any(),\n});\n\nexport type RunSourceContext = z.infer<typeof RunSourceContextSchema>;\n\nexport const AutoYieldConfigSchema = z.object({\n  startTaskThreshold: z.number(),\n  beforeExecuteTaskThreshold: z.number(),\n  beforeCompleteTaskThreshold: z.number(),\n  afterCompleteTaskThreshold: z.number(),\n});\n\nexport type AutoYieldConfig = z.infer<typeof AutoYieldConfigSchema>;\n\nexport const RunJobBodySchema = z.object({\n  event: ApiEventLogSchema,\n  job: z.object({\n    id: z.string(),\n    version: z.string(),\n  }),\n  run: z.object({\n    id: z.string(),\n    isTest: z.boolean(),\n    isRetry: z.boolean().default(false),\n    startedAt: z.coerce.date(),\n  }),\n  environment: z.object({\n    id: z.string(),\n    slug: z.string(),\n    type: RuntimeEnvironmentTypeSchema,\n  }),\n  organization: z.object({\n    id: z.string(),\n    title: z.string(),\n    slug: z.string(),\n  }),\n  project: z\n    .object({\n      id: z.string(),\n      name: z.string(),\n      slug: z.string(),\n    })\n    .optional(),\n  account: z\n    .object({\n      id: z.string(),\n      metadata: z.any(),\n    })\n    .optional(),\n  source: RunSourceContextSchema.optional(),\n  tasks: z.array(CachedTaskSchema).optional(),\n  cachedTaskCursor: z.string().optional(),\n  noopTasksSet: z.string().optional(),\n  connections: z.record(ConnectionAuthSchema).optional(),\n  yieldedExecutions: z.string().array().optional(),\n  runChunkExecutionLimit: z.number().optional(),\n  autoYieldConfig: AutoYieldConfigSchema.optional(),\n});\n\nexport type RunJobBody = z.infer<typeof RunJobBodySchema>;\n\nexport const RunJobErrorSchema = z.object({\n  status: z.literal(\"ERROR\"),\n  error: ErrorWithStackSchema,\n  task: TaskSchema.optional(),\n});\n\nexport type RunJobError = z.infer<typeof RunJobErrorSchema>;\n\nexport const RunJobYieldExecutionErrorSchema = z.object({\n  status: z.literal(\"YIELD_EXECUTION\"),\n  key: z.string(),\n});\n\nexport type RunJobYieldExecutionError = z.infer<typeof RunJobYieldExecutionErrorSchema>;\n\nexport const AutoYieldMetadataSchema = z.object({\n  location: z.string(),\n  timeRemaining: z.number(),\n  timeElapsed: z.number(),\n  limit: z.number().optional(),\n});\n\nexport type AutoYieldMetadata = z.infer<typeof AutoYieldMetadataSchema>;\n\nexport const RunJobAutoYieldExecutionErrorSchema = AutoYieldMetadataSchema.extend({\n  status: z.literal(\"AUTO_YIELD_EXECUTION\"),\n});\n\nexport type RunJobAutoYieldExecutionError = Prettify<\n  z.infer<typeof RunJobAutoYieldExecutionErrorSchema>\n>;\n\nexport const RunJobAutoYieldWithCompletedTaskExecutionErrorSchema = z.object({\n  status: z.literal(\"AUTO_YIELD_EXECUTION_WITH_COMPLETED_TASK\"),\n  id: z.string(),\n  properties: z.array(DisplayPropertySchema).optional(),\n  output: z.string().optional(),\n  data: AutoYieldMetadataSchema,\n});\n\nexport type RunJobAutoYieldWithCompletedTaskExecutionError = z.infer<\n  typeof RunJobAutoYieldWithCompletedTaskExecutionErrorSchema\n>;\n\nexport const RunJobAutoYieldRateLimitErrorSchema = z.object({\n  status: z.literal(\"AUTO_YIELD_RATE_LIMIT\"),\n  reset: z.coerce.number(),\n});\n\nexport type RunJobAutoYieldRateLimitError = z.infer<typeof RunJobAutoYieldRateLimitErrorSchema>;\n\nexport const RunJobInvalidPayloadErrorSchema = z.object({\n  status: z.literal(\"INVALID_PAYLOAD\"),\n  errors: z.array(SchemaErrorSchema),\n});\n\nexport type RunJobInvalidPayloadError = z.infer<typeof RunJobInvalidPayloadErrorSchema>;\n\nexport const RunJobUnresolvedAuthErrorSchema = z.object({\n  status: z.literal(\"UNRESOLVED_AUTH_ERROR\"),\n  issues: z.record(z.object({ id: z.string(), error: z.string() })),\n});\n\nexport type RunJobUnresolvedAuthError = z.infer<typeof RunJobUnresolvedAuthErrorSchema>;\n\nexport const RunJobResumeWithTaskSchema = z.object({\n  status: z.literal(\"RESUME_WITH_TASK\"),\n  task: TaskSchema,\n});\n\nexport type RunJobResumeWithTask = z.infer<typeof RunJobResumeWithTaskSchema>;\n\nexport const RunJobRetryWithTaskSchema = z.object({\n  status: z.literal(\"RETRY_WITH_TASK\"),\n  task: TaskSchema,\n  error: ErrorWithStackSchema,\n  retryAt: z.coerce.date(),\n});\n\nexport type RunJobRetryWithTask = z.infer<typeof RunJobRetryWithTaskSchema>;\n\nexport const RunJobCanceledWithTaskSchema = z.object({\n  status: z.literal(\"CANCELED\"),\n  task: TaskSchema,\n});\n\nexport type RunJobCanceledWithTask = z.infer<typeof RunJobCanceledWithTaskSchema>;\n\nexport const RunJobSuccessSchema = z.object({\n  status: z.literal(\"SUCCESS\"),\n  output: DeserializedJsonSchema.optional(),\n});\n\nexport type RunJobSuccess = z.infer<typeof RunJobSuccessSchema>;\n\nexport const RunJobErrorResponseSchema = z.union([\n  RunJobAutoYieldExecutionErrorSchema,\n  RunJobAutoYieldWithCompletedTaskExecutionErrorSchema,\n  RunJobYieldExecutionErrorSchema,\n  RunJobAutoYieldRateLimitErrorSchema,\n  RunJobErrorSchema,\n  RunJobUnresolvedAuthErrorSchema,\n  RunJobInvalidPayloadErrorSchema,\n  RunJobResumeWithTaskSchema,\n  RunJobRetryWithTaskSchema,\n  RunJobCanceledWithTaskSchema,\n]);\n\nexport type RunJobErrorResponse = z.infer<typeof RunJobErrorResponseSchema>;\n\nexport const RunJobResumeWithParallelTaskSchema = z.object({\n  status: z.literal(\"RESUME_WITH_PARALLEL_TASK\"),\n  task: TaskSchema,\n  childErrors: z.array(RunJobErrorResponseSchema),\n});\n\nexport type RunJobResumeWithParallelTask = z.infer<typeof RunJobResumeWithParallelTaskSchema>;\n\nexport const RunJobResponseSchema = z.discriminatedUnion(\"status\", [\n  RunJobAutoYieldExecutionErrorSchema,\n  RunJobAutoYieldWithCompletedTaskExecutionErrorSchema,\n  RunJobYieldExecutionErrorSchema,\n  RunJobAutoYieldRateLimitErrorSchema,\n  RunJobErrorSchema,\n  RunJobUnresolvedAuthErrorSchema,\n  RunJobInvalidPayloadErrorSchema,\n  RunJobResumeWithTaskSchema,\n  RunJobResumeWithParallelTaskSchema,\n  RunJobRetryWithTaskSchema,\n  RunJobCanceledWithTaskSchema,\n  RunJobSuccessSchema,\n]);\n\nexport type RunJobResponse = z.infer<typeof RunJobResponseSchema>;\n\nexport const PreprocessRunBodySchema = z.object({\n  event: ApiEventLogSchema,\n  job: z.object({\n    id: z.string(),\n    version: z.string(),\n  }),\n  run: z.object({\n    id: z.string(),\n    isTest: z.boolean(),\n  }),\n  environment: z.object({\n    id: z.string(),\n    slug: z.string(),\n    type: RuntimeEnvironmentTypeSchema,\n  }),\n  organization: z.object({\n    id: z.string(),\n    title: z.string(),\n    slug: z.string(),\n  }),\n  account: z\n    .object({\n      id: z.string(),\n      metadata: z.any(),\n    })\n    .optional(),\n});\n\nexport type PreprocessRunBody = z.infer<typeof PreprocessRunBodySchema>;\n\nexport const PreprocessRunResponseSchema = z.object({\n  abort: z.boolean(),\n  properties: z.array(DisplayPropertySchema).optional(),\n});\n\nexport type PreprocessRunResponse = z.infer<typeof PreprocessRunResponseSchema>;\n\nconst CreateRunResponseOkSchema = z.object({\n  ok: z.literal(true),\n  data: z.object({\n    id: z.string(),\n  }),\n});\n\nconst CreateRunResponseErrorSchema = z.object({\n  ok: z.literal(false),\n  error: z.string(),\n});\n\nexport const CreateRunResponseBodySchema = z.discriminatedUnion(\"ok\", [\n  CreateRunResponseOkSchema,\n  CreateRunResponseErrorSchema,\n]);\n\nexport type CreateRunResponseBody = z.infer<typeof CreateRunResponseBodySchema>;\n\nexport const RedactStringSchema = z.object({\n  __redactedString: z.literal(true),\n  strings: z.array(z.string()),\n  interpolations: z.array(z.string()),\n});\n\nexport type RedactString = z.infer<typeof RedactStringSchema>;\n\nexport const LogMessageSchema = z.object({\n  level: z.enum([\"DEBUG\", \"INFO\", \"WARN\", \"ERROR\"]),\n  message: z.string(),\n  data: SerializableJsonSchema.optional(),\n});\n\nexport type LogMessage = z.infer<typeof LogMessageSchema>;\n\nexport type ClientTask = z.infer<typeof TaskSchema>;\nexport type CachedTask = z.infer<typeof CachedTaskSchema>;\n\nexport const RedactSchema = z.object({\n  paths: z.array(z.string()),\n});\n\nexport const RetryOptionsSchema = z.object({\n  /** The maximum number of times to retry the request. */\n  limit: z.number().optional(),\n  /** The exponential factor to use when calculating the next retry time. */\n  factor: z.number().optional(),\n  /** The minimum amount of time to wait before retrying the request. */\n  minTimeoutInMs: z.number().optional(),\n  /** The maximum amount of time to wait before retrying the request. */\n  maxTimeoutInMs: z.number().optional(),\n  /** Whether to randomize the retry time. */\n  randomize: z.boolean().optional(),\n});\n\nexport type RetryOptions = z.infer<typeof RetryOptionsSchema>;\n\nexport const RunTaskOptionsSchema = z.object({\n  /** The name of the Task is required. This is displayed on the Task in the logs. */\n  name: z.string().optional(),\n  /** The Task will wait and only start at the specified Date  */\n  delayUntil: z.coerce.date().optional(),\n  /** Retry options */\n  retry: RetryOptionsSchema.optional(),\n  /** The icon for the Task, it will appear in the logs.\n   *  You can use the name of a company in lowercase, e.g. \"github\".\n   *  Or any icon name that [Tabler Icons](https://tabler-icons.io/) supports. */\n  icon: z.string().optional(),\n  /** The key for the Task that you want to appear in the logs */\n  displayKey: z.string().optional(),\n  /** A description of the Task */\n  description: z.string().optional(),\n  /** Properties that are displayed in the logs */\n  properties: z.array(DisplayPropertySchema).optional(),\n  /** The input params to the Task, will be displayed in the logs  */\n  params: z.any(),\n  /** The style of the log entry. */\n  style: StyleSchema.optional(),\n  /** Allows you to expose a `task.callbackUrl` to use in your tasks. Enabling this feature will cause the task to return the data sent to the callbackUrl instead of the usual async callback result. */\n  callback: z\n    .object({\n      /** Causes the task to wait for and return the data of the first request sent to `task.callbackUrl`. */\n      enabled: z.boolean(),\n      /** Time to wait for the first request to `task.callbackUrl`. Default: One hour. */\n      timeoutInSeconds: z.number(),\n    })\n    .partial()\n    .optional(),\n  /** Allows you to link the Integration connection in the logs. This is handled automatically in integrations.  */\n  connectionKey: z.string().optional(),\n  /** An operation you want to perform on the Trigger.dev platform, current only \"fetch\", \"fetch-response\", and \"fetch-poll\" is supported. If you wish to `fetch` use [`io.backgroundFetch()`](https://trigger.dev/docs/sdk/io/backgroundfetch) instead. */\n  operation: z.enum([\"fetch\", \"fetch-response\", \"fetch-poll\"]).optional(),\n  /** A No Operation means that the code won't be executed. This is used internally to implement features like [io.wait()](https://trigger.dev/docs/sdk/io/wait).  */\n  noop: z.boolean().default(false),\n  redact: RedactSchema.optional(),\n  parallel: z.boolean().optional(),\n});\n\nexport type RunTaskOptions = z.input<typeof RunTaskOptionsSchema>;\n\nexport type OverridableRunTaskOptions = Pick<\n  RunTaskOptions,\n  \"retry\" | \"delayUntil\" | \"description\"\n>;\n\nexport const RunTaskBodyInputSchema = RunTaskOptionsSchema.extend({\n  idempotencyKey: z.string(),\n  parentId: z.string().optional(),\n});\n\nexport type RunTaskBodyInput = z.infer<typeof RunTaskBodyInputSchema>;\n\nexport const RunTaskBodyOutputSchema = RunTaskBodyInputSchema.extend({\n  properties: z.array(DisplayPropertySchema.partial()).optional(),\n  params: DeserializedJsonSchema.optional().nullable(),\n  callback: z\n    .object({\n      enabled: z.boolean(),\n      timeoutInSeconds: z.number().default(3600),\n    })\n    .optional(),\n});\n\nexport type RunTaskBodyOutput = z.infer<typeof RunTaskBodyOutputSchema>;\n\nexport const RunTaskResponseWithCachedTasksBodySchema = z.object({\n  task: ServerTaskSchema,\n  cachedTasks: z\n    .object({\n      tasks: z.array(CachedTaskSchema),\n      cursor: z.string().optional(),\n    })\n    .optional(),\n});\n\nexport type RunTaskResponseWithCachedTasksBody = z.infer<\n  typeof RunTaskResponseWithCachedTasksBodySchema\n>;\n\nexport const CompleteTaskBodyInputSchema = RunTaskBodyInputSchema.pick({\n  properties: true,\n  description: true,\n  params: true,\n}).extend({\n  output: SerializableJsonSchema.optional().transform((v) =>\n    v ? DeserializedJsonSchema.parse(JSON.parse(JSON.stringify(v))) : {}\n  ),\n});\n\nexport type CompleteTaskBodyInput = Prettify<z.input<typeof CompleteTaskBodyInputSchema>>;\nexport type CompleteTaskBodyOutput = z.infer<typeof CompleteTaskBodyInputSchema>;\n\nexport const CompleteTaskBodyV2InputSchema = RunTaskBodyInputSchema.pick({\n  properties: true,\n  description: true,\n  params: true,\n}).extend({\n  output: z.string().optional(),\n});\n\nexport type CompleteTaskBodyV2Input = Prettify<z.input<typeof CompleteTaskBodyV2InputSchema>>;\n\nexport const FailTaskBodyInputSchema = z.object({\n  error: ErrorWithStackSchema,\n});\n\nexport type FailTaskBodyInput = z.infer<typeof FailTaskBodyInputSchema>;\n\nexport const NormalizedRequestSchema = z.object({\n  headers: z.record(z.string()),\n  method: z.string(),\n  query: z.record(z.string()),\n  url: z.string(),\n  body: z.any(),\n});\n\nexport type NormalizedRequest = z.infer<typeof NormalizedRequestSchema>;\n\nexport const NormalizedResponseSchema = z.object({\n  status: z.number(),\n  body: z.any(),\n  headers: z.record(z.string()).optional(),\n});\n\nexport type NormalizedResponse = z.infer<typeof NormalizedResponseSchema>;\n\nexport const HttpSourceResponseSchema = z.object({\n  response: NormalizedResponseSchema,\n  events: z.array(RawEventSchema),\n  metadata: HttpSourceResponseMetadataSchema.optional(),\n});\n\nexport const WebhookDeliveryResponseSchema = z.object({\n  response: NormalizedResponseSchema,\n  verified: z.boolean(),\n  error: z.string().optional(),\n});\n\nexport type WebhookDeliveryResponse = z.infer<typeof WebhookDeliveryResponseSchema>;\n\nexport const RegisterTriggerBodySchemaV1 = z.object({\n  rule: EventRuleSchema,\n  source: SourceMetadataV1Schema,\n});\n\nexport type RegisterTriggerBodyV1 = z.infer<typeof RegisterTriggerBodySchemaV1>;\n\nexport const RegisterTriggerBodySchemaV2 = z.object({\n  rule: EventRuleSchema,\n  source: SourceMetadataV2Schema,\n  accountId: z.string().optional(),\n});\n\nexport type RegisterTriggerBodyV2 = z.infer<typeof RegisterTriggerBodySchemaV2>;\n\nexport const InitializeTriggerBodySchema = z.object({\n  id: z.string(),\n  params: z.any(),\n  accountId: z.string().optional(),\n  metadata: z.any().optional(),\n});\n\nexport type InitializeTriggerBody = z.infer<typeof InitializeTriggerBodySchema>;\n\nconst RegisterCommonScheduleBodySchema = z.object({\n  /** A unique id for the schedule. This is used to identify and unregister the schedule later. */\n  id: z.string(),\n  /** Any additional metadata about the schedule. */\n  metadata: z.any(),\n  /** An optional Account ID to associate with runs triggered by this schedule */\n  accountId: z.string().optional(),\n});\n\nexport const RegisterIntervalScheduleBodySchema =\n  RegisterCommonScheduleBodySchema.merge(IntervalMetadataSchema);\n\nexport type RegisterIntervalScheduleBody = z.infer<typeof RegisterIntervalScheduleBodySchema>;\n\nexport const InitializeCronScheduleBodySchema =\n  RegisterCommonScheduleBodySchema.merge(CronMetadataSchema);\n\nexport type RegisterCronScheduleBody = z.infer<typeof InitializeCronScheduleBodySchema>;\n\nexport const RegisterScheduleBodySchema = z.discriminatedUnion(\"type\", [\n  RegisterIntervalScheduleBodySchema,\n  InitializeCronScheduleBodySchema,\n]);\n\nexport type RegisterScheduleBody = z.infer<typeof RegisterScheduleBodySchema>;\n\nexport const RegisterScheduleResponseBodySchema = z.object({\n  id: z.string(),\n  schedule: ScheduleMetadataSchema,\n  metadata: z.any(),\n  active: z.boolean(),\n});\n\nexport type RegisterScheduleResponseBody = z.infer<typeof RegisterScheduleResponseBodySchema>;\n\nexport const CreateExternalConnectionBodySchema = z.object({\n  accessToken: z.string(),\n  type: z.enum([\"oauth2\"]),\n  scopes: z.array(z.string()).optional(),\n  metadata: z.any(),\n});\n\nexport type CreateExternalConnectionBody = z.infer<typeof CreateExternalConnectionBodySchema>;\n\nexport const GetRunStatusesSchema = z.object({\n  run: z.object({ id: z.string(), status: RunStatusSchema, output: z.any().optional() }),\n  statuses: z.array(JobRunStatusRecordSchema),\n});\nexport type GetRunStatuses = z.infer<typeof GetRunStatusesSchema>;\n\nexport const InvokeJobResponseSchema = z.object({\n  id: z.string(),\n});\n\nexport const InvokeJobRequestBodySchema = z.object({\n  payload: z.any(),\n  context: z.any().optional(),\n  options: z\n    .object({\n      accountId: z.string().optional(),\n      callbackUrl: z.string().optional(),\n    })\n    .optional(),\n});\n\nexport type InvokeJobRequestBody = z.infer<typeof InvokeJobRequestBodySchema>;\n\nexport const InvokeOptionsSchema = z.object({\n  accountId: z.string().optional(),\n  idempotencyKey: z.string().optional(),\n  context: z.any().optional(),\n  callbackUrl: z.string().optional(),\n});\n\nexport type InvokeOptions = z.infer<typeof InvokeOptionsSchema>;\n\nexport const EphemeralEventDispatcherRequestBodySchema = z.object({\n  url: z.string(),\n  name: z.string().or(z.array(z.string())),\n  source: z.string().optional(),\n  filter: EventFilterSchema.optional(),\n  contextFilter: EventFilterSchema.optional(),\n  accountId: z.string().optional(),\n  timeoutInSeconds: z\n    .number()\n    .int()\n    .positive()\n    .min(10)\n    .max(60 * 60 * 24 * 365)\n    .default(3600),\n});\n\nexport type EphemeralEventDispatcherRequestBody = z.infer<\n  typeof EphemeralEventDispatcherRequestBodySchema\n>;\n\nexport const EphemeralEventDispatcherResponseBodySchema = z.object({\n  id: z.string(),\n});\n\nexport type EphemeralEventDispatcherResponseBody = z.infer<\n  typeof EphemeralEventDispatcherResponseBodySchema\n>;\n\nexport const KeyValueStoreResponseBodySchema = z.discriminatedUnion(\"action\", [\n  z.object({\n    action: z.literal(\"DELETE\"),\n    key: z.string(),\n    deleted: z.boolean(),\n  }),\n  z.object({\n    action: z.literal(\"GET\"),\n    key: z.string(),\n    value: z.string().optional(),\n  }),\n  z.object({\n    action: z.literal(\"HAS\"),\n    key: z.string(),\n    has: z.boolean(),\n  }),\n  z.object({\n    action: z.literal(\"SET\"),\n    key: z.string(),\n    value: z.string().optional(),\n  }),\n]);\n\nexport type KeyValueStoreResponseBody = z.infer<typeof KeyValueStoreResponseBodySchema>;\n", "export function addMissingVersionField(val: unknown) {\n  if (val !== null && typeof val === \"object\" && !(\"version\" in val)) {\n    return {\n      ...val,\n      version: \"1\",\n    };\n  }\n  return val;\n}\n", "import { z } from \"zod\";\n\nexport const ErrorWithStackSchema = z.object({\n  message: z.string(),\n  name: z.string().optional(),\n  stack: z.string().optional(),\n});\n\nexport type ErrorWithStack = z.infer<typeof ErrorWithStackSchema>;\n\nexport const SchemaErrorSchema = z.object({\n  path: z.array(z.string()),\n  message: z.string(),\n});\n\nexport type SchemaError = z.infer<typeof SchemaErrorSchema>;\n", "import { z } from \"zod\";\n\nexport const stringPatternMatchers = [\n  z.object({\n    $endsWith: z.string(),\n  }),\n  z.object({\n    $startsWith: z.string(),\n  }),\n  z.object({\n    $ignoreCaseEquals: z.string(),\n  }),\n] as const;\n\nconst EventMatcherSchema = z.union([\n  /** Match against a string */\n  z.array(z.string()),\n  /** Match against a number */\n  z.array(z.number()),\n  /** Match against a boolean */\n  z.array(z.boolean()),\n  z.array(\n    z.union([\n      ...stringPatternMatchers,\n      z.object({\n        $exists: z.boolean(),\n      }),\n      z.object({\n        $isNull: z.boolean(),\n      }),\n      z.object({\n        $anythingBut: z.union([z.string(), z.number(), z.boolean()]),\n      }),\n      z.object({\n        $anythingBut: z.union([z.array(z.string()), z.array(z.number()), z.array(z.boolean())]),\n      }),\n      z.object({\n        $gt: z.number(),\n      }),\n      z.object({\n        $lt: z.number(),\n      }),\n      z.object({\n        $gte: z.number(),\n      }),\n      z.object({\n        $lte: z.number(),\n      }),\n      z.object({\n        $between: z.tuple([z.number(), z.number()]),\n      }),\n      z.object({\n        $includes: z.union([z.string(), z.number(), z.boolean()]),\n      }),\n      z.object({\n        $not: z.union([z.string(), z.number(), z.boolean()])\n      })\n    ])\n  ),\n]);\n\ntype EventMatcher = z.infer<typeof EventMatcherSchema>;\n\n/** A filter for matching against data */\nexport type EventFilter = { [key: string]: EventMatcher | EventFilter };\n\nexport const EventFilterSchema: z.ZodType<EventFilter> = z.lazy(() =>\n  z.record(z.union([EventMatcherSchema, EventFilterSchema]))\n);\n\nexport const EventRuleSchema = z.object({\n  event: z.string().or(z.array(z.string())),\n  source: z.string(),\n  payload: EventFilterSchema.optional(),\n  context: EventFilterSchema.optional(),\n});\n\nexport type EventRule = z.infer<typeof EventRuleSchema>;\n", "import { z } from \"zod\";\n\nexport const ConnectionAuthSchema = z.object({\n  type: z.enum([\"oauth2\", \"apiKey\"]),\n  accessToken: z.string(),\n  scopes: z.array(z.string()).optional(),\n  additionalFields: z.record(z.string()).optional(),\n});\n\nexport type ConnectionAuth = z.infer<typeof ConnectionAuthSchema>;\n\nexport const IntegrationMetadataSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  instructions: z.string().optional(),\n});\n\nexport type IntegrationMetadata = z.infer<typeof IntegrationMetadataSchema>;\n\nexport const IntegrationConfigSchema = z.object({\n  id: z.string(),\n  metadata: IntegrationMetadataSchema,\n  authSource: z.enum([\"HOSTED\", \"LOCAL\", \"RESOLVER\"]),\n});\n\nexport type IntegrationConfig = z.infer<typeof IntegrationConfigSchema>;\n", "import { z } from \"zod\";\n\nconst LiteralSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);\ntype Literal = z.infer<typeof LiteralSchema>;\n\nexport type DeserializedJson = Literal | { [key: string]: DeserializedJson } | DeserializedJson[];\n\nexport const DeserializedJsonSchema: z.ZodType<DeserializedJson> = z.lazy(() =>\n  z.union([LiteralSchema, z.array(DeserializedJsonSchema), z.record(DeserializedJsonSchema)])\n);\n\nconst SerializableSchema = z.union([\n  z.string(),\n  z.number(),\n  z.boolean(),\n  z.null(),\n  z.date(),\n  z.undefined(),\n  z.symbol(),\n]);\ntype Serializable = z.infer<typeof SerializableSchema>;\n\nexport type SerializableJson =\n  | Serializable\n  | { [key: string]: SerializableJson }\n  | SerializableJson[];\n\nexport const SerializableJsonSchema: z.ZodType<SerializableJson> = z.lazy(() =>\n  z.union([SerializableSchema, z.array(SerializableJsonSchema), z.record(SerializableJsonSchema)])\n);\n", "import { z } from \"zod\";\n\n/** A property that is displayed in the logs */\nexport const DisplayPropertySchema = z.object({\n  /** The label for the property */\n  label: z.string(),\n  /** The value of the property */\n  text: z.string(),\n  /** The URL to link to when the property is clicked */\n  url: z.string().optional(),\n  /** The URL to a list of images to display next to the property */\n  imageUrl: z.array(z.string()).optional(),\n});\n\nexport const DisplayPropertiesSchema = z.array(DisplayPropertySchema);\n\nexport type DisplayProperty = z.infer<typeof DisplayPropertySchema>;\n\nexport const StyleSchema = z.object({\n  /** The style, `normal` or `minimal` */\n  style: z.enum([\"normal\", \"minimal\"]),\n  /** A variant of the style. */\n  variant: z.string().optional(),\n});\n\nexport type Style = z.infer<typeof StyleSchema>;\nexport type StyleName = Style[\"style\"];\n", "import { z } from \"zod\";\n\nexport const SCHEDULED_EVENT = \"dev.trigger.scheduled\";\n\nexport const ScheduledPayloadSchema = z.object({\n  ts: z.coerce.date(),\n  lastTimestamp: z.coerce.date().optional(),\n});\n\nexport type ScheduledPayload = z.infer<typeof ScheduledPayloadSchema>;\n\nexport const IntervalOptionsSchema = z.object({\n  /** The number of seconds for the interval. Min = 20, Max = 2_592_000 (30 days) */\n  seconds: z.number().int().positive().min(20).max(2_592_000),\n});\n\n/** Interval options */\nexport type IntervalOptions = z.infer<typeof IntervalOptionsSchema>;\n\nexport const CronOptionsSchema = z.object({\n  /** A CRON expression that defines the schedule. A useful tool when writing CRON\n    expressions is [crontab guru](https://crontab.guru). Note that the timezone\n    used is UTC. */\n  cron: z.string(),\n});\n\n/** The options for a `cronTrigger()` */\nexport type CronOptions = z.infer<typeof CronOptionsSchema>;\n\nexport const CronMetadataSchema = z.object({\n  type: z.literal(\"cron\"),\n  options: CronOptionsSchema,\n  /** An optional Account ID to associate with runs triggered by this interval */\n  accountId: z.string().optional(),\n  metadata: z.any(),\n});\n\nexport type CronMetadata = z.infer<typeof CronMetadataSchema>;\n\nexport const IntervalMetadataSchema = z.object({\n  /** An interval reoccurs at the specified number of seconds  */\n  type: z.literal(\"interval\"),\n  /** An object containing options about the interval. */\n  options: IntervalOptionsSchema,\n  /** An optional Account ID to associate with runs triggered by this interval */\n  accountId: z.string().optional(),\n  /** Any additional metadata about the schedule. */\n  metadata: z.any(),\n});\n\nexport type IntervalMetadata = z.infer<typeof IntervalMetadataSchema>;\n\nexport const ScheduleMetadataSchema = z.discriminatedUnion(\"type\", [\n  IntervalMetadataSchema,\n  CronMetadataSchema,\n]);\n\nexport type ScheduleMetadata = z.infer<typeof ScheduleMetadataSchema>;\n\nexport const RegisterDynamicSchedulePayloadSchema = z.object({\n  id: z.string(),\n  jobs: z.array(\n    z.object({\n      id: z.string(),\n      version: z.string(),\n    })\n  ),\n});\n\nexport type RegisterDynamicSchedulePayload = z.infer<typeof RegisterDynamicSchedulePayloadSchema>;\n", "import { z } from \"zod\";\nimport { DisplayPropertySchema, StyleSchema } from \"./properties\";\nimport { DeserializedJsonSchema } from \"./json\";\n\nexport const TaskStatusSchema = z.enum([\n  \"PENDING\",\n  \"WAITING\",\n  \"RUNNING\",\n  \"COMPLETED\",\n  \"ERRORED\",\n  \"CANCELED\",\n]);\n\nexport type TaskStatus = z.infer<typeof TaskStatusSchema>;\n\nexport const TaskSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  icon: z.string().optional().nullable(),\n  noop: z.boolean(),\n  startedAt: z.coerce.date().optional().nullable(),\n  completedAt: z.coerce.date().optional().nullable(),\n  delayUntil: z.coerce.date().optional().nullable(),\n  status: TaskStatusSchema,\n  description: z.string().optional().nullable(),\n  properties: z.array(DisplayPropertySchema).optional().nullable(),\n  outputProperties: z.array(DisplayPropertySchema).optional().nullable(),\n  params: DeserializedJsonSchema.optional().nullable(),\n  output: DeserializedJsonSchema.optional().nullable(),\n  context: DeserializedJsonSchema.optional().nullable(),\n  error: z.string().optional().nullable(),\n  parentId: z.string().optional().nullable(),\n  style: StyleSchema.optional().nullable(),\n  operation: z.string().optional().nullable(),\n  callbackUrl: z.string().optional().nullable(),\n  childExecutionMode: z.enum([\"SEQUENTIAL\", \"PARALLEL\"]).optional().nullable(),\n});\n\nexport const ServerTaskSchema = TaskSchema.extend({\n  idempotencyKey: z.string(),\n  attempts: z.number(),\n  forceYield: z.boolean().optional().nullable(),\n});\n\nexport type ServerTask = z.infer<typeof ServerTaskSchema>;\n\nexport const CachedTaskSchema = z.object({\n  id: z.string(),\n  idempotencyKey: z.string(),\n  status: TaskStatusSchema,\n  noop: z.boolean().default(false),\n  output: DeserializedJsonSchema.optional().nullable(),\n  parentId: z.string().optional().nullable(),\n});\n", "import { z } from \"zod\";\nimport { EventFilterSchema, EventRuleSchema } from \"./eventFilter\";\nimport { DisplayPropertySchema } from \"./properties\";\nimport { ScheduleMetadataSchema } from \"./schedules\";\n\nexport const EventExampleSchema = z.object({\n  id: z.string(),\n  icon: z.string().optional(),\n  name: z.string(),\n  payload: z.any(),\n});\n\nexport type EventExample = z.infer<typeof EventExampleSchema>;\n\nexport const EventSpecificationSchema = z.object({\n  name: z.string().or(z.array(z.string())),\n  title: z.string(),\n  source: z.string(),\n  icon: z.string(),\n  filter: EventFilterSchema.optional(),\n  properties: z.array(DisplayPropertySchema).optional(),\n  schema: z.any().optional(),\n  examples: z.array(EventExampleSchema).optional(),\n});\n\nexport const DynamicTriggerMetadataSchema = z.object({\n  type: z.literal(\"dynamic\"),\n  id: z.string(),\n});\n\nexport const TriggerHelpSchema = z.object({\n  noRuns: z\n    .object({\n      text: z.string(),\n      link: z.string().optional(),\n    })\n    .optional(),\n});\n\nexport const StaticTriggerMetadataSchema = z.object({\n  type: z.literal(\"static\"),\n  title: z.union([z.string(), z.array(z.string())]),\n  properties: z.array(DisplayPropertySchema).optional(),\n  rule: EventRuleSchema,\n  link: z.string().optional(),\n  help: TriggerHelpSchema.optional(),\n});\n\nexport const InvokeTriggerMetadataSchema = z.object({\n  type: z.literal(\"invoke\"),\n});\n\nexport const ScheduledTriggerMetadataSchema = z.object({\n  type: z.literal(\"scheduled\"),\n  schedule: ScheduleMetadataSchema,\n});\n\nexport const TriggerMetadataSchema = z.discriminatedUnion(\"type\", [\n  DynamicTriggerMetadataSchema,\n  StaticTriggerMetadataSchema,\n  ScheduledTriggerMetadataSchema,\n  InvokeTriggerMetadataSchema,\n]);\n\nexport type TriggerMetadata = z.infer<typeof TriggerMetadataSchema>;\n", "import { z } from \"zod\";\nimport { Prettify } from \"../types\";\nimport { RuntimeEnvironmentType } from \"./api\";\nimport { ErrorWithStack } from \"./errors\";\nimport { JobRunStatusRecord, JobRunStatusRecordSchema } from \"./statuses\";\nimport { TaskStatusSchema } from \"./tasks\";\n\nexport const RunStatusSchema = z.union([\n  z.literal(\"PENDING\"),\n  z.literal(\"QUEUED\"),\n  z.literal(\"WAITING_ON_CONNECTIONS\"),\n  z.literal(\"PREPROCESSING\"),\n  z.literal(\"STARTED\"),\n  z.literal(\"SUCCESS\"),\n  z.literal(\"FAILURE\"),\n  z.literal(\"TIMED_OUT\"),\n  z.literal(\"ABORTED\"),\n  z.literal(\"CANCELED\"),\n  z.literal(\"UNRESOLVED_AUTH\"),\n  z.literal(\"INVALID_PAYLOAD\"),\n  z.literal(\"EXECUTING\"),\n  z.literal(\"WAITING_TO_CONTINUE\"),\n  z.literal(\"WAITING_TO_EXECUTE\"),\n]);\n\nexport const RunTaskSchema = z.object({\n  /** The Task id */\n  id: z.string(),\n  /** The key that you defined when creating the Task, the first param in any task. */\n  displayKey: z.string().nullable(),\n  /** The Task status */\n  status: TaskStatusSchema,\n  /** The name of the Task */\n  name: z.string(),\n  /** The icon of the Task, a string.\n   * For integrations, this will be a lowercase name of the company.\n   * Can be used with the [@trigger.dev/companyicons](https://www.npmjs.com/package/@trigger.dev/companyicons) package to display an svg. */\n  icon: z.string().nullable(),\n  /** When the task started */\n  startedAt: z.coerce.date().nullable(),\n  /** When the task completed */\n  completedAt: z.coerce.date().nullable(),\n});\n\nexport type RunTaskWithSubtasks = z.infer<typeof RunTaskSchema> & {\n  /** The subtasks of the task */\n  subtasks?: RunTaskWithSubtasks[];\n};\n\nconst RunTaskWithSubtasksSchema: z.ZodType<RunTaskWithSubtasks> = RunTaskSchema.extend({\n  subtasks: z.lazy(() => RunTaskWithSubtasksSchema.array()).optional(),\n});\n\nconst GetRunOptionsSchema = z.object({\n  /** Return subtasks, which appear in a `subtasks` array on a task. @default false */\n  subtasks: z.boolean().optional(),\n  /** You can use this to get more tasks, if there are more than are returned in a single batch @default undefined */\n  cursor: z.string().optional(),\n  /** How many tasks you want to return in one go, max 50. @default 20 */\n  take: z.number().optional(),\n});\n\nexport type GetRunOptions = z.infer<typeof GetRunOptionsSchema>;\n\nconst GetRunOptionsWithTaskDetailsSchema = GetRunOptionsSchema.extend({\n  /** If `true`, it returns the `params` and `output` of all tasks. @default false */\n  taskdetails: z.boolean().optional(),\n});\n\nexport type GetRunOptionsWithTaskDetails = z.infer<typeof GetRunOptionsWithTaskDetailsSchema>;\n\nconst RunSchema = z.object({\n  /** The Run id */\n  id: z.string(),\n  /** The Run status */\n  status: RunStatusSchema,\n  /** When the run started */\n  startedAt: z.coerce.date().nullable(),\n  /** When the run was last updated */\n  updatedAt: z.coerce.date().nullable(),\n  /** When the run was completed */\n  completedAt: z.coerce.date().nullable(),\n});\n\nexport const GetRunSchema = RunSchema.extend({\n  /** The output of the run */\n  output: z.any().optional(),\n  /** The tasks from the run */\n  tasks: z.array(RunTaskWithSubtasksSchema),\n  /** Any status updates that were published from the run */\n  statuses: z.array(JobRunStatusRecordSchema).default([]),\n  /** If there are more tasks, you can use this to get them */\n  nextCursor: z.string().optional(),\n});\n\nexport type GetRun = Prettify<z.infer<typeof GetRunSchema>>;\n\nconst GetRunsOptionsSchema = z.object({\n  /** You can use this to get more tasks, if there are more than are returned in a single batch @default undefined */\n  cursor: z.string().optional(),\n  /** How many runs you want to return in one go, max 50. @default 20 */\n  take: z.number().optional(),\n});\n\nexport type GetRunsOptions = z.infer<typeof GetRunsOptionsSchema>;\n\nexport const GetRunsSchema = z.object({\n  /** The runs from the query */\n  runs: RunSchema.array(),\n  /** If there are more runs, you can use this to get them */\n  nextCursor: z.string().optional(),\n});\n\nexport type RunNotificationJobMetadata = { id: string; version: string };\nexport type RunNotificationEnvMetadata = {\n  slug: string;\n  id: string;\n  type: RuntimeEnvironmentType;\n};\nexport type RunNotificationOrgMetadata = { slug: string; id: string; title: string };\nexport type RunNotificationProjectMetadata = { slug: string; id: string; name: string };\nexport type RunNotificationAccountMetadata = { id: string; metadata?: any };\nexport type RunNotificationInvocationMetadata<T = any> = {\n  id: string;\n  context: any;\n  timestamp: Date;\n  payload: T;\n};\nexport type RunNotificationRunMetadata = {\n  /** The Run id */\n  id: string;\n  /** The Run status */\n  statuses: JobRunStatusRecord[];\n  /** When the run started */\n  startedAt: Date;\n  /** When the run was last updated */\n  updatedAt: Date;\n  /** When the run was completed */\n  completedAt: Date;\n  /** If the run was a test or not */\n  isTest: boolean;\n\n  executionDurationInMs: number;\n  executionCount: number;\n};\n\ntype RunNotificationCommon<TPayload = any> = {\n  /** The Run id */\n  id: string;\n  /** The Run status */\n  statuses: JobRunStatusRecord[];\n  /** When the run started */\n  startedAt: Date;\n  /** When the run was last updated */\n  updatedAt: Date;\n  /** When the run was completed */\n  completedAt: Date;\n  /** If the run was a test or not */\n  isTest: boolean;\n\n  executionDurationInMs: number;\n  executionCount: number;\n\n  /** Job metadata */\n  job: RunNotificationJobMetadata;\n  /** Environment metadata */\n  environment: RunNotificationEnvMetadata;\n  /** Organization metadata */\n  organization: RunNotificationOrgMetadata;\n  /** Project metadata */\n  project: RunNotificationProjectMetadata;\n  /** Account metadata */\n  account?: RunNotificationAccountMetadata;\n  /** Invocation metadata */\n  invocation: RunNotificationInvocationMetadata<TPayload>;\n};\n\nexport type SuccessfulRunNotification<TOutput, TPayload = any> = RunNotificationCommon<TPayload> & {\n  ok: true;\n  /** The Run status */\n  status: \"SUCCESS\";\n  /** The output of the run */\n  output: TOutput;\n};\n\nexport type FailedRunNotification<TPayload = any> = RunNotificationCommon<TPayload> & {\n  ok: false;\n  /** The Run status */\n  status: \"FAILURE\" | \"TIMED_OUT\" | \"ABORTED\" | \"CANCELED\" | \"UNRESOLVED_AUTH\" | \"INVALID_PAYLOAD\";\n  /** The error of the run */\n  error: any;\n  /** The task that failed */\n  task?: {\n    id: string;\n    cacheKey: string | null;\n    status: string;\n    name: string;\n    icon: string | null;\n    startedAt: string;\n    error: ErrorWithStack;\n    params: any | null;\n  };\n};\n\nexport type RunNotification<TOutput, TPayload = any> =\n  | SuccessfulRunNotification<TOutput, TPayload>\n  | FailedRunNotification<TPayload>;\n", "import { z } from \"zod\";\nimport { SerializableJsonSchema } from \"./json\";\nimport { RunStatusSchema } from \"./runs\";\n\nexport const StatusUpdateStateSchema = z.union([\n  z.literal(\"loading\"),\n  z.literal(\"success\"),\n  z.literal(\"failure\"),\n]);\nexport type StatusUpdateState = z.infer<typeof StatusUpdateStateSchema>;\n\nconst StatusUpdateDataSchema = z.record(SerializableJsonSchema);\nexport type StatusUpdateData = z.infer<typeof StatusUpdateDataSchema>;\n\nexport const StatusUpdateSchema = z.object({\n  label: z.string().optional(),\n  state: StatusUpdateStateSchema.optional(),\n  data: StatusUpdateDataSchema.optional(),\n});\nexport type StatusUpdate = z.infer<typeof StatusUpdateSchema>;\n\nconst InitalStatusUpdateSchema = StatusUpdateSchema.required({ label: true });\nexport type InitialStatusUpdate = z.infer<typeof InitalStatusUpdateSchema>;\n\nexport const StatusHistorySchema = z.array(StatusUpdateSchema);\nexport type StatusHistory = z.infer<typeof StatusHistorySchema>;\n\nexport const JobRunStatusRecordSchema = InitalStatusUpdateSchema.extend({\n  key: z.string(),\n  history: StatusHistorySchema,\n});\n\nexport type JobRunStatusRecord = z.infer<typeof JobRunStatusRecordSchema>;\n", "import { z } from \"zod\";\nimport { EventFilterSchema, stringPatternMatchers } from \"./eventFilter\";\nimport { Prettify } from \"../types\";\n\nconst StringMatchSchema = z.union([\n  /** Match against a string */\n  z.array(z.string()),\n  z.array(z.union(stringPatternMatchers)),\n]);\n\nexport type StringMatch = z.infer<typeof StringMatchSchema>;\n\nexport const HTTPMethodUnionSchema = z.union([\n  z.literal(\"GET\"),\n  z.literal(\"POST\"),\n  z.literal(\"PUT\"),\n  z.literal(\"PATCH\"),\n  z.literal(\"DELETE\"),\n  z.literal(\"HEAD\"),\n  z.literal(\"OPTIONS\"),\n]);\n\nexport type HttpMethod = z.infer<typeof HTTPMethodUnionSchema>;\n\n/** Only Requests that match this filter will cause the `handler` function to run.\n * For example, you can use this to only respond to `GET` Requests. */\nexport const RequestFilterSchema = z.object({\n  /** An array of HTTP methods to match.\n   * For example, `[\"GET\", \"POST\"]` will match both `GET` and `POST` Requests. */\n  method: z.array(HTTPMethodUnionSchema).optional(),\n  /** An object of header key/values to match. \n   * This uses the [EventFilter matching syntax](https://trigger.dev/docs/documentation/guides/event-filter).\n\n    @example\n  ```ts\n  filter: {\n    header: {\n      \"content-type\": [\"application/json\"],\n    },\n  },\n  ``` */\n  headers: z.record(StringMatchSchema).optional(),\n  /** An object of query parameters to match. \n   * This uses the [EventFilter matching syntax](https://trigger.dev/docs/documentation/guides/event-filter).\n\n  @example\n  ```ts\n  filter: {\n    query: {\n      \"hub.mode\": [{ $startsWith: \"sub\" }],\n    },\n  },\n  ``` */\n  query: z.record(StringMatchSchema).optional(),\n  /** An object of key/values to match.\n   * This uses the [EventFilter matching syntax](https://trigger.dev/docs/documentation/guides/event-filter).\n   */\n  body: EventFilterSchema.optional(),\n});\n\nexport type RequestFilter = z.infer<typeof RequestFilterSchema>;\n\n/** Only Requests that match this filter will cause the `handler` function to run.\n * For example, you can use this to only respond to `GET` Requests. */\nexport const ResponseFilterSchema = RequestFilterSchema.omit({ method: true, query: true }).extend({\n  status: z.array(z.number()).optional(),\n});\n\nexport type ResponseFilter = Prettify<z.infer<typeof ResponseFilterSchema>>;\n", "import { z } from \"zod\";\n\nexport const MISSING_CONNECTION_NOTIFICATION = \"dev.trigger.notifications.missingConnection\";\n\nexport const MISSING_CONNECTION_RESOLVED_NOTIFICATION =\n  \"dev.trigger.notifications.missingConnectionResolved\";\n\nexport const CommonMissingConnectionNotificationPayloadSchema = z.object({\n  id: z.string(),\n  client: z.object({\n    id: z.string(),\n    title: z.string(),\n    scopes: z.array(z.string()),\n    createdAt: z.coerce.date(),\n    updatedAt: z.coerce.date(),\n  }),\n  authorizationUrl: z.string(),\n});\n\nexport const MissingDeveloperConnectionNotificationPayloadSchema =\n  CommonMissingConnectionNotificationPayloadSchema.extend({\n    type: z.literal(\"DEVELOPER\"),\n  });\n\nexport const MissingExternalConnectionNotificationPayloadSchema =\n  CommonMissingConnectionNotificationPayloadSchema.extend({\n    type: z.literal(\"EXTERNAL\"),\n    account: z.object({\n      id: z.string(),\n      metadata: z.any(),\n    }),\n  });\n\nexport const MissingConnectionNotificationPayloadSchema = z.discriminatedUnion(\"type\", [\n  MissingDeveloperConnectionNotificationPayloadSchema,\n  MissingExternalConnectionNotificationPayloadSchema,\n]);\n\nexport type MissingConnectionNotificationPayload = z.infer<\n  typeof MissingConnectionNotificationPayloadSchema\n>;\n\nexport const CommonMissingConnectionNotificationResolvedPayloadSchema = z.object({\n  id: z.string(),\n  client: z.object({\n    id: z.string(),\n    title: z.string(),\n    scopes: z.array(z.string()),\n    createdAt: z.coerce.date(),\n    updatedAt: z.coerce.date(),\n    integrationIdentifier: z.string(),\n    integrationAuthMethod: z.string(),\n  }),\n  expiresAt: z.coerce.date(),\n});\n\nexport const MissingDeveloperConnectionResolvedNotificationPayloadSchema =\n  CommonMissingConnectionNotificationResolvedPayloadSchema.extend({\n    type: z.literal(\"DEVELOPER\"),\n  });\n\nexport const MissingExternalConnectionResolvedNotificationPayloadSchema =\n  CommonMissingConnectionNotificationResolvedPayloadSchema.extend({\n    type: z.literal(\"EXTERNAL\"),\n    account: z.object({\n      id: z.string(),\n      metadata: z.any(),\n    }),\n  });\n\nexport const MissingConnectionResolvedNotificationPayloadSchema = z.discriminatedUnion(\"type\", [\n  MissingDeveloperConnectionResolvedNotificationPayloadSchema,\n  MissingExternalConnectionResolvedNotificationPayloadSchema,\n]);\n\nexport type MissingConnectionResolvedNotificationPayload = z.infer<\n  typeof MissingConnectionResolvedNotificationPayloadSchema\n>;\n", "import { z } from \"zod\";\nimport { RedactStringSchema, RetryOptionsSchema } from \"./api\";\nimport { EventFilterSchema } from \"./eventFilter\";\nimport { ResponseFilterSchema } from \"./requestFilter\";\nimport { Prettify } from \"../types\";\n\nexport const FetchRetryHeadersStrategySchema = z.object({\n  /** The `headers` strategy retries the request using info from the response headers. */\n  strategy: z.literal(\"headers\"),\n  /** The header to use to determine the maximum number of times to retry the request. */\n  limitHeader: z.string(),\n  /** The header to use to determine the number of remaining retries. */\n  remainingHeader: z.string(),\n  /** The header to use to determine the time when the number of remaining retries will be reset. */\n  resetHeader: z.string(),\n  /** The event filter to use to determine if the request should be retried. */\n  bodyFilter: EventFilterSchema.optional(),\n\n  /** The format of the `resetHeader` value. */\n  resetFormat: z\n    .enum([\n      \"unix_timestamp\",\n      \"unix_timestamp_in_ms\",\n      \"iso_8601\",\n      \"iso_8601_duration_openai_variant\",\n    ])\n    .default(\"unix_timestamp\"),\n});\n\nexport type FetchRetryHeadersStrategy = z.infer<typeof FetchRetryHeadersStrategySchema>;\n\n/** The `backoff` strategy retries the request with an exponential backoff. */\nexport const FetchRetryBackoffStrategySchema = RetryOptionsSchema.extend({\n  /** The `backoff` strategy retries the request with an exponential backoff. */\n  strategy: z.literal(\"backoff\"),\n  /** The event filter to use to determine if the request should be retried. */\n  bodyFilter: EventFilterSchema.optional(),\n});\n\n/** The `backoff` strategy retries the request with an exponential backoff. */\nexport type FetchRetryBackoffStrategy = z.infer<typeof FetchRetryBackoffStrategySchema>;\n\nexport const FetchRetryStrategySchema = z.discriminatedUnion(\"strategy\", [\n  FetchRetryHeadersStrategySchema,\n  FetchRetryBackoffStrategySchema,\n]);\n\nexport type FetchRetryStrategy = z.infer<typeof FetchRetryStrategySchema>;\n\n/** The options for a fetch request */\nexport const FetchRequestInitSchema = z.object({\n  /** The HTTP method to use for the request. */\n  method: z.string().optional(),\n  /** Any headers to send with the request. Note that you can use [redactString](https://trigger.dev/docs/sdk/redactString) to prevent sensitive information from being stored (e.g. in the logs), like API keys and tokens. */\n  headers: z.record(z.union([z.string(), RedactStringSchema])).optional(),\n  /** The body of the request. */\n  body: z.union([z.string(), z.instanceof(ArrayBuffer)]).optional(),\n});\n\n/** The options for a fetch request */\nexport type FetchRequestInit = z.infer<typeof FetchRequestInitSchema>;\n\nexport const FetchRetryOptionsSchema = z.record(FetchRetryStrategySchema);\n\n/** An object where the key is a status code pattern and the value is a retrying strategy. Supported patterns are:\n  - Specific status codes: 429\n  - Ranges: 500-599\n  - Wildcards: 2xx, 3xx, 4xx, 5xx \n  */\nexport type FetchRetryOptions = z.infer<typeof FetchRetryOptionsSchema>;\n\nexport const FetchTimeoutOptionsSchema = z.object({\n  durationInMs: z.number(),\n  retry: RetryOptionsSchema.optional(),\n});\n\nexport type FetchTimeoutOptions = z.infer<typeof FetchTimeoutOptionsSchema>;\n\nexport const FetchOperationSchema = z.object({\n  url: z.string(),\n  requestInit: FetchRequestInitSchema.optional(),\n  retry: z.record(FetchRetryStrategySchema).optional(),\n  timeout: FetchTimeoutOptionsSchema.optional(),\n});\n\nexport type FetchOperation = z.infer<typeof FetchOperationSchema>;\n\nexport const FetchPollOperationSchema = z.object({\n  url: z.string(),\n  interval: z.number().int().positive().min(10).max(600).default(10), // defaults to 10 seconds\n  timeout: z.number().int().positive().min(30).max(3600).default(600), // defaults to 10 minutes\n  responseFilter: ResponseFilterSchema,\n  requestInit: FetchRequestInitSchema.optional(),\n  requestTimeout: FetchTimeoutOptionsSchema.optional(),\n});\n\nexport type FetchPollOperation = Prettify<z.infer<typeof FetchPollOperationSchema>>;\n", "import { z } from \"zod\";\nimport { RunStatusSchema } from \"./runs\";\n\nexport const GetEventSchema = z.object({\n  /** The event id */\n  id: z.string(),\n  /** The event name */\n  name: z.string(),\n  /** When the event was created */\n  createdAt: z.coerce.date(),\n  /** When the event was last updated */\n  updatedAt: z.coerce.date(),\n  /** The runs that were triggered by the event */\n  runs: z.array(\n    z.object({\n      /** The Run id */\n      id: z.string(),\n      /** The Run status */\n      status: RunStatusSchema,\n      /** When the run started */\n      startedAt: z.coerce.date().optional().nullable(),\n      /** When the run completed */\n      completedAt: z.coerce.date().optional().nullable(),\n    })\n  ),\n});\n\nexport type GetEvent = z.infer<typeof GetEventSchema>;\n\nexport const CancelRunsForEventSchema = z.object({\n  cancelledRunIds: z.array(z.string()),\n  failedToCancelRunIds: z.array(z.string()),\n});\n\nexport type CancelRunsForEvent = z.infer<typeof CancelRunsForEventSchema>;\n", "import { z } from \"zod\";\n\nexport const RequestWithRawBodySchema = z.object({\n  url: z.string(),\n  method: z.string(),\n  headers: z.record(z.string()),\n  rawBody: z.string(),\n});\n", "import { z } from \"zod\";\n\nexport const CancelRunsForJobSchema = z.object({\n  cancelledRunIds: z.array(z.string()),\n  failedToCancelRunIds: z.array(z.string()),\n});\n\nexport type CancelRunsForJob = z.infer<typeof CancelRunsForJobSchema>;\n", "// EventFilter is typed as type EventFilter = { [key: string]: EventFilter | string[] | number[] | boolean[] }\n\nimport { EventFilter } from \"./schemas\";\n\n// This function should take any number of EventFilters and return a new EventFilter that is the result of merging of them.\nexport function deepMergeFilters(...filters: EventFilter[]): EventFilter {\n  const result: EventFilter = {};\n\n  for (const filter of filters) {\n    for (const key in filter) {\n      if (filter.hasOwnProperty(key)) {\n        const filterValue = filter[key];\n        const existingValue = result[key];\n\n        if (\n          existingValue &&\n          typeof existingValue === \"object\" &&\n          typeof filterValue === \"object\" &&\n          !Array.isArray(existingValue) &&\n          !Array.isArray(filterValue) &&\n          existingValue !== null &&\n          filterValue !== null\n        ) {\n          result[key] = deepMergeFilters(existingValue, filterValue);\n        } else {\n          result[key] = filterValue;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nexport function assertExhaustive(x: never): never {\n  throw new Error(\"Unexpected object: \" + x);\n}\n", "import { RetryOptions } from \"./schemas\";\n\nconst DEFAULT_RETRY_OPTIONS = {\n  limit: 5,\n  factor: 1.8,\n  minTimeoutInMs: 1000,\n  maxTimeoutInMs: 60000,\n  randomize: true,\n} satisfies RetryOptions;\n\nexport function calculateRetryAt(retryOptions: RetryOptions, attempts: number): Date | undefined {\n  const options = {\n    ...DEFAULT_RETRY_OPTIONS,\n    ...retryOptions,\n  };\n\n  const retryCount = attempts + 1;\n\n  if (retryCount >= options.limit) {\n    return;\n  }\n\n  const random = options.randomize ? Math.random() + 1 : 1;\n\n  let timeoutInMs = Math.round(\n    random *\n      Math.max(options.minTimeoutInMs, 1) *\n      Math.pow(options.factor, Math.max(attempts - 1, 0))\n  );\n\n  timeoutInMs = Math.min(timeoutInMs, options.maxTimeoutInMs);\n\n  return new Date(Date.now() + timeoutInMs);\n}\n\nexport function calculateResetAt(\n  resets: string | undefined | null,\n  format:\n    | \"unix_timestamp\"\n    | \"iso_8601\"\n    | \"iso_8601_duration_openai_variant\"\n    | \"unix_timestamp_in_ms\",\n  now: Date = new Date()\n): Date | undefined {\n  if (!resets) return;\n\n  switch (format) {\n    case \"iso_8601_duration_openai_variant\": {\n      return calculateISO8601DurationOpenAIVariantResetAt(resets, now);\n    }\n    case \"iso_8601\": {\n      return calculateISO8601ResetAt(resets, now);\n    }\n    case \"unix_timestamp\": {\n      return calculateUnixTimestampResetAt(resets, now);\n    }\n    case \"unix_timestamp_in_ms\": {\n      return calculateUnixTimestampInMsResetAt(resets, now);\n    }\n  }\n}\n\nfunction calculateUnixTimestampResetAt(resets: string, now: Date = new Date()): Date | undefined {\n  // Check if the input is null or undefined\n  if (!resets) return undefined;\n\n  // Convert the string to a number\n  const resetAt = parseInt(resets, 10);\n\n  // If the string doesn't match the expected format, return undefined\n  if (isNaN(resetAt)) return undefined;\n\n  // Return the date\n  return new Date(resetAt * 1000);\n}\n\nfunction calculateUnixTimestampInMsResetAt(\n  resets: string,\n  now: Date = new Date()\n): Date | undefined {\n  // Check if the input is null or undefined\n  if (!resets) return undefined;\n\n  // Convert the string to a number\n  const resetAt = parseInt(resets, 10);\n\n  // If the string doesn't match the expected format, return undefined\n  if (isNaN(resetAt)) return undefined;\n\n  // Return the date\n  return new Date(resetAt);\n}\n\nfunction calculateISO8601ResetAt(resets: string, now: Date = new Date()): Date | undefined {\n  // Check if the input is null or undefined\n  if (!resets) return undefined;\n\n  // Parse the date\n  const resetAt = new Date(resets);\n\n  // If the string doesn't match the expected format, return undefined\n  if (isNaN(resetAt.getTime())) return undefined;\n\n  return resetAt;\n}\n\nfunction calculateISO8601DurationOpenAIVariantResetAt(\n  resets: string,\n  now: Date = new Date()\n): Date | undefined {\n  // Check if the input is null or undefined\n  if (!resets) return undefined;\n\n  // Regular expression to match the duration string pattern\n  const pattern = /^(?:(\\d+)d)?(?:(\\d+)h)?(?:(\\d+)m)?(?:(\\d+(?:\\.\\d+)?)s)?(?:(\\d+)ms)?$/;\n  const match = resets.match(pattern);\n\n  // If the string doesn't match the expected format, return undefined\n  if (!match) return undefined;\n\n  // Extract days, hours, minutes, seconds, and milliseconds from the string\n  const days = parseInt(match[1], 10) || 0;\n  const hours = parseInt(match[2], 10) || 0;\n  const minutes = parseInt(match[3], 10) || 0;\n  const seconds = parseFloat(match[4]) || 0;\n  const milliseconds = parseInt(match[5], 10) || 0;\n\n  // Calculate the future date based on the current date plus the extracted time\n  const resetAt = new Date(now);\n  resetAt.setDate(resetAt.getDate() + days);\n  resetAt.setHours(resetAt.getHours() + hours);\n  resetAt.setMinutes(resetAt.getMinutes() + minutes);\n  resetAt.setSeconds(resetAt.getSeconds() + Math.floor(seconds));\n  resetAt.setMilliseconds(\n    resetAt.getMilliseconds() + (seconds - Math.floor(seconds)) * 1000 + milliseconds\n  );\n\n  return resetAt;\n}\n", "import { DeserializedJson } from \"./schemas\";\n\nexport interface ExampleReplacement {\n  marker: string;\n  replace(input: ExampleInputData): DeserializedJson;\n}\n\ntype ExampleInputData = {\n  match: {\n    key: string;\n    value: string;\n  };\n  data: {\n    now: Date;\n  };\n};\n\nexport const currentDate: ExampleReplacement = {\n  marker: \"__CURRENT_DATE__\",\n  replace({ data: { now } }: ExampleInputData) {\n    return now.toISOString();\n  },\n};\n\nexport const currentTimestampMilliseconds: ExampleReplacement = {\n  marker: \"__CURRENT_TIMESTAMP_MS__\",\n  replace({ data: { now } }: ExampleInputData) {\n    return now.getTime();\n  },\n};\n\nexport const currentTimestampSeconds: ExampleReplacement = {\n  marker: \"__CURRENT_TIMESTAMP_S__\",\n  replace({ data: { now } }: ExampleInputData) {\n    return now.getTime() / 1000;\n  },\n};\n\nexport const replacements: ExampleReplacement[] = [\n  currentDate,\n  currentTimestampMilliseconds,\n  currentTimestampSeconds,\n];\n", "export function urlWithSearchParams(\n  url: string,\n  params: Record<string, string | number | boolean> | undefined\n) {\n  if (!params) {\n    return url;\n  }\n\n  const urlObj = new URL(url);\n  for (const [key, value] of Object.entries(params)) {\n    if (value !== undefined) {\n      urlObj.searchParams.append(key, String(value));\n    }\n  }\n  return urlObj.toString();\n}\n", "import { EventFilter } from \"./schemas/eventFilter\";\n\n// EventFilter is a recursive type, where the keys are strings and the values are an array of strings, numbers, booleans, or objects.\n// If the values of the array are strings, numbers, or booleans, than we are matching against the value of the payload.\n// If the values of the array are objects, then we are doing content filtering\n// An example would be [{ $endsWith: \".png\" }, { $startsWith: \"images/\" } ]\nexport function eventFilterMatches(payload: any, filter: EventFilter): boolean {\n  if (payload === undefined || payload === null) {\n    if (Object.entries(filter).length === 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  for (const [patternKey, patternValue] of Object.entries(filter)) {\n    const payloadValue = payload[patternKey];\n\n    if (Array.isArray(patternValue)) {\n      if (patternValue.length === 0) {\n        continue;\n      }\n\n      // Check to see if all the items in the array are a string\n      if ((patternValue as unknown[]).every((item) => typeof item === \"string\")) {\n        if ((patternValue as string[]).includes(payloadValue)) {\n          continue;\n        }\n\n        return false;\n      }\n\n      // Check to see if all the items in the array are a number\n      if ((patternValue as unknown[]).every((item) => typeof item === \"number\")) {\n        if ((patternValue as number[]).includes(payloadValue)) {\n          continue;\n        }\n\n        return false;\n      }\n\n      // Check to see if all the items in the array are a boolean\n      if ((patternValue as unknown[]).every((item) => typeof item === \"boolean\")) {\n        if ((patternValue as boolean[]).includes(payloadValue)) {\n          continue;\n        }\n\n        return false;\n      }\n\n      // Now we know that all the items in the array are objects\n      const objectArray = patternValue as Exclude<\n        typeof patternValue,\n        number[] | string[] | boolean[]\n      >;\n\n      if (!contentFiltersMatches(payloadValue, objectArray)) {\n        return false;\n      }\n\n      continue;\n    } else if (typeof patternValue === \"object\") {\n      if (Array.isArray(payloadValue)) {\n        if (!payloadValue.some((item) => eventFilterMatches(item, patternValue))) {\n          return false;\n        }\n      } else {\n        if (!eventFilterMatches(payloadValue, patternValue)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\ntype ContentFilters = Exclude<EventFilter[string], EventFilter | string[] | number[] | boolean[]>;\n\nfunction contentFiltersMatches(actualValue: any, contentFilters: ContentFilters): boolean {\n  for (const contentFilter of contentFilters) {\n    if (typeof contentFilter === \"object\") {\n      const [key, value] = Object.entries(contentFilter)[0];\n\n      if (!contentFilterMatches(actualValue, contentFilter)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction contentFilterMatches(actualValue: any, contentFilter: ContentFilters[number]): boolean {\n  if (\"$endsWith\" in contentFilter) {\n    if (typeof actualValue !== \"string\") {\n      return false;\n    }\n\n    return actualValue.endsWith(contentFilter.$endsWith);\n  }\n\n  if (\"$startsWith\" in contentFilter) {\n    if (typeof actualValue !== \"string\") {\n      return false;\n    }\n\n    return actualValue.startsWith(contentFilter.$startsWith);\n  }\n\n  if (\"$anythingBut\" in contentFilter) {\n    if (Array.isArray(contentFilter.$anythingBut)) {\n      if ((contentFilter.$anythingBut as any[]).includes(actualValue)) {\n        return false;\n      }\n    }\n\n    if (contentFilter.$anythingBut === actualValue) {\n      return false;\n    }\n\n    return true;\n  }\n\n  if (\"$exists\" in contentFilter) {\n    if (contentFilter.$exists) {\n      return actualValue !== undefined;\n    }\n\n    return actualValue === undefined;\n  }\n\n  if (\"$gt\" in contentFilter) {\n    if (typeof actualValue !== \"number\") {\n      return false;\n    }\n\n    return actualValue > contentFilter.$gt;\n  }\n\n  if (\"$lt\" in contentFilter) {\n    if (typeof actualValue !== \"number\") {\n      return false;\n    }\n\n    return actualValue < contentFilter.$lt;\n  }\n\n  if (\"$gte\" in contentFilter) {\n    if (typeof actualValue !== \"number\") {\n      return false;\n    }\n\n    return actualValue >= contentFilter.$gte;\n  }\n\n  if (\"$lte\" in contentFilter) {\n    if (typeof actualValue !== \"number\") {\n      return false;\n    }\n\n    return actualValue <= contentFilter.$lte;\n  }\n\n  if (\"$between\" in contentFilter) {\n    if (typeof actualValue !== \"number\") {\n      return false;\n    }\n\n    return actualValue >= contentFilter.$between[0] && actualValue <= contentFilter.$between[1];\n  }\n\n  if (\"$includes\" in contentFilter) {\n    if (Array.isArray(actualValue)) {\n      return actualValue.includes(contentFilter.$includes);\n    }\n\n    return false;\n  }\n\n  // Use localCompare\n  if (\"$ignoreCaseEquals\" in contentFilter) {\n    if (typeof actualValue !== \"string\") {\n      return false;\n    }\n\n    return (\n      actualValue.localeCompare(contentFilter.$ignoreCaseEquals, undefined, {\n        sensitivity: \"accent\",\n      }) === 0\n    );\n  }\n\n  if (\"$isNull\" in contentFilter) {\n    if (contentFilter.$isNull) {\n      return actualValue === null;\n    }\n\n    return actualValue !== null;\n  }\n\n  if (\"$not\" in contentFilter) {\n    if (Array.isArray(actualValue)) {\n      return !actualValue.includes(contentFilter.$not);\n    } else if (typeof actualValue === 'number' || typeof actualValue === 'boolean' || typeof actualValue === 'string') {\n      return actualValue !== contentFilter.$not;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n", "import { eventFilterMatches } from \"./eventFilterMatches\";\nimport { HttpMethod, RequestFilter, ResponseFilter, StringMatch } from \"./schemas/requestFilter\";\n\nexport async function requestFilterMatches(\n  request: Request,\n  filter: RequestFilter\n): Promise<boolean> {\n  const clonedRequest = request.clone();\n  if (!requestMethodMatches(clonedRequest.method as HttpMethod, filter.method)) {\n    return false;\n  }\n\n  const headersObj = Object.fromEntries(clonedRequest.headers.entries());\n  if (filter.headers && !eventFilterMatches(headersObj, filter.headers)) {\n    return false;\n  }\n\n  const searchParams = new URL(clonedRequest.url).searchParams;\n  const searchParamsObject: Record<string, string> = {};\n  for (const [key, value] of searchParams.entries()) {\n    searchParamsObject[key] = value;\n  }\n\n  if (filter.query && !eventFilterMatches(searchParamsObject, filter.query)) {\n    return false;\n  }\n\n  try {\n    const json = await clonedRequest.json();\n    if (filter.body && !eventFilterMatches(json, filter.body)) {\n      return false;\n    }\n  } catch (e) {\n    if (filter.body) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport type ResponseFilterMatchResult = {\n  match: boolean;\n  body?: unknown;\n};\n\nexport async function responseFilterMatches(\n  response: Response,\n  filter: ResponseFilter\n): Promise<ResponseFilterMatchResult> {\n  if (filter.headers && !eventFilterMatches(response.headers, filter.headers)) {\n    return { match: false };\n  }\n\n  try {\n    const json = await response.json();\n    if (filter.body && !eventFilterMatches(json, filter.body)) {\n      return { match: false, body: json };\n    } else {\n      return { match: true, body: json };\n    }\n  } catch (e) {\n    if (filter.body) {\n      return { match: false, body: undefined };\n    }\n  }\n\n  return { match: true, body: undefined };\n}\n\nfunction requestMethodMatches(method: HttpMethod, filter: RequestFilter[\"method\"]): boolean {\n  if (!filter) {\n    return true;\n  }\n\n  return filter.includes(method);\n}\n", "export const API_VERSIONS = {\n  LAZY_LOADED_CACHED_TASKS: \"2023-09-29\",\n  SERIALIZED_TASK_OUTPUT: \"2023-11-01\",\n} as const;\n\nexport const PLATFORM_FEATURES = {\n  yieldExecution: API_VERSIONS.LAZY_LOADED_CACHED_TASKS,\n  lazyLoadedCachedTasks: API_VERSIONS.LAZY_LOADED_CACHED_TASKS,\n};\n\nexport function supportsFeature<TFeatureName extends keyof typeof PLATFORM_FEATURES>(\n  featureName: TFeatureName,\n  version: string\n): boolean {\n  if (version === \"unversioned\" || version === \"unknown\") {\n    return false;\n  }\n\n  const supportedVersion = PLATFORM_FEATURES[featureName];\n\n  if (!supportedVersion) {\n    return false;\n  }\n\n  return version >= supportedVersion;\n}\n", "import { Buffer } from \"node:buffer\";\n\nexport class BloomFilter {\n  private size: number;\n  private bitArray: Uint8Array;\n\n  constructor(size: number) {\n    this.size = size;\n    this.bitArray = new Uint8Array(Math.ceil(size / 8));\n  }\n\n  add(item: string): void {\n    const index = murmurHash3(item) % this.size;\n    this.bitArray[Math.floor(index / 8)] |= 1 << index % 8;\n  }\n\n  test(item: string): boolean {\n    const index = murmurHash3(item) % this.size;\n    return (this.bitArray[Math.floor(index / 8)] & (1 << index % 8)) !== 0;\n  }\n\n  // Serialize to a Base64 string\n  serialize(): string {\n    return Buffer.from(this.bitArray).toString(\"base64\");\n  }\n\n  // Deserialize from a Base64 string\n  static deserialize(str: string, size: number): BloomFilter {\n    const filter = new BloomFilter(size);\n    filter.bitArray = Uint8Array.from(Buffer.from(str, \"base64\"));\n    return filter;\n  }\n\n  static NOOP_TASK_SET_SIZE = 32_768;\n}\n\nfunction murmurHash3(str: string, seed = 0): number {\n  let h1 = 0xdeadbeef ^ seed,\n    h2 = 0x41c6ce57 ^ seed;\n  for (let i = 0, ch; i < str.length; i++) {\n    ch = str.charCodeAt(i);\n    h1 = Math.imul(h1 ^ ch, 0xcc9e2d51);\n    h1 = (h1 << 15) | (h1 >>> 17);\n    h1 = Math.imul(h1, 0x1b873593);\n\n    h2 = Math.imul(h2 ^ ch, 0x85ebca6b);\n    h2 = (h2 << 13) | (h2 >>> 19);\n    h2 = Math.imul(h2, 0xc2b2ae35);\n  }\n\n  h1 ^= str.length;\n  h2 ^= str.length;\n\n  h1 = Math.imul(h1 ^ (h1 >>> 16), 0x85ebca6b);\n  h1 = Math.imul(h1 ^ (h1 >>> 13), 0xc2b2ae35);\n  h1 ^= h1 >>> 16;\n\n  h2 = Math.imul(h2 ^ (h2 >>> 16), 0x85ebca6b);\n  h2 = Math.imul(h2 ^ (h2 >>> 13), 0xc2b2ae35);\n  h2 ^= h2 >>> 16;\n\n  return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n}\n", "// Create a logger class that uses the debug package internally\n\n/**\n * Represents different log levels.\n * - `\"log\"`: Only essential messages.\n * - `\"error\"`: Errors and essential messages.\n * - `\"warn\"`: Warnings, Errors and essential messages.\n * - `\"info\"`: Info, Warnings, Errors and essential messages.\n * - `\"debug\"`: Everything.\n */\nimport { env } from \"node:process\";\nimport { Buffer } from \"node:buffer\";\nimport { trace, context } from \"@opentelemetry/api\";\n\nexport type LogLevel = \"log\" | \"error\" | \"warn\" | \"info\" | \"debug\";\n\nconst logLevels: Array<LogLevel> = [\"log\", \"error\", \"warn\", \"info\", \"debug\"];\n\nexport class Logger {\n  #name: string;\n  readonly #level: number;\n  #filteredKeys: string[] = [];\n  #jsonReplacer?: (key: string, value: unknown) => unknown;\n  #additionalFields: () => Record<string, unknown>;\n\n  constructor(\n    name: string,\n    level: LogLevel = \"info\",\n    filteredKeys: string[] = [],\n    jsonReplacer?: (key: string, value: unknown) => unknown,\n    additionalFields?: () => Record<string, unknown>\n  ) {\n    this.#name = name;\n    this.#level = logLevels.indexOf((env.TRIGGER_LOG_LEVEL ?? level) as LogLevel);\n    this.#filteredKeys = filteredKeys;\n    this.#jsonReplacer = createReplacer(jsonReplacer);\n    this.#additionalFields = additionalFields ?? (() => ({}));\n  }\n\n  child(fields: Record<string, unknown>) {\n    return new Logger(\n      this.#name,\n      logLevels[this.#level],\n      this.#filteredKeys,\n      this.#jsonReplacer,\n      () => ({ ...this.#additionalFields(), ...fields })\n    );\n  }\n\n  // Return a new Logger instance with the same name and a new log level\n  // but filter out the keys from the log messages (at any level)\n  filter(...keys: string[]) {\n    return new Logger(this.#name, logLevels[this.#level], keys, this.#jsonReplacer);\n  }\n\n  static satisfiesLogLevel(logLevel: LogLevel, setLevel: LogLevel) {\n    return logLevels.indexOf(logLevel) <= logLevels.indexOf(setLevel);\n  }\n\n  log(message: string, ...args: Array<Record<string, unknown> | undefined>) {\n    if (this.#level < 0) return;\n\n    this.#structuredLog(console.log, message, \"log\", ...args);\n  }\n\n  error(message: string, ...args: Array<Record<string, unknown> | undefined>) {\n    if (this.#level < 1) return;\n\n    this.#structuredLog(console.error, message, \"error\", ...args);\n  }\n\n  warn(message: string, ...args: Array<Record<string, unknown> | undefined>) {\n    if (this.#level < 2) return;\n\n    this.#structuredLog(console.warn, message, \"warn\", ...args);\n  }\n\n  info(message: string, ...args: Array<Record<string, unknown> | undefined>) {\n    if (this.#level < 3) return;\n\n    this.#structuredLog(console.info, message, \"info\", ...args);\n  }\n\n  debug(message: string, ...args: Array<Record<string, unknown> | undefined>) {\n    if (this.#level < 4) return;\n\n    this.#structuredLog(console.debug, message, \"debug\", ...args);\n  }\n\n  #structuredLog(\n    loggerFunction: (message: string, ...args: any[]) => void,\n    message: string,\n    level: string,\n    ...args: Array<Record<string, unknown> | undefined>\n  ) {\n    // Get the current context from trace if it exists\n    const currentSpan = trace.getSpan(context.active());\n\n    const structuredLog = {\n      ...structureArgs(safeJsonClone(args) as Record<string, unknown>[], this.#filteredKeys),\n      ...this.#additionalFields(),\n      timestamp: new Date(),\n      name: this.#name,\n      message,\n      level,\n      traceId:\n        currentSpan && currentSpan.isRecording() ? currentSpan?.spanContext().traceId : undefined,\n      parentSpanId:\n        currentSpan && currentSpan.isRecording() ? currentSpan?.spanContext().spanId : undefined,\n    };\n\n    loggerFunction(JSON.stringify(structuredLog, this.#jsonReplacer));\n  }\n}\n\nfunction createReplacer(replacer?: (key: string, value: unknown) => unknown) {\n  return (key: string, value: unknown) => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n\n    if (replacer) {\n      return replacer(key, value);\n    }\n\n    return value;\n  };\n}\n\n// Replacer function for JSON.stringify that converts BigInts to strings\nfunction bigIntReplacer(_key: string, value: unknown) {\n  if (typeof value === \"bigint\") {\n    return value.toString();\n  }\n\n  return value;\n}\n\nfunction safeJsonClone(obj: unknown) {\n  try {\n    return JSON.parse(JSON.stringify(obj, bigIntReplacer));\n  } catch (e) {\n    return;\n  }\n}\n\n// If args is has a single item that is an object, return that object\nfunction structureArgs(args: Array<Record<string, unknown>>, filteredKeys: string[] = []) {\n  if (!args) {\n    return;\n  }\n\n  if (args.length === 0) {\n    return;\n  }\n\n  if (args.length === 1 && typeof args[0] === \"object\") {\n    return filterKeys(JSON.parse(JSON.stringify(args[0], bigIntReplacer)), filteredKeys);\n  }\n\n  return args;\n}\n\n// Recursively filter out keys from an object, including nested objects, and arrays\nfunction filterKeys(obj: unknown, keys: string[]): any {\n  if (typeof obj !== \"object\" || obj === null) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map((item) => filterKeys(item, keys));\n  }\n\n  const filteredObj: any = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (keys.includes(key)) {\n      if (value) {\n        filteredObj[key] = `[filtered ${prettyPrintBytes(value)}]`;\n      } else {\n        filteredObj[key] = value;\n      }\n      continue;\n    }\n\n    filteredObj[key] = filterKeys(value, keys);\n  }\n\n  return filteredObj;\n}\n\nfunction prettyPrintBytes(value: unknown): string {\n  if (env.NODE_ENV === \"production\") {\n    return \"skipped size\";\n  }\n\n  const sizeInBytes = getSizeInBytes(value);\n\n  if (sizeInBytes < 1024) {\n    return `${sizeInBytes} bytes`;\n  }\n\n  if (sizeInBytes < 1024 * 1024) {\n    return `${(sizeInBytes / 1024).toFixed(2)} KB`;\n  }\n\n  if (sizeInBytes < 1024 * 1024 * 1024) {\n    return `${(sizeInBytes / (1024 * 1024)).toFixed(2)} MB`;\n  }\n\n  return `${(sizeInBytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;\n}\n\nfunction getSizeInBytes(value: unknown) {\n  const jsonString = JSON.stringify(value);\n\n  return Buffer.byteLength(jsonString, \"utf8\");\n}\n", "import { AsyncLocalStorage } from \"node:async_hooks\";\n\nexport class TypedAsyncLocalStorage<T> {\n  private storage: AsyncLocalStorage<T>;\n\n  constructor() {\n    this.storage = new AsyncLocalStorage<T>();\n  }\n\n  runWith<R extends (...args: any[]) => Promise<any>>(context: T, fn: R): Promise<ReturnType<R>> {\n    return this.storage.run(context, fn);\n  }\n\n  getStore(): T | undefined {\n    return this.storage.getStore();\n  }\n}\n", "import { IO } from \"./io\";\nimport { TriggerContext } from \"./types\";\nimport { TypedAsyncLocalStorage } from \"./utils/typedAsyncLocalStorage\";\n\nexport type RunStore = {\n  io: IO;\n  ctx: TriggerContext;\n};\n\nexport const runLocalStorage = new TypedAsyncLocalStorage<RunStore>();\n", "export function slugifyId(input: string): string {\n  // Replace any number of spaces with a single dash\n  const replaceSpacesWithDash = input.toLowerCase().replace(/\\s+/g, \"-\");\n\n  // Remove any non-URL-safe characters\n  const removeNonUrlSafeChars = replaceSpacesWithDash.replace(/[^a-zA-Z0-9-._~]/g, \"\");\n\n  return removeNonUrlSafeChars;\n}\n", "import {\n  FailedRunNotification,\n  IntegrationConfig,\n  InvokeOptions,\n  JobMetadata,\n  Prettify,\n  RunNotification,\n  SuccessfulRunNotification,\n} from \"@trigger.dev/core\";\nimport { LogLevel } from \"@trigger.dev/core-backend\";\nimport { ConcurrencyLimit } from \"./concurrencyLimit\";\nimport { IOWithIntegrations, TriggerIntegration } from \"./integrations\";\nimport { runLocalStorage } from \"./runLocalStorage\";\nimport { TriggerClient } from \"./triggerClient\";\nimport type {\n  EventSpecification,\n  Trigger,\n  TriggerContext,\n  TriggerEventType,\n  TriggerInvokeType,\n} from \"./types\";\nimport { slugifyId } from \"./utils\";\n\nexport type JobOptions<\n  TTrigger extends Trigger<EventSpecification<any>>,\n  TIntegrations extends Record<string, TriggerIntegration> = {},\n  TOutput extends any = any,\n> = {\n  /** The `id` property is used to uniquely identify the Job. Only change this if you want to create a new Job. */\n  id: string;\n  /** The `name` of the Job that you want to appear in the dashboard and logs. You can change this without creating a new Job. */\n  name: string;\n  /** The `version` property is used to version your Job. A new version will be created if you change this property. We recommend using [semantic versioning](https://www.baeldung.com/cs/semantic-versioning), e.g. `1.0.3`. */\n  version: string;\n  /** The `trigger` property is used to define when the Job should run. There are currently the following Trigger types:\n      - [cronTrigger](https://trigger.dev/docs/sdk/crontrigger)\n      - [intervalTrigger](https://trigger.dev/docs/sdk/intervaltrigger)\n      - [eventTrigger](https://trigger.dev/docs/sdk/eventtrigger)\n      - [DynamicTrigger](https://trigger.dev/docs/sdk/dynamictrigger)\n      - [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule)\n      - integration Triggers, like webhooks. See the [integrations](https://trigger.dev/docs/integrations) page for more information. */\n  trigger: TTrigger;\n  /** The `logLevel` property is an optional property that specifies the level of\n      logging for the Job. The level is inherited from the client if you omit this property. */\n  logLevel?: LogLevel;\n  /** Imports the specified integrations into the Job. The integrations will be available on the `io` object in the `run()` function with the same name as the key. For example:\n      ```ts\n      client.defineJob({\n        //... other options\n        integrations: {\n          slack,\n          gh: github,\n        },\n        run: async (payload, io, ctx) => {\n          //slack is available on io.slack\n          io.slack.postMessage(...);\n          //github is available on io.gh\n          io.gh.addIssueLabels(...);\n        }\n      });\n      ``` */\n  integrations?: TIntegrations;\n\n  /**\n   * The `concurrencyLimit` property is used to limit the number of concurrent run executions of a job.\n   * Can be a number which represents the limit or a `ConcurrencyLimit` instance which can be used to\n   * group together multiple jobs to share the same concurrency limit.\n   *\n   * If undefined the job will be limited only by the server's global concurrency limit, or if you are using the\n   * Trigger.dev Cloud service, the concurrency limit of your plan.\n   */\n  concurrencyLimit?: number | ConcurrencyLimit;\n  /** The `enabled` property is used to enable or disable the Job. If you disable a Job, it will not run. */\n  enabled?: boolean;\n  /** This function gets called automatically when a Run is Triggered.\n   * This is where you put the code you want to run for a Job. You can use normal code in here and you can also use Tasks. You can return a value from this function and it will be sent back to the Trigger API.\n   * @param payload The payload of the event\n   * @param io An object that contains the integrations that you specified in the `integrations` property and other useful functions like delays and running Tasks.\n   * @param context An object that contains information about the Organization, Job, Run and more.\n   */\n  run: (\n    payload: TriggerEventType<TTrigger>,\n    io: IOWithIntegrations<TIntegrations>,\n    context: TriggerContext\n  ) => Promise<TOutput>;\n\n  onSuccess?: (\n    notification: SuccessfulRunNotification<TOutput, TriggerEventType<TTrigger>>\n  ) => void;\n\n  onFailure?: (notification: FailedRunNotification<TriggerEventType<TTrigger>>) => void;\n\n  // @internal\n  __internal?: boolean;\n};\n\nexport type JobPayload<TJob> = TJob extends Job<Trigger<EventSpecification<infer TEvent>>, any>\n  ? TEvent\n  : never;\n\nexport type JobIO<TJob> = TJob extends Job<any, infer TIntegrations>\n  ? IOWithIntegrations<TIntegrations>\n  : never;\n\n/** A [Job](https://trigger.dev/docs/documentation/concepts/jobs) is used to define the [Trigger](https://trigger.dev/docs/documentation/concepts/triggers), metadata, and what happens when it runs. */\nexport class Job<\n  TTrigger extends Trigger<EventSpecification<any>>,\n  TIntegrations extends Record<string, TriggerIntegration> = {},\n  TOutput extends any = any,\n> {\n  readonly options: JobOptions<TTrigger, TIntegrations, TOutput>;\n\n  client?: TriggerClient;\n\n  constructor(options: JobOptions<TTrigger, TIntegrations, TOutput>) {\n    this.options = options;\n    this.#validate();\n  }\n\n  /**\n   * Attaches the job to a client. This is called automatically when you define a job using `client.defineJob()`.\n   */\n  attachToClient(client: TriggerClient) {\n    client.attach(this);\n    return this;\n  }\n\n  get id() {\n    return slugifyId(this.options.id);\n  }\n\n  get enabled() {\n    return typeof this.options.enabled === \"boolean\" ? this.options.enabled : true;\n  }\n\n  get name() {\n    return this.options.name;\n  }\n\n  get trigger() {\n    return this.options.trigger;\n  }\n\n  get version() {\n    return this.options.version;\n  }\n\n  get logLevel() {\n    return this.options.logLevel;\n  }\n\n  get integrations(): Record<string, IntegrationConfig> {\n    return Object.keys(this.options.integrations ?? {}).reduce(\n      (acc: Record<string, IntegrationConfig>, key) => {\n        const integration = this.options.integrations![key];\n\n        acc[key] = {\n          id: integration.id,\n          metadata: integration.metadata,\n          authSource: integration.authSource,\n        };\n\n        return acc;\n      },\n      {}\n    );\n  }\n\n  toJSON(): JobMetadata {\n    // @ts-ignore\n    const internal = this.options.__internal as JobMetadata[\"internal\"];\n\n    return {\n      id: this.id,\n      name: this.name,\n      version: this.version,\n      event: this.trigger.event,\n      trigger: this.trigger.toJSON(),\n      integrations: this.integrations,\n      startPosition: \"latest\", // this is deprecated, leaving this for now to make sure newer clients work with older servers\n      enabled: this.enabled,\n      preprocessRuns: this.trigger.preprocessRuns,\n      internal,\n      concurrencyLimit:\n        typeof this.options.concurrencyLimit === \"number\"\n          ? this.options.concurrencyLimit\n          : typeof this.options.concurrencyLimit === \"object\"\n          ? { id: this.options.concurrencyLimit.id, limit: this.options.concurrencyLimit.limit }\n          : undefined,\n    };\n  }\n\n  async invoke(\n    cacheKey: string,\n    payload: TriggerInvokeType<TTrigger>,\n    options?: InvokeOptions\n  ): Promise<{ id: string }>;\n  async invoke(\n    payload: TriggerInvokeType<TTrigger>,\n    options?: InvokeOptions\n  ): Promise<{ id: string }>;\n  async invoke(\n    param1: string | TriggerInvokeType<TTrigger>,\n    param2: TriggerInvokeType<TTrigger> | InvokeOptions | undefined = undefined,\n    param3: InvokeOptions | undefined = undefined\n  ): Promise<{ id: string }> {\n    const triggerClient = this.client;\n\n    if (!triggerClient) {\n      throw new Error(\n        \"Cannot invoke a job that is not attached to a client. Make sure you attach the job to a client before invoking it.\"\n      );\n    }\n\n    const runStore = runLocalStorage.getStore();\n\n    if (typeof param1 === \"string\") {\n      if (!runStore) {\n        throw new Error(\n          \"Cannot invoke a job from outside of a run when passing a cacheKey. Make sure you are running the job from within a run or use the invoke method without the cacheKey.\"\n        );\n      }\n\n      const options = param3 ?? {};\n\n      return await runStore.io.runTask(\n        param1,\n        async (task) => {\n          const result = await triggerClient.invokeJob(this.id, param2, {\n            idempotencyKey: task.idempotencyKey,\n            ...options,\n          });\n\n          task.outputProperties = [\n            {\n              label: \"Run\",\n              text: result.id,\n              url: `/orgs/${runStore.ctx.organization.slug}/projects/${runStore.ctx.project.slug}/jobs/${this.id}/runs/${result.id}/trigger`,\n            },\n          ];\n\n          return result;\n        },\n        {\n          name: `Manually Invoke '${this.name}'`,\n          params: param2,\n          properties: [\n            {\n              label: \"Job\",\n              text: this.id,\n              url: `/orgs/${runStore.ctx.organization.slug}/projects/${runStore.ctx.project.slug}/jobs/${this.id}`,\n            },\n            {\n              label: \"Env\",\n              text: runStore.ctx.environment.slug,\n            },\n          ],\n        }\n      );\n    }\n\n    if (runStore) {\n      throw new Error(\"Cannot invoke a job from within a run without a cacheKey.\");\n    }\n\n    return await triggerClient.invokeJob(this.id, param1, param2);\n  }\n\n  async invokeAndWaitForCompletion(\n    cacheKey: string | string[],\n    payload: TriggerInvokeType<TTrigger>,\n    timeoutInSeconds: number = 60 * 60, // 1 hour\n    options: Prettify<Pick<InvokeOptions, \"accountId\" | \"context\">> = {}\n  ): Promise<RunNotification<TOutput>> {\n    const triggerClient = this.client;\n\n    if (!triggerClient) {\n      throw new Error(\n        \"Cannot invoke a job that is not attached to a client. Make sure you attach the job to a client before invoking it.\"\n      );\n    }\n\n    const runStore = runLocalStorage.getStore();\n\n    if (!runStore) {\n      throw new Error(\n        \"Cannot invoke a job from outside of a run using invokeAndWaitForCompletion. Make sure you are running the job from within a run or use the invoke method instead.\"\n      );\n    }\n\n    const { io, ctx } = runStore;\n\n    return (await io.runTask(\n      cacheKey,\n      async (task) => {\n        const parsedPayload = this.trigger.event.parseInvokePayload\n          ? this.trigger.event.parseInvokePayload(payload)\n            ? payload\n            : undefined\n          : payload;\n\n        const result = await triggerClient.invokeJob(this.id, parsedPayload, {\n          idempotencyKey: task.idempotencyKey,\n          callbackUrl: task.callbackUrl ?? undefined,\n          ...options,\n        });\n\n        task.outputProperties = [\n          {\n            label: \"Run\",\n            text: result.id,\n            url: `/orgs/${ctx.organization.slug}/projects/${ctx.project.slug}/jobs/${this.id}/runs/${result.id}/trigger`,\n          },\n        ];\n\n        return {}; // we don't want to return anything here, we just want to wait for the callback\n      },\n      {\n        name: `Manually Invoke '${this.name}' and wait for completion`,\n        params: payload,\n        properties: [\n          {\n            label: \"Job\",\n            text: this.id,\n            url: `/orgs/${ctx.organization.slug}/projects/${ctx.project.slug}/jobs/${this.id}`,\n          },\n          {\n            label: \"Env\",\n            text: ctx.environment.slug,\n          },\n        ],\n        callback: {\n          enabled: true,\n          timeoutInSeconds,\n        },\n      }\n    )) as RunNotification<TOutput>;\n  }\n\n  async batchInvokeAndWaitForCompletion(\n    cacheKey: string | string[],\n    batch: Array<{\n      payload: TriggerInvokeType<TTrigger>;\n      timeoutInSeconds?: number;\n      options?: Prettify<Pick<InvokeOptions, \"accountId\" | \"context\">>;\n    }>\n  ): Promise<Array<RunNotification<TOutput>>> {\n    const runStore = runLocalStorage.getStore();\n\n    if (!runStore) {\n      throw new Error(\n        \"Cannot invoke a job from outside of a run using batchInvokeAndWaitForCompletion.\"\n      );\n    }\n\n    // If there are no items in the batch, return an empty array\n    if (batch.length === 0) {\n      return [];\n    }\n\n    // If there are too many items in the batch, throw an error\n    if (batch.length > 25) {\n      throw new Error(\n        `Cannot batch invoke more than 25 items. You tried to batch invoke ${batch.length} items.`\n      );\n    }\n\n    const { io, ctx } = runStore;\n\n    const results = await io.parallel(\n      cacheKey,\n      batch,\n      async (item, index) => {\n        return (await this.invokeAndWaitForCompletion(\n          String(index),\n          item.payload,\n          item.timeoutInSeconds ?? 60 * 60,\n          item.options\n        )) as RunNotification<{}>;\n      },\n      {\n        name: `Batch Invoke '${this.name}'`,\n        properties: [\n          {\n            label: \"Job\",\n            text: this.id,\n            url: `/orgs/${ctx.organization.slug}/projects/${ctx.project.slug}/jobs/${this.id}`,\n          },\n          {\n            label: \"Env\",\n            text: ctx.environment.slug,\n          },\n        ],\n      }\n    );\n\n    return results as Array<RunNotification<TOutput>>;\n  }\n\n  // Make sure the id is valid (must only contain alphanumeric characters and dashes)\n  // Make sure the version is valid (must be a valid semver version)\n  #validate() {\n    if (!this.version.match(/^(\\d+)\\.(\\d+)\\.(\\d+)$/)) {\n      throw new Error(\n        `Invalid job version: \"${this.version}\". Job versions must be valid semver versions.`\n      );\n    }\n  }\n}\n", "import {\n  API_VERSIONS,\n  ConnectionAuth,\n  DELIVER_WEBHOOK_REQUEST,\n  DeserializedJson,\n  EphemeralEventDispatcherRequestBody,\n  ErrorWithStackSchema,\n  FailedRunNotification,\n  GetRunOptionsWithTaskDetails,\n  GetRunsOptions,\n  HandleTriggerSource,\n  HttpEndpointRequestHeadersSchema,\n  HttpSourceRequestHeadersSchema,\n  HttpSourceResponseMetadata,\n  IndexEndpointResponse,\n  InitializeTriggerBodySchema,\n  IntegrationConfig,\n  InvokeOptions,\n  JobMetadata,\n  NormalizedResponse,\n  PreprocessRunBody,\n  PreprocessRunBodySchema,\n  Prettify,\n  REGISTER_SOURCE_EVENT_V2,\n  REGISTER_WEBHOOK,\n  RegisterSourceEventSchemaV2,\n  RegisterSourceEventV2,\n  RegisterTriggerBodyV2,\n  RegisterWebhookPayload,\n  RegisterWebhookPayloadSchema,\n  RequestWithRawBodySchema,\n  RunJobBody,\n  RunJobBodySchema,\n  RunJobErrorResponse,\n  RunJobResponse,\n  RunNotification,\n  ScheduleMetadata,\n  SendEvent,\n  SendEventOptions,\n  SourceMetadataV2,\n  StatusUpdate,\n  SuccessfulRunNotification,\n  WebhookDeliveryResponse,\n  WebhookMetadata,\n  WebhookSourceRequestHeadersSchema,\n} from \"@trigger.dev/core\";\nimport { LogLevel, Logger } from \"@trigger.dev/core-backend\";\nimport EventEmitter from \"node:events\";\nimport { env } from \"node:process\";\nimport * as packageJson from \"../package.json\";\nimport { ApiClient } from \"./apiClient\";\nimport { ConcurrencyLimit, ConcurrencyLimitOptions } from \"./concurrencyLimit\";\nimport {\n  AutoYieldExecutionError,\n  AutoYieldRateLimitError,\n  AutoYieldWithCompletedTaskExecutionError,\n  CanceledWithTaskError,\n  ErrorWithTask,\n  ParsedPayloadSchemaError,\n  ResumeWithParallelTaskError,\n  ResumeWithTaskError,\n  RetryWithTaskError,\n  YieldExecutionError,\n} from \"./errors\";\nimport { EndpointOptions, HttpEndpoint, httpEndpoint } from \"./httpEndpoint\";\nimport { TriggerIntegration } from \"./integrations\";\nimport { IO, IOStats } from \"./io\";\nimport { createIOWithIntegrations } from \"./ioWithIntegrations\";\nimport { Job, JobOptions } from \"./job\";\nimport { runLocalStorage } from \"./runLocalStorage\";\nimport { KeyValueStore } from \"./store/keyValueStore\";\nimport { DynamicTrigger, DynamicTriggerOptions } from \"./triggers/dynamic\";\nimport { EventTrigger } from \"./triggers/eventTrigger\";\nimport { ExternalSource } from \"./triggers/externalSource\";\nimport { DynamicIntervalOptions, DynamicSchedule } from \"./triggers/scheduled\";\nimport { WebhookDeliveryContext, WebhookSource } from \"./triggers/webhook\";\nimport {\n  type EventSpecification,\n  type NotificationsEventEmitter,\n  type Trigger,\n  type TriggerContext,\n  type TriggerPreprocessContext,\n  type VerifyResult,\n} from \"./types\";\nimport { formatSchemaErrors } from \"./utils/formatSchemaErrors\";\n\nconst parseRequestPayload = (rawPayload: any) => {\n  const result = RequestWithRawBodySchema.safeParse(rawPayload);\n\n  if (!result.success) {\n    throw new ParsedPayloadSchemaError(formatSchemaErrors(result.error.issues));\n  }\n\n  return new Request(new URL(result.data.url), {\n    method: result.data.method,\n    headers: result.data.headers,\n    body: result.data.rawBody,\n  });\n};\n\nconst registerWebhookEvent = (key: string): EventSpecification<RegisterWebhookPayload> => ({\n  name: `${REGISTER_WEBHOOK}.${key}`,\n  title: \"Register Webhook\",\n  source: \"internal\",\n  icon: \"webhook\",\n  parsePayload: RegisterWebhookPayloadSchema.parse,\n});\n\nconst registerSourceEvent: EventSpecification<RegisterSourceEventV2> = {\n  name: REGISTER_SOURCE_EVENT_V2,\n  title: \"Register Source\",\n  source: \"internal\",\n  icon: \"register-source\",\n  parsePayload: RegisterSourceEventSchemaV2.parse,\n};\n\nexport type TriggerClientOptions = {\n  /** The `id` property is used to uniquely identify the client.\n   */\n  id: string;\n  /** The `apiKey` property is the API Key for your Trigger.dev environment. We\n      recommend using an environment variable to store your API Key. */\n  apiKey?: string;\n  /** The `apiUrl` property is an optional property that specifies the API URL. You\n      only need to specify this if you are not using Trigger.dev Cloud and are\n      running your own Trigger.dev instance. */\n  apiUrl?: string;\n  /** The `logLevel` property is an optional property that specifies the level of\n      logging for the TriggerClient. The level is inherited by all Jobs that use this Client, unless they also specify a `logLevel`. */\n  logLevel?: LogLevel;\n  /** Very verbose log messages, defaults to false. */\n  verbose?: boolean;\n  /** Default is unset and off. If set to true it will log to the server's console as well as the Trigger.dev platform */\n  ioLogLocalEnabled?: boolean;\n};\n\nexport type AuthResolverResult = {\n  type: \"apiKey\" | \"oauth\";\n  token: string;\n  additionalFields?: Record<string, string>;\n};\n\nexport type TriggerAuthResolver = (\n  ctx: TriggerContext,\n  integration: TriggerIntegration\n) => Promise<AuthResolverResult | void | undefined>;\n\ntype WebhookVerifyFunction = (\n  request: Request,\n  client: TriggerClient,\n  ctx: WebhookDeliveryContext\n) => Promise<VerifyResult>;\n\ntype WebhookEventGeneratorFunction = (\n  request: Request,\n  client: TriggerClient,\n  ctx: WebhookDeliveryContext\n) => Promise<void>;\n\n/** A [TriggerClient](https://trigger.dev/docs/documentation/concepts/client-adaptors) is used to connect to a specific [Project](https://trigger.dev/docs/documentation/concepts/projects) by using an [API Key](https://trigger.dev/docs/documentation/concepts/environments-apikeys). */\nexport class TriggerClient {\n  #options: TriggerClientOptions;\n  #registeredJobs: Record<string, Job<Trigger<EventSpecification<any>>, any>> = {};\n  #registeredSources: Record<string, SourceMetadataV2> = {};\n  #registeredWebhooks: Record<string, WebhookMetadata> = {};\n  #registeredHttpSourceHandlers: Record<\n    string,\n    (\n      source: HandleTriggerSource,\n      request: Request\n    ) => Promise<{\n      events: Array<SendEvent>;\n      response?: NormalizedResponse;\n      metadata?: HttpSourceResponseMetadata;\n    } | void>\n  > = {};\n  #registeredWebhookSourceHandlers: Record<\n    string,\n    {\n      verify: WebhookVerifyFunction;\n      generateEvents: WebhookEventGeneratorFunction;\n    }\n  > = {};\n  #registeredDynamicTriggers: Record<\n    string,\n    DynamicTrigger<EventSpecification<any>, ExternalSource<any, any, any>>\n  > = {};\n  #jobMetadataByDynamicTriggers: Record<string, Array<{ id: string; version: string }>> = {};\n  #registeredSchedules: Record<string, Array<{ id: string; version: string }>> = {};\n  #registeredHttpEndpoints: Record<string, HttpEndpoint<EventSpecification<any>>> = {};\n  #authResolvers: Record<string, TriggerAuthResolver> = {};\n  #envStore: KeyValueStore;\n  #eventEmitter: NotificationsEventEmitter = new EventEmitter() as NotificationsEventEmitter;\n\n  #client: ApiClient;\n  #internalLogger: Logger;\n  id: string;\n\n  constructor(options: Prettify<TriggerClientOptions>) {\n    this.id = options.id;\n    this.#options = options;\n    this.#internalLogger = new Logger(\"trigger.dev\", this.#options.verbose ? \"debug\" : \"log\", [\n      \"output\",\n      \"noopTasksSet\",\n    ]);\n    this.#client = new ApiClient({\n      logLevel: this.#options.verbose ? \"debug\" : \"log\",\n      ...this.#options,\n    });\n\n    this.#envStore = new KeyValueStore(this.#client);\n  }\n\n  on = this.#eventEmitter.on.bind(this.#eventEmitter);\n\n  async handleRequest(\n    request: Request,\n    timeOrigin: number = performance.now()\n  ): Promise<NormalizedResponse> {\n    this.#internalLogger.debug(\"handling request\", {\n      url: request.url,\n      headers: Object.fromEntries(request.headers.entries()),\n      method: request.method,\n    });\n\n    const apiKey = request.headers.get(\"x-trigger-api-key\");\n    const triggerVersion = request.headers.get(\"x-trigger-version\");\n\n    const authorization = this.authorized(apiKey);\n\n    switch (authorization) {\n      case \"authorized\": {\n        break;\n      }\n      case \"missing-client\": {\n        return {\n          status: 401,\n          body: {\n            message: \"Unauthorized: client missing apiKey\",\n          },\n          headers: this.#standardResponseHeaders(timeOrigin),\n        };\n      }\n      case \"missing-header\": {\n        return {\n          status: 401,\n          body: {\n            message: \"Unauthorized: missing x-trigger-api-key header\",\n          },\n          headers: this.#standardResponseHeaders(timeOrigin),\n        };\n      }\n      case \"unauthorized\": {\n        return {\n          status: 401,\n          body: {\n            message: `Forbidden: client apiKey mismatch: Make sure you are using the correct API Key for your environment`,\n          },\n          headers: this.#standardResponseHeaders(timeOrigin),\n        };\n      }\n    }\n\n    if (request.method !== \"POST\") {\n      return {\n        status: 405,\n        body: {\n          message: \"Method not allowed (only POST is allowed)\",\n        },\n        headers: this.#standardResponseHeaders(timeOrigin),\n      };\n    }\n\n    const action = request.headers.get(\"x-trigger-action\");\n\n    if (!action) {\n      return {\n        status: 400,\n        body: {\n          message: \"Missing x-trigger-action header\",\n        },\n        headers: this.#standardResponseHeaders(timeOrigin),\n      };\n    }\n\n    switch (action) {\n      case \"PING\": {\n        const endpointId = request.headers.get(\"x-trigger-endpoint-id\");\n\n        if (!endpointId) {\n          return {\n            status: 200,\n            body: {\n              ok: false,\n              error: \"Missing endpoint ID\",\n            },\n            headers: this.#standardResponseHeaders(timeOrigin),\n          };\n        }\n\n        if (this.id !== endpointId) {\n          return {\n            status: 200,\n            body: {\n              ok: false,\n              error: `Endpoint ID mismatch error. Expected ${this.id}, got ${endpointId}`,\n            },\n            headers: this.#standardResponseHeaders(timeOrigin),\n          };\n        }\n\n        return {\n          status: 200,\n          body: {\n            ok: true,\n          },\n          headers: this.#standardResponseHeaders(timeOrigin),\n        };\n      }\n      case \"INDEX_ENDPOINT\": {\n        const body: IndexEndpointResponse = {\n          jobs: this.#buildJobsIndex(),\n          sources: Object.values(this.#registeredSources),\n          webhooks: Object.values(this.#registeredWebhooks),\n          dynamicTriggers: Object.values(this.#registeredDynamicTriggers).map((trigger) => ({\n            id: trigger.id,\n            jobs: this.#jobMetadataByDynamicTriggers[trigger.id] ?? [],\n            registerSourceJob: {\n              id: dynamicTriggerRegisterSourceJobId(trigger.id),\n              version: trigger.source.version,\n            },\n          })),\n          dynamicSchedules: Object.entries(this.#registeredSchedules).map(([id, jobs]) => ({\n            id,\n            jobs,\n          })),\n          httpEndpoints: Object.entries(this.#registeredHttpEndpoints).map(([id, endpoint]) =>\n            endpoint.toJSON()\n          ),\n        };\n\n        // if the x-trigger-job-id header is not set, we return all jobs\n        return {\n          status: 200,\n          body,\n          headers: this.#standardResponseHeaders(timeOrigin),\n        };\n      }\n      case \"INITIALIZE_TRIGGER\": {\n        const json = await request.json();\n        const body = InitializeTriggerBodySchema.safeParse(json);\n\n        if (!body.success) {\n          return {\n            status: 400,\n            body: {\n              message: \"Invalid trigger body\",\n            },\n          };\n        }\n\n        const dynamicTrigger = this.#registeredDynamicTriggers[body.data.id];\n\n        if (!dynamicTrigger) {\n          return {\n            status: 404,\n            body: {\n              message: \"Dynamic trigger not found\",\n            },\n          };\n        }\n\n        return {\n          status: 200,\n          body: dynamicTrigger.registeredTriggerForParams(body.data.params),\n          headers: this.#standardResponseHeaders(timeOrigin),\n        };\n      }\n      case \"EXECUTE_JOB\": {\n        const json = await request.json();\n        const execution = RunJobBodySchema.safeParse(json);\n\n        if (!execution.success) {\n          return {\n            status: 400,\n            body: {\n              message: \"Invalid execution\",\n            },\n          };\n        }\n\n        const job = this.#registeredJobs[execution.data.job.id];\n\n        if (!job) {\n          return {\n            status: 404,\n            body: {\n              message: \"Job not found\",\n            },\n          };\n        }\n\n        const results = await this.#executeJob(execution.data, job, timeOrigin, triggerVersion);\n\n        this.#internalLogger.debug(\"executed job\", {\n          results,\n          job: job.id,\n          version: job.version,\n          triggerVersion,\n        });\n\n        const standardHeaders = this.#standardResponseHeaders(timeOrigin);\n\n        standardHeaders[\"x-trigger-run-metadata\"] = this.#serializeRunMetadata(job);\n\n        return {\n          status: 200,\n          body: results,\n          headers: standardHeaders,\n        };\n      }\n      case \"PREPROCESS_RUN\": {\n        const json = await request.json();\n        const body = PreprocessRunBodySchema.safeParse(json);\n\n        if (!body.success) {\n          return {\n            status: 400,\n            body: {\n              message: \"Invalid body\",\n            },\n          };\n        }\n\n        const job = this.#registeredJobs[body.data.job.id];\n\n        if (!job) {\n          return {\n            status: 404,\n            body: {\n              message: \"Job not found\",\n            },\n          };\n        }\n\n        const results = await this.#preprocessRun(body.data, job);\n\n        return {\n          status: 200,\n          body: {\n            abort: results.abort,\n            properties: results.properties,\n          },\n          headers: this.#standardResponseHeaders(timeOrigin),\n        };\n      }\n      case \"DELIVER_HTTP_SOURCE_REQUEST\": {\n        const headers = HttpSourceRequestHeadersSchema.safeParse(\n          Object.fromEntries(request.headers.entries())\n        );\n\n        if (!headers.success) {\n          return {\n            status: 400,\n            body: {\n              message: \"Invalid headers\",\n            },\n          };\n        }\n\n        const sourceRequestNeedsBody = headers.data[\"x-ts-http-method\"] !== \"GET\";\n\n        const sourceRequestInit: RequestInit = {\n          method: headers.data[\"x-ts-http-method\"],\n          headers: headers.data[\"x-ts-http-headers\"],\n          body: sourceRequestNeedsBody ? request.body : undefined,\n        };\n\n        if (sourceRequestNeedsBody) {\n          try {\n            // @ts-ignore\n            sourceRequestInit.duplex = \"half\";\n          } catch (error) {\n            // ignore\n          }\n        }\n\n        const sourceRequest = new Request(headers.data[\"x-ts-http-url\"], sourceRequestInit);\n\n        const key = headers.data[\"x-ts-key\"];\n        const dynamicId = headers.data[\"x-ts-dynamic-id\"];\n        const secret = headers.data[\"x-ts-secret\"];\n        const params = headers.data[\"x-ts-params\"];\n        const data = headers.data[\"x-ts-data\"];\n        const auth = headers.data[\"x-ts-auth\"];\n        const inputMetadata = headers.data[\"x-ts-metadata\"];\n\n        const source = {\n          key,\n          dynamicId,\n          secret,\n          params,\n          data,\n          auth,\n          metadata: inputMetadata,\n        };\n\n        const { response, events, metadata } = await this.#handleHttpSourceRequest(\n          source,\n          sourceRequest\n        );\n\n        return {\n          status: 200,\n          body: {\n            events,\n            response,\n            metadata,\n          },\n          headers: this.#standardResponseHeaders(timeOrigin),\n        };\n      }\n      case \"DELIVER_HTTP_ENDPOINT_REQUEST_FOR_RESPONSE\": {\n        const headers = HttpEndpointRequestHeadersSchema.safeParse(\n          Object.fromEntries(request.headers.entries())\n        );\n\n        if (!headers.success) {\n          return {\n            status: 400,\n            body: {\n              message: \"Invalid headers\",\n            },\n          };\n        }\n\n        const sourceRequestNeedsBody = headers.data[\"x-ts-http-method\"] !== \"GET\";\n\n        const sourceRequestInit: RequestInit = {\n          method: headers.data[\"x-ts-http-method\"],\n          headers: headers.data[\"x-ts-http-headers\"],\n          body: sourceRequestNeedsBody ? request.body : undefined,\n        };\n\n        if (sourceRequestNeedsBody) {\n          try {\n            // @ts-ignore\n            sourceRequestInit.duplex = \"half\";\n          } catch (error) {\n            // ignore\n          }\n        }\n\n        const sourceRequest = new Request(headers.data[\"x-ts-http-url\"], sourceRequestInit);\n\n        const key = headers.data[\"x-ts-key\"];\n\n        const { response } = await this.#handleHttpEndpointRequestForResponse(\n          {\n            key,\n          },\n          sourceRequest\n        );\n\n        return {\n          status: 200,\n          body: response,\n          headers: this.#standardResponseHeaders(timeOrigin),\n        };\n      }\n      case \"DELIVER_WEBHOOK_REQUEST\": {\n        const headers = WebhookSourceRequestHeadersSchema.safeParse(\n          Object.fromEntries(request.headers.entries())\n        );\n\n        if (!headers.success) {\n          return {\n            status: 400,\n            body: {\n              message: \"Invalid headers\",\n            },\n          };\n        }\n\n        const sourceRequestNeedsBody = headers.data[\"x-ts-http-method\"] !== \"GET\";\n\n        const sourceRequestInit: RequestInit = {\n          method: headers.data[\"x-ts-http-method\"],\n          headers: headers.data[\"x-ts-http-headers\"],\n          body: sourceRequestNeedsBody ? request.body : undefined,\n        };\n\n        if (sourceRequestNeedsBody) {\n          try {\n            // @ts-ignore\n            sourceRequestInit.duplex = \"half\";\n          } catch (error) {\n            // ignore\n          }\n        }\n\n        const webhookRequest = new Request(headers.data[\"x-ts-http-url\"], sourceRequestInit);\n\n        const key = headers.data[\"x-ts-key\"];\n        const secret = headers.data[\"x-ts-secret\"];\n        const params = headers.data[\"x-ts-params\"];\n\n        const ctx = {\n          key,\n          secret,\n          params,\n        };\n\n        const { response, verified, error } = await this.#handleWebhookRequest(webhookRequest, ctx);\n\n        return {\n          status: 200,\n          body: {\n            response,\n            verified,\n            error,\n          },\n          headers: this.#standardResponseHeaders(timeOrigin),\n        };\n      }\n      case \"VALIDATE\": {\n        return {\n          status: 200,\n          body: {\n            ok: true,\n            endpointId: this.id,\n          },\n          headers: this.#standardResponseHeaders(timeOrigin),\n        };\n      }\n      case \"PROBE_EXECUTION_TIMEOUT\": {\n        const json = await request.json();\n        // Keep this request open for max 15 minutes so the server can detect when the function execution limit is exceeded\n        const timeout = json?.timeout ?? 15 * 60 * 1000;\n\n        await new Promise((resolve) => setTimeout(resolve, timeout));\n\n        return {\n          status: 200,\n          body: {\n            ok: true,\n          },\n          headers: this.#standardResponseHeaders(timeOrigin),\n        };\n      }\n      case \"RUN_NOTIFICATION\": {\n        const rawJson = await request.json();\n        const runNotification = rawJson as RunNotification<any>;\n\n        if (runNotification.ok) {\n          await this.#deliverSuccessfulRunNotification(runNotification);\n        } else {\n          await this.#deliverFailedRunNotification(runNotification);\n        }\n\n        return {\n          status: 200,\n          body: {\n            ok: true,\n          },\n          headers: this.#standardResponseHeaders(timeOrigin),\n        };\n      }\n    }\n\n    return {\n      status: 405,\n      body: {\n        message: \"Method not allowed\",\n      },\n      headers: this.#standardResponseHeaders(timeOrigin),\n    };\n  }\n\n  defineJob<\n    TTrigger extends Trigger<EventSpecification<any>>,\n    TIntegrations extends Record<string, TriggerIntegration> = {},\n    TOutput extends any = any,\n  >(options: JobOptions<TTrigger, TIntegrations, TOutput>) {\n    const existingRegisteredJob = this.#registeredJobs[options.id];\n\n    if (existingRegisteredJob && options.__internal !== true) {\n      console.warn(\n        `[@trigger.dev/sdk] Warning: The Job \"${existingRegisteredJob.id}\" you're attempting to define has already been defined. Please assign a different ID to the job.`\n      );\n    }\n\n    const job = new Job<TTrigger, TIntegrations, TOutput>(options);\n\n    this.attach(job);\n\n    return job;\n  }\n\n  defineAuthResolver(\n    integration: TriggerIntegration,\n    resolver: TriggerAuthResolver\n  ): TriggerClient {\n    this.#authResolvers[integration.id] = resolver;\n\n    return this;\n  }\n\n  defineDynamicSchedule(options: DynamicIntervalOptions): DynamicSchedule {\n    return new DynamicSchedule(this, options);\n  }\n\n  defineDynamicTrigger<\n    TEventSpec extends EventSpecification<any>,\n    TExternalSource extends ExternalSource<any, any, any>,\n  >(\n    options: DynamicTriggerOptions<TEventSpec, TExternalSource>\n  ): DynamicTrigger<TEventSpec, TExternalSource> {\n    return new DynamicTrigger(this, options);\n  }\n\n  /**\n   * An [HTTP endpoint](https://trigger.dev/docs/documentation/concepts/http-endpoints) allows you to create a [HTTP Trigger](https://trigger.dev/docs/documentation/concepts/triggers/http), which means you can trigger your Jobs from any webhooks.\n   * @param options The Endpoint options\n   * @returns An HTTP Endpoint, that can be used to create an HTTP Trigger.\n   * @link https://trigger.dev/docs/documentation/concepts/http-endpoints\n   */\n  defineHttpEndpoint(options: EndpointOptions, suppressWarnings = false) {\n    const existingHttpEndpoint = this.#registeredHttpEndpoints[options.id];\n    if (!suppressWarnings && existingHttpEndpoint) {\n      console.warn(\n        `[@trigger.dev/sdk] Warning: The HttpEndpoint \"${existingHttpEndpoint.id}\" you're attempting to define has already been defined. Please assign a different ID to the HttpEndpoint.`\n      );\n    }\n\n    const endpoint = httpEndpoint(options);\n    this.#registeredHttpEndpoints[endpoint.id] = endpoint;\n    return endpoint;\n  }\n\n  defineConcurrencyLimit(options: ConcurrencyLimitOptions) {\n    return new ConcurrencyLimit(options);\n  }\n\n  attach(job: Job<Trigger<any>, any>): void {\n    this.#registeredJobs[job.id] = job;\n    job.trigger.attachToJob(this, job);\n    job.client = this;\n  }\n\n  attachDynamicTrigger(trigger: DynamicTrigger<any, any>): void {\n    this.#registeredDynamicTriggers[trigger.id] = trigger;\n\n    this.defineJob({\n      id: dynamicTriggerRegisterSourceJobId(trigger.id),\n      name: `Register dynamic trigger ${trigger.id}`,\n      version: trigger.source.version,\n      trigger: new EventTrigger({\n        event: registerSourceEvent,\n        filter: { dynamicTriggerId: [trigger.id] },\n      }),\n      integrations: {\n        integration: trigger.source.integration,\n      },\n      run: async (event, io, ctx) => {\n        const updates = await trigger.source.register(event.source.params, event, io, ctx);\n\n        if (!updates) {\n          // TODO: do something here?\n          return;\n        }\n\n        return await io.updateSource(\"update-source\", {\n          key: event.source.key,\n          ...updates,\n        });\n      },\n      __internal: true,\n    });\n  }\n\n  attachJobToDynamicTrigger(job: Job<Trigger<any>, any>, trigger: DynamicTrigger<any, any>): void {\n    const jobs = this.#jobMetadataByDynamicTriggers[trigger.id] ?? [];\n\n    jobs.push({ id: job.id, version: job.version });\n\n    this.#jobMetadataByDynamicTriggers[trigger.id] = jobs;\n  }\n\n  attachSource(options: {\n    key: string;\n    source: ExternalSource<any, any>;\n    event: EventSpecification<any>;\n    params: any;\n    options?: Record<string, string[]>;\n  }): void {\n    this.#registeredHttpSourceHandlers[options.key] = async (s, r) => {\n      return await options.source.handle(s, r, this.#internalLogger);\n    };\n\n    let registeredSource = this.#registeredSources[options.key];\n\n    if (!registeredSource) {\n      registeredSource = {\n        version: \"2\",\n        channel: options.source.channel,\n        key: options.key,\n        params: options.params,\n        options: {},\n        integration: {\n          id: options.source.integration.id,\n          metadata: options.source.integration.metadata,\n          authSource: options.source.integration.authSource,\n        },\n        registerSourceJob: {\n          id: options.key,\n          version: options.source.version,\n        },\n      };\n    }\n\n    //combined the previous source options with this one, making sure to include event\n    const newOptions = deepMergeOptions(\n      {\n        event: typeof options.event.name === \"string\" ? [options.event.name] : options.event.name,\n      },\n      options.options ?? {}\n    );\n    registeredSource.options = deepMergeOptions(registeredSource.options, newOptions);\n\n    this.#registeredSources[options.key] = registeredSource;\n\n    this.defineJob({\n      id: options.key,\n      name: options.key,\n      version: options.source.version,\n      trigger: new EventTrigger({\n        event: registerSourceEvent,\n        filter: { source: { key: [options.key] } },\n      }),\n      integrations: {\n        integration: options.source.integration,\n      },\n      run: async (event, io, ctx) => {\n        const updates = await options.source.register(options.params, event, io, ctx);\n\n        if (!updates) {\n          // TODO: do something here?\n          return;\n        }\n\n        return await io.updateSource(\"update-source\", {\n          key: options.key,\n          ...updates,\n        });\n      },\n      __internal: true,\n    });\n  }\n\n  attachDynamicSchedule(key: string): void {\n    const jobs = this.#registeredSchedules[key] ?? [];\n\n    this.#registeredSchedules[key] = jobs;\n  }\n\n  attachDynamicScheduleToJob(key: string, job: Job<Trigger<any>, any>): void {\n    const jobs = this.#registeredSchedules[key] ?? [];\n\n    jobs.push({ id: job.id, version: job.version });\n\n    this.#registeredSchedules[key] = jobs;\n  }\n\n  attachWebhook<\n    TIntegration extends TriggerIntegration,\n    TParams extends any,\n    TConfig extends Record<string, string[]>,\n  >(options: {\n    key: string;\n    source: WebhookSource<TIntegration, TParams, TConfig>;\n    event: EventSpecification<any>;\n    params: any;\n    config: TConfig;\n  }): void {\n    const { source } = options;\n\n    this.#registeredWebhookSourceHandlers[options.key] = {\n      verify: source.verify.bind(source),\n      generateEvents: source.generateEvents.bind(source),\n    };\n\n    let registeredWebhook = this.#registeredWebhooks[options.key];\n\n    if (!registeredWebhook) {\n      registeredWebhook = {\n        key: options.key,\n        params: options.params,\n        config: options.config,\n        integration: {\n          id: source.integration.id,\n          metadata: source.integration.metadata,\n          authSource: source.integration.authSource,\n        },\n        httpEndpoint: {\n          id: options.key,\n        },\n      };\n    } else {\n      registeredWebhook.config = deepMergeOptions(registeredWebhook.config, options.config);\n    }\n\n    this.#registeredWebhooks[options.key] = registeredWebhook;\n\n    this.defineJob({\n      id: `webhook.register.${options.key}`,\n      name: `webhook.register.${options.key}`,\n      version: source.version,\n      trigger: new EventTrigger({\n        event: registerWebhookEvent(options.key),\n      }),\n      integrations: {\n        integration: source.integration,\n      },\n      run: async (registerPayload, io, ctx) => {\n        return await io.try(\n          async () => {\n            this.#internalLogger.debug(\"[webhook.register] Start\");\n\n            const crudOptions = {\n              io,\n              // this is just a more strongly typed payload\n              ctx: registerPayload as Parameters<(typeof source)[\"crud\"][\"create\"]>[0][\"ctx\"],\n            };\n\n            if (!registerPayload.active) {\n              this.#internalLogger.debug(\"[webhook.register] Not active, run create\");\n\n              await io.try(\n                async () => {\n                  await source.crud.create(crudOptions);\n                },\n                async (error) => {\n                  this.#internalLogger.debug(\n                    \"[webhook.register] Error during create, re-trying with delete first\",\n                    { error }\n                  );\n\n                  await io.runTask(\"create-retry\", async () => {\n                    await source.crud.delete(crudOptions);\n                    await source.crud.create(crudOptions);\n                  });\n                }\n              );\n\n              return await io.updateWebhook(\"update-webhook-success\", {\n                key: options.key,\n                active: true,\n                config: registerPayload.config.desired,\n              });\n            }\n\n            this.#internalLogger.debug(\"[webhook.register] Already active, run update\");\n\n            if (source.crud.update) {\n              await source.crud.update(crudOptions);\n            } else {\n              this.#internalLogger.debug(\n                \"[webhook.register] Run delete and create instead of update\"\n              );\n\n              await source.crud.delete(crudOptions);\n              await source.crud.create(crudOptions);\n            }\n\n            return await io.updateWebhook(\"update-webhook-success\", {\n              key: options.key,\n              active: true,\n              config: registerPayload.config.desired,\n            });\n          },\n          async (error) => {\n            this.#internalLogger.debug(\"[webhook.register] Error\", { error });\n\n            await io.updateWebhook(\"update-webhook-error\", {\n              key: options.key,\n              active: false,\n            });\n\n            throw error;\n          }\n        );\n      },\n      __internal: true,\n    });\n  }\n\n  async registerTrigger(\n    id: string,\n    key: string,\n    options: RegisterTriggerBodyV2,\n    idempotencyKey?: string\n  ) {\n    return this.#client.registerTrigger(this.id, id, key, options, idempotencyKey);\n  }\n\n  async getAuth(id: string) {\n    return this.#client.getAuth(this.id, id);\n  }\n\n  /** You can call this function from anywhere in your backend to send an event. The other way to send an event is by using [`io.sendEvent()`](https://trigger.dev/docs/sdk/io/sendevent) from inside a `run()` function.\n   * @param event The event to send.\n   * @param options Options for sending the event.\n   * @returns A promise that resolves to the event details\n   */\n  async sendEvent(event: SendEvent, options?: SendEventOptions) {\n    return this.#client.sendEvent(event, options);\n  }\n\n  /** You can call this function from anywhere in your backend to send multiple events. The other way to send multiple events is by using [`io.sendEvents()`](https://trigger.dev/docs/sdk/io/sendevents) from inside a `run()` function.\n   * @param events The events to send.\n   * @param options Options for sending the events.\n   * @returns A promise that resolves to an array of event details\n   */\n  async sendEvents(events: SendEvent[], options?: SendEventOptions) {\n    return this.#client.sendEvents(events, options);\n  }\n\n  async cancelEvent(eventId: string) {\n    return this.#client.cancelEvent(eventId);\n  }\n\n  async cancelRunsForEvent(eventId: string) {\n    return this.#client.cancelRunsForEvent(eventId);\n  }\n\n  async updateStatus(runId: string, id: string, status: StatusUpdate) {\n    return this.#client.updateStatus(runId, id, status);\n  }\n\n  async registerSchedule(id: string, key: string, schedule: ScheduleMetadata) {\n    return this.#client.registerSchedule(this.id, id, key, schedule);\n  }\n\n  async unregisterSchedule(id: string, key: string) {\n    return this.#client.unregisterSchedule(this.id, id, key);\n  }\n\n  async getEvent(eventId: string) {\n    return this.#client.getEvent(eventId);\n  }\n\n  async getRun(runId: string, options?: GetRunOptionsWithTaskDetails) {\n    return this.#client.getRun(runId, options);\n  }\n\n  async cancelRun(runId: string) {\n    return this.#client.cancelRun(runId);\n  }\n\n  async getRuns(jobSlug: string, options?: GetRunsOptions) {\n    return this.#client.getRuns(jobSlug, options);\n  }\n\n  async getRunStatuses(runId: string) {\n    return this.#client.getRunStatuses(runId);\n  }\n\n  async invokeJob(jobId: string, payload: any, options?: InvokeOptions) {\n    return this.#client.invokeJob(jobId, payload, options);\n  }\n\n  async cancelRunsForJob(jobId: string) {\n    return this.#client.cancelRunsForJob(jobId);\n  }\n\n  async createEphemeralEventDispatcher(payload: EphemeralEventDispatcherRequestBody) {\n    return this.#client.createEphemeralEventDispatcher(payload);\n  }\n\n  get store() {\n    return {\n      env: this.#envStore,\n    };\n  }\n\n  authorized(\n    apiKey?: string | null\n  ): \"authorized\" | \"unauthorized\" | \"missing-client\" | \"missing-header\" {\n    if (typeof apiKey !== \"string\") {\n      return \"missing-header\";\n    }\n\n    const localApiKey = this.#options.apiKey ?? env.TRIGGER_API_KEY;\n\n    if (!localApiKey) {\n      return \"missing-client\";\n    }\n\n    return apiKey === localApiKey ? \"authorized\" : \"unauthorized\";\n  }\n\n  apiKey() {\n    return this.#options.apiKey ?? env.TRIGGER_API_KEY;\n  }\n\n  async #preprocessRun(body: PreprocessRunBody, job: Job<Trigger<EventSpecification<any>>, any>) {\n    const context = this.#createPreprocessRunContext(body);\n\n    const parsedPayload = job.trigger.event.parsePayload(body.event.payload ?? {});\n\n    const properties = job.trigger.event.runProperties?.(parsedPayload) ?? [];\n\n    return {\n      abort: false,\n      properties,\n    };\n  }\n\n  async #executeJob(\n    body: RunJobBody,\n    job: Job<Trigger<any>, Record<string, TriggerIntegration>>,\n    timeOrigin: number,\n    triggerVersion: string | null\n  ): Promise<RunJobResponse> {\n    this.#internalLogger.debug(\"executing job\", {\n      execution: body,\n      job: job.id,\n      version: job.version,\n      triggerVersion,\n    });\n\n    const context = this.#createRunContext(body);\n\n    const io = new IO({\n      id: body.run.id,\n      jobId: job.id,\n      cachedTasks: body.tasks,\n      cachedTasksCursor: body.cachedTaskCursor,\n      yieldedExecutions: body.yieldedExecutions ?? [],\n      noopTasksSet: body.noopTasksSet,\n      apiClient: this.#client,\n      logger: this.#internalLogger,\n      client: this,\n      context,\n      jobLogLevel: job.logLevel ?? this.#options.logLevel ?? \"info\",\n      jobLogger: this.#options.ioLogLocalEnabled\n        ? new Logger(job.id, job.logLevel ?? this.#options.logLevel ?? \"info\")\n        : undefined,\n      serverVersion: triggerVersion,\n      timeOrigin,\n      executionTimeout: body.runChunkExecutionLimit,\n    });\n\n    const resolvedConnections = await this.#resolveConnections(\n      context,\n      job.options.integrations,\n      body.connections\n    );\n\n    if (!resolvedConnections.ok) {\n      return {\n        status: \"UNRESOLVED_AUTH_ERROR\",\n        issues: resolvedConnections.issues,\n      };\n    }\n\n    const ioWithConnections = createIOWithIntegrations(\n      io,\n      resolvedConnections.data,\n      job.options.integrations\n    );\n\n    try {\n      const parsedPayload = job.trigger.event.parsePayload(body.event.payload ?? {});\n\n      if (!context.run.isTest) {\n        const verified = await job.trigger.verifyPayload(parsedPayload);\n        if (!verified.success) {\n          return {\n            status: \"ERROR\",\n            error: { message: `Payload verification failed. ${verified.reason}` },\n          };\n        }\n      }\n\n      const output = await runLocalStorage.runWith({ io, ctx: context }, () => {\n        return job.options.run(parsedPayload, ioWithConnections, context);\n      });\n\n      if (this.#options.verbose) {\n        this.#logIOStats(io.stats);\n      }\n\n      return { status: \"SUCCESS\", output };\n    } catch (error) {\n      if (this.#options.verbose) {\n        this.#logIOStats(io.stats);\n      }\n\n      if (error instanceof ResumeWithParallelTaskError) {\n        return {\n          status: \"RESUME_WITH_PARALLEL_TASK\",\n          task: error.task,\n          childErrors: error.childErrors.map((childError) => {\n            return this.#convertErrorToExecutionResponse(childError, body);\n          }),\n        };\n      }\n\n      return this.#convertErrorToExecutionResponse(error, body);\n    }\n  }\n\n  #convertErrorToExecutionResponse(error: any, body: RunJobBody): RunJobErrorResponse {\n    if (error instanceof AutoYieldExecutionError) {\n      return {\n        status: \"AUTO_YIELD_EXECUTION\",\n        location: error.location,\n        timeRemaining: error.timeRemaining,\n        timeElapsed: error.timeElapsed,\n        limit: body.runChunkExecutionLimit,\n      };\n    }\n\n    if (error instanceof AutoYieldWithCompletedTaskExecutionError) {\n      return {\n        status: \"AUTO_YIELD_EXECUTION_WITH_COMPLETED_TASK\",\n        id: error.id,\n        properties: error.properties,\n        output: error.output,\n        data: {\n          ...error.data,\n          limit: body.runChunkExecutionLimit,\n        },\n      };\n    }\n\n    if (error instanceof AutoYieldRateLimitError) {\n      return {\n        status: \"AUTO_YIELD_RATE_LIMIT\",\n        reset: error.resetAtTimestamp,\n      };\n    }\n\n    if (error instanceof YieldExecutionError) {\n      return { status: \"YIELD_EXECUTION\", key: error.key };\n    }\n\n    if (error instanceof ParsedPayloadSchemaError) {\n      return { status: \"INVALID_PAYLOAD\", errors: error.schemaErrors };\n    }\n\n    if (error instanceof ResumeWithTaskError) {\n      return { status: \"RESUME_WITH_TASK\", task: error.task };\n    }\n\n    if (error instanceof RetryWithTaskError) {\n      return {\n        status: \"RETRY_WITH_TASK\",\n        task: error.task,\n        error: error.cause,\n        retryAt: error.retryAt,\n      };\n    }\n\n    if (error instanceof CanceledWithTaskError) {\n      return {\n        status: \"CANCELED\",\n        task: error.task,\n      };\n    }\n\n    if (error instanceof ErrorWithTask) {\n      const errorWithStack = ErrorWithStackSchema.safeParse(error.cause.output);\n\n      if (errorWithStack.success) {\n        return {\n          status: \"ERROR\",\n          error: errorWithStack.data,\n          task: error.cause,\n        };\n      }\n\n      return {\n        status: \"ERROR\",\n        error: { message: JSON.stringify(error.cause.output) },\n        task: error.cause,\n      };\n    }\n\n    if (error instanceof RetryWithTaskError) {\n      const errorWithStack = ErrorWithStackSchema.safeParse(error.cause);\n\n      if (errorWithStack.success) {\n        return {\n          status: \"ERROR\",\n          error: errorWithStack.data,\n          task: error.task,\n        };\n      }\n\n      return {\n        status: \"ERROR\",\n        error: { message: \"Unknown error\" },\n        task: error.task,\n      };\n    }\n\n    const errorWithStack = ErrorWithStackSchema.safeParse(error);\n\n    if (errorWithStack.success) {\n      return { status: \"ERROR\", error: errorWithStack.data };\n    }\n\n    const message = typeof error === \"string\" ? error : JSON.stringify(error);\n\n    return {\n      status: \"ERROR\",\n      error: { name: \"Unknown error\", message },\n    };\n  }\n\n  #createRunContext(execution: RunJobBody): TriggerContext {\n    const { event, organization, project, environment, job, run, source } = execution;\n\n    return {\n      event: {\n        id: event.id,\n        name: event.name,\n        context: event.context,\n        timestamp: event.timestamp,\n      },\n      organization,\n      project: project ?? { id: \"unknown\", name: \"unknown\", slug: \"unknown\" }, // backwards compat with old servers\n      environment,\n      job,\n      run,\n      account: execution.account,\n      source,\n    };\n  }\n\n  #createPreprocessRunContext(body: PreprocessRunBody): TriggerPreprocessContext {\n    const { event, organization, environment, job, run, account } = body;\n\n    return {\n      event: {\n        id: event.id,\n        name: event.name,\n        context: event.context,\n        timestamp: event.timestamp,\n      },\n      organization,\n      environment,\n      job,\n      run,\n      account,\n    };\n  }\n\n  async #handleHttpSourceRequest(\n    source: {\n      key: string;\n      dynamicId?: string;\n      secret: string;\n      data: any;\n      params: any;\n      auth?: ConnectionAuth;\n      metadata?: DeserializedJson;\n    },\n    sourceRequest: Request\n  ): Promise<{\n    response: NormalizedResponse;\n    events: SendEvent[];\n    metadata?: HttpSourceResponseMetadata;\n  }> {\n    this.#internalLogger.debug(\"Handling HTTP source request\", {\n      source,\n    });\n\n    if (source.dynamicId) {\n      const dynamicTrigger = this.#registeredDynamicTriggers[source.dynamicId];\n\n      if (!dynamicTrigger) {\n        this.#internalLogger.debug(\"No dynamic trigger registered for HTTP source\", {\n          source,\n        });\n\n        return {\n          response: {\n            status: 200,\n            body: {\n              ok: true,\n            },\n          },\n          events: [],\n        };\n      }\n\n      const results = await dynamicTrigger.source.handle(\n        source,\n        sourceRequest,\n        this.#internalLogger\n      );\n\n      if (!results) {\n        return {\n          events: [],\n          response: {\n            status: 200,\n            body: {\n              ok: true,\n            },\n          },\n        };\n      }\n\n      return {\n        events: results.events,\n        response: results.response ?? {\n          status: 200,\n          body: {\n            ok: true,\n          },\n        },\n        metadata: results.metadata,\n      };\n    }\n\n    const handler = this.#registeredHttpSourceHandlers[source.key];\n\n    if (!handler) {\n      this.#internalLogger.debug(\"No handler registered for HTTP source\", {\n        source,\n      });\n\n      return {\n        response: {\n          status: 200,\n          body: {\n            ok: true,\n          },\n        },\n        events: [],\n      };\n    }\n\n    const results = await handler(source, sourceRequest);\n\n    if (!results) {\n      return {\n        events: [],\n        response: {\n          status: 200,\n          body: {\n            ok: true,\n          },\n        },\n      };\n    }\n\n    return {\n      events: results.events,\n      response: results.response ?? {\n        status: 200,\n        body: {\n          ok: true,\n        },\n      },\n      metadata: results.metadata,\n    };\n  }\n\n  async #handleHttpEndpointRequestForResponse(\n    data: {\n      key: string;\n    },\n    sourceRequest: Request\n  ): Promise<{\n    response: NormalizedResponse;\n  }> {\n    this.#internalLogger.debug(\"Handling HTTP Endpoint request for response\", {\n      data,\n    });\n\n    const httpEndpoint = this.#registeredHttpEndpoints[data.key];\n    if (!httpEndpoint) {\n      this.#internalLogger.debug(\"No handler registered for HTTP Endpoint\", {\n        data,\n      });\n\n      return {\n        response: {\n          status: 200,\n          body: {\n            ok: true,\n          },\n        },\n      };\n    }\n\n    const handledResponse = await httpEndpoint.handleRequest(sourceRequest);\n\n    if (!handledResponse) {\n      this.#internalLogger.debug(\"There's no HTTP Endpoint respondWith.handler()\", {\n        data,\n      });\n      return {\n        response: {\n          status: 200,\n          body: {\n            ok: true,\n          },\n        },\n      };\n    }\n\n    let body: string | undefined;\n    try {\n      body = await handledResponse.text();\n    } catch (error) {\n      this.#internalLogger.error(\n        `Error reading httpEndpoint ${httpEndpoint.id} respondWith.handler Response`,\n        {\n          error,\n        }\n      );\n    }\n\n    const response = {\n      status: handledResponse.status,\n      headers: handledResponse.headers\n        ? Object.fromEntries(handledResponse.headers.entries())\n        : undefined,\n      body,\n    };\n\n    this.#internalLogger.info(`httpEndpoint ${httpEndpoint.id} respondWith.handler response`, {\n      response,\n    });\n\n    return {\n      response,\n    };\n  }\n\n  async #handleWebhookRequest(\n    request: Request,\n    ctx: WebhookDeliveryContext\n  ): Promise<WebhookDeliveryResponse> {\n    this.#internalLogger.debug(\"Handling webhook request\", {\n      ctx,\n    });\n\n    const okResponse = {\n      status: 200,\n      body: {\n        ok: true,\n      },\n    };\n\n    const handlers = this.#registeredWebhookSourceHandlers[ctx.key];\n\n    if (!handlers) {\n      this.#internalLogger.debug(\"No handler registered for webhook\", {\n        ctx,\n      });\n\n      return {\n        response: okResponse,\n        verified: false,\n      };\n    }\n\n    const { verify, generateEvents } = handlers;\n\n    const verifyResult = await verify(request, this, ctx);\n\n    if (!verifyResult.success) {\n      return {\n        response: okResponse,\n        verified: false,\n        error: verifyResult.reason,\n      };\n    }\n\n    await generateEvents(request, this, ctx);\n\n    return {\n      response: okResponse,\n      verified: true,\n    };\n  }\n\n  async #resolveConnections(\n    ctx: TriggerContext,\n    integrations?: Record<string, TriggerIntegration>,\n    connections?: Record<string, ConnectionAuth>\n  ): Promise<\n    | { ok: true; data: Record<string, ConnectionAuth> }\n    | { ok: false; issues: Record<string, { id: string; error: string }> }\n  > {\n    if (!integrations) {\n      return { ok: true, data: {} };\n    }\n\n    const resolvedAuthResults = await Promise.all(\n      Object.keys(integrations).map(async (key) => {\n        const integration = integrations[key];\n        const auth = (connections ?? {})[key];\n\n        const result = await this.#resolveConnection(ctx, integration, auth);\n\n        if (result.ok) {\n          return {\n            ok: true as const,\n            auth: result.auth,\n            key,\n          };\n        } else {\n          return {\n            ok: false as const,\n            error: result.error,\n            key,\n          };\n        }\n      })\n    );\n\n    const allResolved = resolvedAuthResults.every((result) => result.ok);\n\n    if (allResolved) {\n      return {\n        ok: true,\n        data: resolvedAuthResults.reduce((acc: Record<string, ConnectionAuth>, result) => {\n          acc[result.key] = result.auth!;\n\n          return acc;\n        }, {}),\n      };\n    } else {\n      return {\n        ok: false,\n        issues: resolvedAuthResults.reduce(\n          (acc: Record<string, { id: string; error: string }>, result) => {\n            if (result.ok) {\n              return acc;\n            }\n\n            const integration = integrations[result.key];\n\n            acc[result.key] = { id: integration.id, error: result.error };\n\n            return acc;\n          },\n          {}\n        ),\n      };\n    }\n  }\n\n  async #resolveConnection(\n    ctx: TriggerContext,\n    integration: TriggerIntegration,\n    auth?: ConnectionAuth\n  ): Promise<{ ok: true; auth: ConnectionAuth | undefined } | { ok: false; error: string }> {\n    if (auth) {\n      return { ok: true, auth };\n    }\n\n    const authResolver = this.#authResolvers[integration.id];\n\n    if (!authResolver) {\n      if (integration.authSource === \"HOSTED\") {\n        return {\n          ok: false,\n          error: `Something went wrong: Integration ${integration.id} is missing auth credentials from Trigger.dev`,\n        };\n      }\n\n      return {\n        ok: true,\n        auth: undefined,\n      };\n    }\n\n    try {\n      const resolvedAuth = await authResolver(ctx, integration);\n\n      if (!resolvedAuth) {\n        return {\n          ok: false,\n          error: `Auth could not be resolved for ${integration.id}: auth resolver returned null or undefined`,\n        };\n      }\n\n      return {\n        ok: true,\n        auth:\n          resolvedAuth.type === \"apiKey\"\n            ? {\n                type: \"apiKey\",\n                accessToken: resolvedAuth.token,\n                additionalFields: resolvedAuth.additionalFields,\n              }\n            : {\n                type: \"oauth2\",\n                accessToken: resolvedAuth.token,\n                additionalFields: resolvedAuth.additionalFields,\n              },\n      };\n    } catch (resolverError) {\n      if (resolverError instanceof Error) {\n        return {\n          ok: false,\n          error: `Auth could not be resolved for ${integration.id}: auth resolver threw. ${resolverError.name}: ${resolverError.message}`,\n        };\n      } else if (typeof resolverError === \"string\") {\n        return {\n          ok: false,\n          error: `Auth could not be resolved for ${integration.id}: auth resolver threw an error: ${resolverError}`,\n        };\n      }\n\n      return {\n        ok: false,\n        error: `Auth could not be resolved for ${\n          integration.id\n        }: auth resolver threw an unknown error: ${JSON.stringify(resolverError)}`,\n      };\n    }\n  }\n\n  #buildJobsIndex(): IndexEndpointResponse[\"jobs\"] {\n    return Object.values(this.#registeredJobs).map((job) => this.#buildJobIndex(job));\n  }\n\n  #buildJobIndex(job: Job<Trigger<any>, any>): IndexEndpointResponse[\"jobs\"][number] {\n    const internal = job.options.__internal as JobMetadata[\"internal\"];\n\n    return {\n      id: job.id,\n      name: job.name,\n      version: job.version,\n      event: job.trigger.event,\n      trigger: job.trigger.toJSON(),\n      integrations: this.#buildJobIntegrations(job),\n      startPosition: \"latest\", // job is deprecated, leaving job for now to make sure newer clients work with older servers\n      enabled: job.enabled,\n      preprocessRuns: job.trigger.preprocessRuns,\n      internal,\n      concurrencyLimit:\n        typeof job.options.concurrencyLimit === \"number\"\n          ? job.options.concurrencyLimit\n          : typeof job.options.concurrencyLimit === \"object\"\n          ? { id: job.options.concurrencyLimit.id, limit: job.options.concurrencyLimit.limit }\n          : undefined,\n    };\n  }\n\n  #buildJobIntegrations(\n    job: Job<Trigger<any>, Record<string, TriggerIntegration>>\n  ): IndexEndpointResponse[\"jobs\"][number][\"integrations\"] {\n    return Object.keys(job.options.integrations ?? {}).reduce(\n      (acc: Record<string, IntegrationConfig>, key) => {\n        const integration = job.options.integrations![key];\n\n        acc[key] = this.#buildJobIntegration(integration);\n\n        return acc;\n      },\n      {}\n    );\n  }\n\n  #buildJobIntegration(\n    integration: TriggerIntegration\n  ): IndexEndpointResponse[\"jobs\"][number][\"integrations\"][string] {\n    const authSource = this.#authResolvers[integration.id] ? \"RESOLVER\" : integration.authSource;\n\n    return {\n      id: integration.id,\n      metadata: integration.metadata,\n      authSource,\n    };\n  }\n\n  #logIOStats(stats: IOStats) {\n    this.#internalLogger.debug(\"IO stats\", {\n      stats,\n    });\n  }\n\n  #standardResponseHeaders(start: number): Record<string, string> {\n    return {\n      \"Trigger-Version\": API_VERSIONS.LAZY_LOADED_CACHED_TASKS,\n      \"Trigger-SDK-Version\": packageJson.version,\n      \"X-Trigger-Request-Timing\": `dur=${performance.now() - start / 1000.0}`,\n    };\n  }\n\n  #serializeRunMetadata(job: Job<Trigger<EventSpecification<any>>, any>) {\n    const metadata: Record<string, any> = {};\n\n    if (\n      this.#eventEmitter.listenerCount(\"runSucceeeded\") > 0 ||\n      typeof job.options.onSuccess === \"function\"\n    ) {\n      metadata[\"successSubscription\"] = true;\n    }\n\n    if (\n      this.#eventEmitter.listenerCount(\"runFailed\") > 0 ||\n      typeof job.options.onFailure === \"function\"\n    ) {\n      metadata[\"failedSubscription\"] = true;\n    }\n\n    return JSON.stringify(metadata);\n  }\n\n  async #deliverSuccessfulRunNotification(notification: SuccessfulRunNotification<any>) {\n    this.#internalLogger.debug(\"delivering successful run notification\", {\n      notification,\n    });\n\n    this.#eventEmitter.emit(\"runSucceeeded\", notification);\n\n    const job = this.#registeredJobs[notification.job.id];\n\n    if (!job) {\n      return;\n    }\n\n    if (typeof job.options.onSuccess === \"function\") {\n      await job.options.onSuccess(notification);\n    }\n  }\n\n  async #deliverFailedRunNotification(notification: FailedRunNotification) {\n    this.#internalLogger.debug(\"delivering failed run notification\", {\n      notification,\n    });\n\n    this.#eventEmitter.emit(\"runFailed\", notification);\n\n    const job = this.#registeredJobs[notification.job.id];\n\n    if (!job) {\n      return;\n    }\n\n    if (typeof job.options.onFailure === \"function\") {\n      await job.options.onFailure(notification);\n    }\n  }\n}\n\nfunction dynamicTriggerRegisterSourceJobId(id: string) {\n  return `register-dynamic-trigger-${id}`;\n}\n\ntype Options = Record<string, string[]>;\n\nfunction deepMergeOptions(obj1: Options, obj2: Options): Options {\n  const mergedOptions: Options = { ...obj1 };\n\n  for (const key in obj2) {\n    if (obj2.hasOwnProperty(key)) {\n      if (key in mergedOptions) {\n        mergedOptions[key] = [...mergedOptions[key], ...obj2[key]];\n      } else {\n        mergedOptions[key] = obj2[key];\n      }\n    }\n  }\n\n  return mergedOptions;\n}\n", "{\n  \"name\": \"@trigger.dev/sdk\",\n  \"version\": \"3.0.0-beta.56\",\n  \"description\": \"trigger.dev Node.JS SDK\",\n  \"license\": \"MIT\",\n  \"main\": \"./dist/index.js\",\n  \"types\": \"./dist/index.d.ts\",\n  \"module\": \"./dist/index.mjs\",\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"import\": {\n        \"types\": \"./dist/index.d.mts\",\n        \"default\": \"./dist/index.mjs\"\n      },\n      \"require\": \"./dist/index.js\",\n      \"types\": \"./dist/index.d.ts\"\n    },\n    \"./v3\": {\n      \"import\": {\n        \"types\": \"./dist/v3/index.d.mts\",\n        \"default\": \"./dist/v3/index.mjs\"\n      },\n      \"require\": \"./dist/v3/index.js\",\n      \"types\": \"./dist/v3/index.d.ts\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"typesVersions\": {\n    \"*\": {\n      \"v3\": [\n        \"./dist/v3/index.d.ts\"\n      ]\n    }\n  },\n  \"scripts\": {\n    \"clean\": \"rimraf dist\",\n    \"build\": \"npm run clean && npm run build:tsup\",\n    \"build:tsup\": \"tsup --dts-resolve\",\n    \"typecheck\": \"tsc --noEmit\"\n  },\n  \"dependencies\": {\n    \"@opentelemetry/api\": \"^1.8.0\",\n    \"@opentelemetry/api-logs\": \"^0.48.0\",\n    \"@opentelemetry/semantic-conventions\": \"^1.22.0\",\n    \"@trigger.dev/core\": \"workspace:3.0.0-beta.56\",\n    \"@trigger.dev/core-backend\": \"workspace:3.0.0-beta.56\",\n    \"chalk\": \"^5.2.0\",\n    \"cronstrue\": \"^2.21.0\",\n    \"debug\": \"^4.3.4\",\n    \"evt\": \"^2.4.13\",\n    \"get-caller-file\": \"^2.0.5\",\n    \"git-remote-origin-url\": \"^4.0.0\",\n    \"git-repo-info\": \"^2.1.1\",\n    \"slug\": \"^6.0.0\",\n    \"terminal-link\": \"^3.0.0\",\n    \"ulid\": \"^2.3.0\",\n    \"uuid\": \"^9.0.0\",\n    \"ws\": \"^8.11.0\",\n    \"zod\": \"3.22.3\",\n    \"msw\": \"2.2.1\"\n  },\n  \"devDependencies\": {\n    \"@trigger.dev/tsconfig\": \"workspace:*\",\n    \"@trigger.dev/tsup\": \"workspace:*\",\n    \"@types/debug\": \"^4.1.7\",\n    \"@types/node\": \"18\",\n    \"@types/slug\": \"^5.0.3\",\n    \"@types/uuid\": \"^9.0.0\",\n    \"@types/ws\": \"^8.5.3\",\n    \"encoding\": \"^0.1.13\",\n    \"msw\": \"2.2.1\",\n    \"rimraf\": \"^3.0.2\",\n    \"tsup\": \"^8.0.1\",\n    \"typed-emitter\": \"^2.1.0\",\n    \"typescript\": \"^5.3.0\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  }\n}\n", "import {\n  API_VERSIONS,\n  ApiEventLog,\n  ApiEventLogSchema,\n  CancelRunsForEventSchema,\n  CancelRunsForJobSchema,\n  CompleteTaskBodyV2Input,\n  ConnectionAuthSchema,\n  EphemeralEventDispatcherRequestBody,\n  EphemeralEventDispatcherResponseBodySchema,\n  FailTaskBodyInput,\n  GetEventSchema,\n  GetRunOptionsWithTaskDetails,\n  GetRunSchema,\n  GetRunStatusesSchema,\n  GetRunsOptions,\n  GetRunsSchema,\n  InvokeJobRequestBody,\n  InvokeJobResponseSchema,\n  InvokeOptions,\n  JobRunStatusRecordSchema,\n  KeyValueStoreResponseBody,\n  KeyValueStoreResponseBodySchema,\n  RegisterScheduleResponseBodySchema,\n  RegisterSourceEventSchemaV2,\n  RegisterSourceEventV2,\n  RegisterTriggerBodyV2,\n  RunTaskBodyInput,\n  RunTaskResponseWithCachedTasksBodySchema,\n  ScheduleMetadata,\n  SendEvent,\n  SendEventOptions,\n  ServerTaskSchema,\n  StatusUpdate,\n  TriggerSource,\n  TriggerSourceSchema,\n  UpdateTriggerSourceBodyV2,\n  UpdateWebhookBody,\n  assertExhaustive,\n  urlWithSearchParams,\n} from \"@trigger.dev/core\";\nimport { LogLevel, Logger } from \"@trigger.dev/core-backend\";\nimport { env } from \"node:process\";\n\nimport { z } from \"zod\";\nimport { KeyValueStoreClient } from \"./store/keyValueStoreClient\";\nimport { AutoYieldRateLimitError } from \"./errors\";\n\nexport type ApiClientOptions = {\n  apiKey?: string;\n  apiUrl?: string;\n  logLevel?: LogLevel;\n};\n\nexport type EndpointRecord = {\n  id: string;\n  name: string;\n  url: string;\n};\n\nexport type HttpSourceRecord = {\n  id: string;\n  key: string;\n  managed: boolean;\n  url: string;\n  status: \"PENDING\" | \"ACTIVE\" | \"INACTIVE\";\n  secret?: string;\n  data?: any;\n};\n\nexport type RunRecord = {\n  id: string;\n  jobId: string;\n  callbackUrl: string;\n  event: ApiEventLog;\n};\n\nexport class UnknownVersionError extends Error {\n  constructor(version: string) {\n    super(`Unknown version ${version}`);\n  }\n}\n\nconst MAX_RETRIES = 8;\nconst EXPONENT_FACTOR = 2;\nconst MIN_DELAY_IN_MS = 80;\nconst MAX_DELAY_IN_MS = 2000;\nconst JITTER_IN_MS = 50;\n\nexport class ApiClient {\n  #apiUrl: string;\n  #options: ApiClientOptions;\n  #logger: Logger;\n  #storeClient: KeyValueStoreClient;\n\n  constructor(options: ApiClientOptions) {\n    this.#options = options;\n\n    this.#apiUrl = this.#options.apiUrl ?? env.TRIGGER_API_URL ?? \"https://api.trigger.dev\";\n    this.#logger = new Logger(\"trigger.dev\", this.#options.logLevel);\n\n    this.#storeClient = new KeyValueStoreClient(this.#queryKeyValueStore.bind(this));\n  }\n\n  async registerEndpoint(options: { url: string; name: string }): Promise<EndpointRecord> {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Registering endpoint\", {\n      url: options.url,\n      name: options.name,\n    });\n\n    const response = await fetch(`${this.#apiUrl}/api/v1/endpoints`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${apiKey}`,\n      },\n      body: JSON.stringify({\n        url: options.url,\n        name: options.name,\n      }),\n    });\n\n    if (response.status >= 400 && response.status < 500) {\n      const body = await response.json();\n\n      throw new Error(body.error);\n    }\n\n    if (response.status !== 200) {\n      throw new Error(`Failed to register entry point, got status code ${response.status}`);\n    }\n\n    return await response.json();\n  }\n\n  async runTask(\n    runId: string,\n    task: RunTaskBodyInput,\n    options: { cachedTasksCursor?: string } = {}\n  ) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(`[ApiClient] runTask ${task.displayKey}`);\n\n    return await zodfetchWithVersions(\n      this.#logger,\n      {\n        [API_VERSIONS.LAZY_LOADED_CACHED_TASKS]: RunTaskResponseWithCachedTasksBodySchema,\n      },\n      ServerTaskSchema,\n      `${this.#apiUrl}/api/v1/runs/${runId}/tasks`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${apiKey}`,\n          \"Idempotency-Key\": task.idempotencyKey,\n          \"X-Cached-Tasks-Cursor\": options.cachedTasksCursor ?? \"\",\n          \"Trigger-Version\": API_VERSIONS.LAZY_LOADED_CACHED_TASKS,\n        },\n        body: JSON.stringify(task),\n      }\n    );\n  }\n\n  async completeTask(runId: string, id: string, task: CompleteTaskBodyV2Input) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Complete Task\", {\n      task,\n    });\n\n    return await zodfetch(\n      ServerTaskSchema,\n      `${this.#apiUrl}/api/v1/runs/${runId}/tasks/${id}/complete`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${apiKey}`,\n          \"Trigger-Version\": API_VERSIONS.SERIALIZED_TASK_OUTPUT,\n        },\n        body: JSON.stringify(task),\n      }\n    );\n  }\n\n  async failTask(runId: string, id: string, body: FailTaskBodyInput) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Fail Task\", {\n      id,\n      runId,\n      body,\n    });\n\n    return await zodfetch(\n      ServerTaskSchema,\n      `${this.#apiUrl}/api/v1/runs/${runId}/tasks/${id}/fail`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${apiKey}`,\n        },\n        body: JSON.stringify(body),\n      }\n    );\n  }\n\n  async sendEvent(event: SendEvent, options: SendEventOptions = {}) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Sending event\", {\n      event,\n    });\n\n    return await zodfetch(ApiEventLogSchema, `${this.#apiUrl}/api/v1/events`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${apiKey}`,\n      },\n      body: JSON.stringify({ event, options }),\n    });\n  }\n\n  async sendEvents(events: SendEvent[], options: SendEventOptions = {}) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Sending multiple events\", {\n      events,\n    });\n\n    return await zodfetch(ApiEventLogSchema.array(), `${this.#apiUrl}/api/v1/events/bulk`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${apiKey}`,\n      },\n      body: JSON.stringify({ events, options }),\n    });\n  }\n\n  async cancelEvent(eventId: string) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Cancelling event\", {\n      eventId,\n    });\n\n    return await zodfetch(ApiEventLogSchema, `${this.#apiUrl}/api/v1/events/${eventId}/cancel`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${apiKey}`,\n      },\n    });\n  }\n\n  async cancelRunsForEvent(eventId: string) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Cancelling runs for event\", {\n      eventId,\n    });\n\n    return await zodfetch(\n      CancelRunsForEventSchema,\n      `${this.#apiUrl}/api/v1/events/${eventId}/cancel-runs`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${apiKey}`,\n        },\n      }\n    );\n  }\n\n  async updateStatus(runId: string, id: string, status: StatusUpdate) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Update status\", {\n      id,\n      status,\n    });\n\n    return await zodfetch(\n      JobRunStatusRecordSchema,\n      `${this.#apiUrl}/api/v1/runs/${runId}/statuses/${id}`,\n      {\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${apiKey}`,\n        },\n        body: JSON.stringify(status),\n      }\n    );\n  }\n\n  async updateSource(\n    client: string,\n    key: string,\n    source: UpdateTriggerSourceBodyV2\n  ): Promise<TriggerSource> {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"activating http source\", {\n      source,\n    });\n\n    const response = await zodfetch(\n      TriggerSourceSchema,\n      `${this.#apiUrl}/api/v2/${client}/sources/${key}`,\n      {\n        method: \"PUT\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${apiKey}`,\n        },\n        body: JSON.stringify(source),\n      }\n    );\n\n    return response;\n  }\n\n  async updateWebhook(key: string, webhookData: UpdateWebhookBody): Promise<TriggerSource> {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"activating webhook\", {\n      webhookData,\n    });\n\n    const response = await zodfetch(TriggerSourceSchema, `${this.#apiUrl}/api/v1/webhooks/${key}`, {\n      method: \"PUT\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${apiKey}`,\n      },\n      body: JSON.stringify(webhookData),\n    });\n\n    return response;\n  }\n\n  async registerTrigger(\n    client: string,\n    id: string,\n    key: string,\n    payload: RegisterTriggerBodyV2,\n    idempotencyKey?: string\n  ): Promise<RegisterSourceEventV2> {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"registering trigger\", {\n      id,\n      payload,\n    });\n\n    const headers: HeadersInit = {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${apiKey}`,\n    };\n\n    if (idempotencyKey) {\n      headers[\"Idempotency-Key\"] = idempotencyKey;\n    }\n\n    const response = await zodfetch(\n      RegisterSourceEventSchemaV2,\n      `${this.#apiUrl}/api/v2/${client}/triggers/${id}/registrations/${key}`,\n      {\n        method: \"PUT\",\n        headers: headers,\n        body: JSON.stringify(payload),\n      }\n    );\n\n    return response;\n  }\n\n  async registerSchedule(client: string, id: string, key: string, payload: ScheduleMetadata) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"registering schedule\", {\n      id,\n      payload,\n    });\n\n    const response = await zodfetch(\n      RegisterScheduleResponseBodySchema,\n      `${this.#apiUrl}/api/v1/${client}/schedules/${id}/registrations`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${apiKey}`,\n        },\n        body: JSON.stringify({ id: key, ...payload }),\n      }\n    );\n\n    return response;\n  }\n\n  async unregisterSchedule(client: string, id: string, key: string) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"unregistering schedule\", {\n      id,\n    });\n\n    const response = await zodfetch(\n      z.object({ ok: z.boolean() }),\n      `${this.#apiUrl}/api/v1/${client}/schedules/${id}/registrations/${encodeURIComponent(key)}`,\n      {\n        method: \"DELETE\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${apiKey}`,\n        },\n      }\n    );\n\n    return response;\n  }\n\n  async getAuth(client: string, id: string) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"getting auth\", {\n      id,\n    });\n\n    const response = await zodfetch(\n      ConnectionAuthSchema,\n      `${this.#apiUrl}/api/v1/${client}/auth/${id}`,\n      {\n        method: \"GET\",\n        headers: {\n          Accept: \"application/json\",\n          Authorization: `Bearer ${apiKey}`,\n        },\n      },\n      {\n        optional: true,\n      }\n    );\n\n    return response;\n  }\n\n  async getEvent(eventId: string) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Getting Event\", {\n      eventId,\n    });\n\n    return await zodfetch(GetEventSchema, `${this.#apiUrl}/api/v2/events/${eventId}`, {\n      method: \"GET\",\n      headers: {\n        Authorization: `Bearer ${apiKey}`,\n      },\n    });\n  }\n\n  async getRun(runId: string, options?: GetRunOptionsWithTaskDetails) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Getting Run\", {\n      runId,\n    });\n\n    return await zodfetch(\n      GetRunSchema,\n      urlWithSearchParams(`${this.#apiUrl}/api/v2/runs/${runId}`, options),\n      {\n        method: \"GET\",\n        headers: {\n          Authorization: `Bearer ${apiKey}`,\n        },\n      }\n    );\n  }\n\n  async cancelRun(runId: string) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Cancelling Run\", {\n      runId,\n    });\n\n    return await zodfetch(GetRunSchema, `${this.#apiUrl}/api/v1/runs/${runId}/cancel`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${apiKey}`,\n      },\n    });\n  }\n\n  async getRunStatuses(runId: string) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Getting Run statuses\", {\n      runId,\n    });\n\n    return await zodfetch(GetRunStatusesSchema, `${this.#apiUrl}/api/v2/runs/${runId}/statuses`, {\n      method: \"GET\",\n      headers: {\n        Authorization: `Bearer ${apiKey}`,\n      },\n    });\n  }\n\n  async getRuns(jobSlug: string, options?: GetRunsOptions) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Getting Runs\", {\n      jobSlug,\n    });\n\n    return await zodfetch(\n      GetRunsSchema,\n      urlWithSearchParams(`${this.#apiUrl}/api/v1/jobs/${jobSlug}/runs`, options),\n      {\n        method: \"GET\",\n        headers: {\n          Authorization: `Bearer ${apiKey}`,\n        },\n      }\n    );\n  }\n\n  async invokeJob(jobId: string, payload: any, options: InvokeOptions = {}) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Invoking Job\", {\n      jobId,\n    });\n\n    const body: InvokeJobRequestBody = {\n      payload,\n      context: options.context ?? {},\n      options: {\n        accountId: options.accountId,\n        callbackUrl: options.callbackUrl,\n      },\n    };\n\n    return await zodfetch(InvokeJobResponseSchema, `${this.#apiUrl}/api/v1/jobs/${jobId}/invoke`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${apiKey}`,\n        ...(options.idempotencyKey ? { \"Idempotency-Key\": options.idempotencyKey } : {}),\n      },\n      body: JSON.stringify(body),\n    });\n  }\n\n  async cancelRunsForJob(jobId: string) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Cancelling Runs for Job\", {\n      jobId,\n    });\n\n    return await zodfetch(\n      CancelRunsForJobSchema,\n      `${this.#apiUrl}/api/v1/jobs/${jobId}/cancel-runs`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${apiKey}`,\n        },\n      }\n    );\n  }\n\n  async createEphemeralEventDispatcher(payload: EphemeralEventDispatcherRequestBody) {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"Creating ephemeral event dispatcher\", {\n      payload,\n    });\n\n    const response = await zodfetch(\n      EphemeralEventDispatcherResponseBodySchema,\n      `${this.#apiUrl}/api/v1/event-dispatchers/ephemeral`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${apiKey}`,\n        },\n        body: JSON.stringify(payload),\n      }\n    );\n\n    return response;\n  }\n\n  get store() {\n    return this.#storeClient;\n  }\n\n  async #queryKeyValueStore(\n    action: KeyValueStoreResponseBody[\"action\"],\n    data: {\n      key: string;\n      value?: string;\n    }\n  ): Promise<KeyValueStoreResponseBody> {\n    const apiKey = await this.#apiKey();\n\n    this.#logger.debug(\"accessing key-value store\", {\n      action,\n      data,\n    });\n\n    const encodedKey = encodeURIComponent(data.key);\n\n    const STORE_URL = `${this.#apiUrl}/api/v1/store/${encodedKey}`;\n\n    const authHeader: HeadersInit = {\n      Authorization: `Bearer ${apiKey}`,\n    };\n\n    let requestInit: RequestInit | undefined;\n\n    switch (action) {\n      case \"DELETE\": {\n        requestInit = {\n          method: \"DELETE\",\n          headers: authHeader,\n        };\n\n        break;\n      }\n      case \"GET\": {\n        requestInit = {\n          method: \"GET\",\n          headers: authHeader,\n        };\n\n        break;\n      }\n      case \"HAS\": {\n        const headResponse = await fetchHead(STORE_URL, {\n          headers: authHeader,\n        });\n\n        return {\n          action: \"HAS\",\n          key: encodedKey,\n          has: !!headResponse.ok,\n        };\n      }\n      case \"SET\": {\n        const MAX_BODY_BYTE_LENGTH = 256 * 1024;\n\n        if ((data.value?.length ?? 0) > MAX_BODY_BYTE_LENGTH) {\n          throw new Error(`Max request body size exceeded: ${MAX_BODY_BYTE_LENGTH} bytes`);\n        }\n\n        requestInit = {\n          method: \"PUT\",\n          headers: {\n            ...authHeader,\n            \"Content-Type\": \"text/plain\",\n          },\n          body: data.value,\n        };\n\n        break;\n      }\n      default: {\n        assertExhaustive(action);\n      }\n    }\n\n    const response = await zodfetch(KeyValueStoreResponseBodySchema, STORE_URL, requestInit);\n\n    return response;\n  }\n\n  async #apiKey() {\n    const apiKey = getApiKey(this.#options.apiKey);\n\n    if (apiKey.status === \"invalid\") {\n      throw new Error(\"Invalid API key\");\n\n      // const chalk = (await import(\"chalk\")).default;\n      // const terminalLink = (await import(\"terminal-link\")).default;\n\n      // throw new Error(\n      //   `${chalk.red(\"Trigger.dev error\")}: Invalid API key (\"${chalk.italic(\n      //     apiKey.apiKey\n      //   )}\"), please set the TRIGGER_API_KEY environment variable or pass the apiKey option to a valid value. ${terminalLink(\n      //     \"Get your API key here\",\n      //     \"https://app.trigger.dev\",\n      //     {\n      //       fallback(text, url) {\n      //         return `${text} 👉 ${url}`;\n      //       },\n      //     }\n      //   )}`\n      // );\n    } else if (apiKey.status === \"missing\") {\n      throw new Error(\"Missing API key\");\n      // const chalk = (await import(\"chalk\")).default;\n      // const terminalLink = (await import(\"terminal-link\")).default;\n\n      // throw new Error(\n      //   `${chalk.red(\n      //     \"Trigger.dev error\"\n      //   )}: Missing an API key, please set the TRIGGER_API_KEY environment variable or pass the apiKey option to the Trigger constructor. ${terminalLink(\n      //     \"Get your API key here\",\n      //     \"https://app.trigger.dev\",\n      //     {\n      //       fallback(text, url) {\n      //         return `${text} 👉 ${url}`;\n      //       },\n      //     }\n      //   )}`\n      // );\n    }\n\n    return apiKey.apiKey;\n  }\n}\n\nfunction getApiKey(key?: string) {\n  const apiKey = key ?? env.TRIGGER_API_KEY;\n\n  if (!apiKey) {\n    return { status: \"missing\" as const };\n  }\n\n  // Validate the api_key format (should be tr_{env}_XXXXX)\n  const isValid = apiKey.match(/^tr_[a-z]+_[a-zA-Z0-9]+$/);\n\n  if (!isValid) {\n    return { status: \"invalid\" as const, apiKey };\n  }\n\n  return { status: \"valid\" as const, apiKey };\n}\n\ntype VersionedResponseBodyMap = {\n  [key: string]: z.ZodTypeAny;\n};\n\n// The resulting type should be a discriminating union\n// For example, if the TVersions param is { \"2023_09_29\": z.string() } and the TUnversioned param is z.number(), the resulting type should be:\n// type VersionedResponseBody = { version: \"2023_09_29\"; body: string } | { version: \"unversioned\"; body: number }\ntype VersionedResponseBody<\n  TVersions extends VersionedResponseBodyMap,\n  TUnversioned extends z.ZodTypeAny,\n> =\n  | {\n      [TVersion in keyof TVersions]: {\n        version: TVersion;\n        body: z.infer<TVersions[TVersion]>;\n      };\n    }[keyof TVersions]\n  | {\n      version: \"unversioned\";\n      body: z.infer<TUnversioned>;\n    };\n\nasync function zodfetchWithVersions<\n  TVersionedResponseBodyMap extends VersionedResponseBodyMap,\n  TUnversionedResponseBodySchema extends z.ZodTypeAny,\n  TOptional extends boolean = false,\n>(\n  logger: Logger,\n  versionedSchemaMap: TVersionedResponseBodyMap,\n  unversionedSchema: TUnversionedResponseBodySchema,\n  url: string,\n  requestInit?: RequestInit,\n  options?: {\n    errorMessage?: string;\n    optional?: TOptional;\n  },\n  retryCount = 0\n): Promise<\n  TOptional extends true\n    ? VersionedResponseBody<TVersionedResponseBodyMap, TUnversionedResponseBodySchema> | undefined\n    : VersionedResponseBody<TVersionedResponseBodyMap, TUnversionedResponseBodySchema>\n> {\n  try {\n    const fullRequestInit = requestInitWithCache(requestInit);\n\n    const response = await fetch(url, fullRequestInit);\n\n    logger.debug(`[ApiClient] zodfetchWithVersions ${url} (attempt ${retryCount + 1})`, {\n      url,\n      retryCount,\n      requestHeaders: fullRequestInit?.headers,\n      responseHeaders: Object.fromEntries(response.headers.entries()),\n    });\n\n    if (\n      (!requestInit || requestInit.method === \"GET\") &&\n      response.status === 404 &&\n      options?.optional\n    ) {\n      // @ts-ignore\n      return;\n    }\n\n    //rate limit, so we want to reschedule\n    if (response.status === 429) {\n      //unix timestamp in milliseconds\n      const retryAfter = response.headers.get(\"x-ratelimit-reset\");\n      if (retryAfter) {\n        throw new AutoYieldRateLimitError(parseInt(retryAfter));\n      }\n    }\n\n    if (response.status >= 400 && response.status < 500) {\n      const rawBody = await safeResponseText(response);\n      const body = safeJsonParse(rawBody);\n\n      logger.error(`[ApiClient] zodfetchWithVersions failed with ${response.status}`, {\n        url,\n        retryCount,\n        requestHeaders: fullRequestInit?.headers,\n        responseHeaders: Object.fromEntries(response.headers.entries()),\n        status: response.status,\n        rawBody,\n      });\n\n      if (body && body.error) {\n        throw new Error(body.error);\n      } else {\n        throw new Error(rawBody);\n      }\n    }\n\n    if (response.status >= 500 && retryCount < MAX_RETRIES) {\n      // retry with exponential backoff and jitter\n      const delay = exponentialBackoff(retryCount + 1);\n\n      await new Promise((resolve) => setTimeout(resolve, delay));\n\n      return zodfetchWithVersions(\n        logger,\n        versionedSchemaMap,\n        unversionedSchema,\n        url,\n        requestInit,\n        options,\n        retryCount + 1\n      );\n    }\n\n    if (response.status !== 200) {\n      const rawBody = await safeResponseText(response);\n\n      logger.error(`[ApiClient] zodfetchWithVersions failed with ${response.status}`, {\n        url,\n        retryCount,\n        requestHeaders: fullRequestInit?.headers,\n        responseHeaders: Object.fromEntries(response.headers.entries()),\n        status: response.status,\n        rawBody,\n      });\n\n      throw new Error(\n        options?.errorMessage ?? `Failed to fetch ${url}, got status code ${response.status}`\n      );\n    }\n\n    const jsonBody = await response.json();\n\n    const version = response.headers.get(\"trigger-version\");\n\n    if (!version) {\n      return {\n        version: \"unversioned\",\n        body: unversionedSchema.parse(jsonBody),\n      };\n    }\n\n    const versionedSchema = versionedSchemaMap[version];\n\n    if (!versionedSchema) {\n      throw new UnknownVersionError(version);\n    }\n\n    return {\n      version,\n      body: versionedSchema.parse(jsonBody),\n    };\n  } catch (error) {\n    if (error instanceof UnknownVersionError || error instanceof AutoYieldRateLimitError) {\n      throw error;\n    }\n\n    logger.error(`[ApiClient] zodfetchWithVersions failed with a connection error`, {\n      url,\n      retryCount,\n      error,\n    });\n\n    if (retryCount < MAX_RETRIES) {\n      // retry with exponential backoff and jitter\n      const delay = exponentialBackoff(retryCount + 1);\n\n      await new Promise((resolve) => setTimeout(resolve, delay));\n\n      return zodfetchWithVersions(\n        logger,\n        versionedSchemaMap,\n        unversionedSchema,\n        url,\n        requestInit,\n        options,\n        retryCount + 1\n      );\n    }\n\n    throw error;\n  }\n}\n\nfunction requestInitWithCache(requestInit?: RequestInit): RequestInit {\n  try {\n    const withCache: RequestInit = {\n      ...requestInit,\n      cache: \"no-cache\",\n    };\n\n    const _ = new Request(\"http://localhost\", withCache);\n\n    return withCache;\n  } catch (error) {\n    return requestInit ?? {};\n  }\n}\n\nasync function fetchHead(\n  url: string,\n  requestInitWithoutMethod?: Omit<RequestInit, \"method\">,\n  retryCount = 0\n): Promise<Response> {\n  const requestInit: RequestInit = {\n    ...requestInitWithoutMethod,\n    method: \"HEAD\",\n  };\n  const response = await fetch(url, requestInitWithCache(requestInit));\n\n  if (response.status >= 500 && retryCount < MAX_RETRIES) {\n    // retry with exponential backoff and jitter\n    const delay = exponentialBackoff(retryCount + 1);\n\n    await new Promise((resolve) => setTimeout(resolve, delay));\n\n    return fetchHead(url, requestInitWithoutMethod, retryCount + 1);\n  }\n\n  return response;\n}\n\nasync function zodfetch<TResponseSchema extends z.ZodTypeAny, TOptional extends boolean = false>(\n  schema: TResponseSchema,\n  url: string,\n  requestInit?: RequestInit,\n  options?: {\n    errorMessage?: string;\n    optional?: TOptional;\n  },\n  retryCount = 0\n): Promise<\n  TOptional extends true ? z.infer<TResponseSchema> | undefined : z.infer<TResponseSchema>\n> {\n  try {\n    const response = await fetch(url, requestInitWithCache(requestInit));\n\n    if (\n      (!requestInit || requestInit.method === \"GET\") &&\n      response.status === 404 &&\n      options?.optional\n    ) {\n      // @ts-ignore\n      return;\n    }\n\n    //rate limit, so we want to reschedule\n    if (response.status === 429) {\n      //unix timestamp in milliseconds\n      const retryAfter = response.headers.get(\"x-ratelimit-reset\");\n      if (retryAfter) {\n        throw new AutoYieldRateLimitError(parseInt(retryAfter));\n      }\n    }\n\n    if (response.status >= 400 && response.status < 500) {\n      const body = await response.json();\n\n      throw new Error(body.error);\n    }\n\n    if (response.status >= 500 && retryCount < MAX_RETRIES) {\n      // retry with exponential backoff and jitter\n      const delay = exponentialBackoff(retryCount + 1);\n\n      await new Promise((resolve) => setTimeout(resolve, delay));\n\n      return zodfetch(schema, url, requestInit, options, retryCount + 1);\n    }\n\n    if (response.status !== 200) {\n      throw new Error(\n        options?.errorMessage ?? `Failed to fetch ${url}, got status code ${response.status}`\n      );\n    }\n\n    const jsonBody = await response.json();\n\n    return schema.parse(jsonBody);\n  } catch (error) {\n    if (error instanceof AutoYieldRateLimitError) {\n      throw error;\n    }\n\n    if (retryCount < MAX_RETRIES) {\n      // retry with exponential backoff and jitter\n      const delay = exponentialBackoff(retryCount + 1);\n\n      await new Promise((resolve) => setTimeout(resolve, delay));\n\n      return zodfetch(schema, url, requestInit, options, retryCount + 1);\n    }\n\n    throw error;\n  }\n}\n\n// First retry will have a delay of 80ms, second 160ms, third 320ms, etc.\nfunction exponentialBackoff(retryCount: number): number {\n  // Calculate the delay using the exponential backoff formula\n  const delay = Math.min(Math.pow(EXPONENT_FACTOR, retryCount) * MIN_DELAY_IN_MS, MAX_DELAY_IN_MS);\n\n  // Calculate the jitter\n  const jitterValue = Math.random() * JITTER_IN_MS;\n\n  // Return the calculated delay with jitter\n  return delay + jitterValue;\n}\n\nfunction safeJsonParse(rawBody: string) {\n  try {\n    return JSON.parse(rawBody);\n  } catch (error) {\n    return;\n  }\n}\n\nasync function safeResponseText(response: Response) {\n  try {\n    return await response.text();\n  } catch (error) {\n    return \"\";\n  }\n}\n", "import {\n  API_VERSIONS,\n  CachedTask,\n  CompleteTaskBodyV2Input,\n  ConnectionAuth,\n  CronOptions,\n  ErrorWithStackSchema,\n  EventFilter,\n  FetchPollOperation,\n  FetchRequestInit,\n  FetchRetryOptions,\n  FetchTimeoutOptions,\n  InitialStatusUpdate,\n  IntervalOptions,\n  RunTaskBodyInput,\n  RunTaskOptions,\n  SendEvent,\n  SendEventOptions,\n  ServerTask,\n  UpdateTriggerSourceBodyV2,\n  UpdateWebhookBody,\n  supportsFeature,\n} from \"@trigger.dev/core\";\nimport { LogLevel, Logger } from \"@trigger.dev/core-backend\";\nimport { BloomFilter } from \"@trigger.dev/core-backend\";\nimport { AsyncLocalStorage } from \"node:async_hooks\";\nimport { webcrypto } from \"node:crypto\";\nimport { ApiClient } from \"./apiClient\";\nimport {\n  AutoYieldExecutionError,\n  AutoYieldRateLimitError,\n  AutoYieldWithCompletedTaskExecutionError,\n  CanceledWithTaskError,\n  ErrorWithTask,\n  ResumeWithParallelTaskError,\n  ResumeWithTaskError,\n  RetryWithTaskError,\n  TriggerInternalError,\n  YieldExecutionError,\n  isTriggerError,\n} from \"./errors\";\nimport { IntegrationTaskKey } from \"./integrations\";\nimport { calculateRetryAt } from \"./retry\";\nimport { TriggerStatus } from \"./status\";\nimport { TriggerClient } from \"./triggerClient\";\nimport { DynamicTrigger } from \"./triggers/dynamic\";\nimport { ExternalSource, ExternalSourceParams } from \"./triggers/externalSource\";\nimport { DynamicSchedule } from \"./triggers/scheduled\";\nimport {\n  EventSpecification,\n  TaskLogger,\n  TriggerContext,\n  WaitForEventResult,\n  waitForEventSchema,\n} from \"./types\";\nimport { z } from \"zod\";\nimport { KeyValueStore } from \"./store/keyValueStore\";\nimport { Buffer } from \"node:buffer\";\n\nexport type IOTask = ServerTask;\n\nexport type IOOptions = {\n  id: string;\n  jobId: string;\n  apiClient: ApiClient;\n  client: TriggerClient;\n  context: TriggerContext;\n  timeOrigin: number;\n  logger?: Logger;\n  logLevel?: LogLevel;\n  jobLogger?: Logger;\n  jobLogLevel: LogLevel;\n  cachedTasks?: Array<CachedTask>;\n  cachedTasksCursor?: string;\n  yieldedExecutions?: Array<string>;\n  noopTasksSet?: string;\n  serverVersion?: string | null;\n  executionTimeout?: number;\n};\n\ntype JsonPrimitive = string | number | boolean | null | undefined | Date | symbol;\ntype JsonArray = Json[];\ntype JsonRecord<T> = { [Property in keyof T]: Json };\nexport type Json<T = any> = JsonPrimitive | JsonArray | JsonRecord<T>;\n\nexport type RunTaskErrorCallback = (\n  error: unknown,\n  task: IOTask,\n  io: IO\n) =>\n  | { retryAt?: Date; error?: Error; jitter?: number; skipRetrying?: boolean }\n  | Error\n  | undefined\n  | void;\n\nexport type IOStats = {\n  initialCachedTasks: number;\n  lazyLoadedCachedTasks: number;\n  executedTasks: number;\n  cachedTaskHits: number;\n  cachedTaskMisses: number;\n  noopCachedTaskHits: number;\n  noopCachedTaskMisses: number;\n};\n\nexport interface OutputSerializer {\n  serialize(value: any): string;\n  deserialize<T>(value: string): T;\n}\n\nexport class JSONOutputSerializer implements OutputSerializer {\n  serialize(value: any): string {\n    return JSON.stringify(value);\n  }\n\n  deserialize(value?: string): any {\n    return value ? JSON.parse(value) : undefined;\n  }\n}\n\nexport type BackgroundFetchResponse<T> = {\n  status: number;\n  data: T;\n  headers: Record<string, string>;\n};\n\nexport class IO {\n  private _id: string;\n  private _jobId: string;\n  private _apiClient: ApiClient;\n  private _triggerClient: TriggerClient;\n  private _logger: Logger;\n  private _jobLogger?: Logger;\n  private _jobLogLevel: LogLevel;\n  private _cachedTasks: Map<string, CachedTask>;\n  private _taskStorage: AsyncLocalStorage<{ taskId: string }>;\n  private _cachedTasksCursor?: string;\n  private _context: TriggerContext;\n  private _yieldedExecutions: Array<string>;\n  private _noopTasksBloomFilter: BloomFilter | undefined;\n  private _stats: IOStats;\n  private _serverVersion: string;\n  private _timeOrigin: number;\n  private _executionTimeout?: number;\n  private _outputSerializer: OutputSerializer = new JSONOutputSerializer();\n  private _visitedCacheKeys: Set<string> = new Set();\n\n  private _envStore: KeyValueStore;\n  private _jobStore: KeyValueStore;\n  private _runStore: KeyValueStore;\n\n  get stats() {\n    return this._stats;\n  }\n\n  constructor(options: IOOptions) {\n    this._id = options.id;\n    this._jobId = options.jobId;\n    this._apiClient = options.apiClient;\n    this._triggerClient = options.client;\n    this._logger = options.logger ?? new Logger(\"trigger.dev\", options.logLevel);\n    this._cachedTasks = new Map();\n    this._jobLogger = options.jobLogger;\n    this._jobLogLevel = options.jobLogLevel;\n    this._timeOrigin = options.timeOrigin;\n    this._executionTimeout = options.executionTimeout;\n\n    this._envStore = new KeyValueStore(options.apiClient);\n    this._jobStore = new KeyValueStore(options.apiClient, \"job\", options.jobId);\n    this._runStore = new KeyValueStore(options.apiClient, \"run\", options.id);\n\n    this._stats = {\n      initialCachedTasks: 0,\n      lazyLoadedCachedTasks: 0,\n      executedTasks: 0,\n      cachedTaskHits: 0,\n      cachedTaskMisses: 0,\n      noopCachedTaskHits: 0,\n      noopCachedTaskMisses: 0,\n    };\n\n    if (options.cachedTasks) {\n      options.cachedTasks.forEach((task) => {\n        this._cachedTasks.set(task.idempotencyKey, task);\n      });\n\n      this._stats.initialCachedTasks = options.cachedTasks.length;\n    }\n\n    this._taskStorage = new AsyncLocalStorage();\n    this._context = options.context;\n    this._yieldedExecutions = options.yieldedExecutions ?? [];\n\n    if (options.noopTasksSet) {\n      this._noopTasksBloomFilter = BloomFilter.deserialize(\n        options.noopTasksSet,\n        BloomFilter.NOOP_TASK_SET_SIZE\n      );\n    }\n\n    this._cachedTasksCursor = options.cachedTasksCursor;\n    this._serverVersion = options.serverVersion ?? \"unversioned\";\n  }\n\n  /** @internal */\n  get runId() {\n    return this._id;\n  }\n\n  /** @internal */\n  get triggerClient() {\n    return this._triggerClient;\n  }\n\n  /** Used to send log messages to the [Run log](https://trigger.dev/docs/documentation/guides/viewing-runs). */\n  get logger() {\n    return new IOLogger(async (level, message, data) => {\n      let logLevel: LogLevel = \"info\";\n\n      if (data instanceof Error) {\n        data = {\n          name: data.name,\n          message: data.message,\n          stack: data.stack,\n        };\n      }\n\n      if (Logger.satisfiesLogLevel(logLevel, this._jobLogLevel)) {\n        await this.runTask(\n          [message, level],\n          async (task) => {\n            switch (level) {\n              case \"LOG\": {\n                this._jobLogger?.log(message, data);\n                logLevel = \"log\";\n                break;\n              }\n              case \"DEBUG\": {\n                this._jobLogger?.debug(message, data);\n                logLevel = \"debug\";\n                break;\n              }\n              case \"INFO\": {\n                this._jobLogger?.info(message, data);\n                logLevel = \"info\";\n                break;\n              }\n              case \"WARN\": {\n                this._jobLogger?.warn(message, data);\n                logLevel = \"warn\";\n                break;\n              }\n              case \"ERROR\": {\n                this._jobLogger?.error(message, data);\n                logLevel = \"error\";\n                break;\n              }\n            }\n          },\n          {\n            name: \"log\",\n            icon: \"log\",\n            description: message,\n            params: data,\n            properties: [{ label: \"Level\", text: level }],\n            style: { style: \"minimal\", variant: level.toLowerCase() },\n            noop: true,\n          }\n        );\n      }\n    });\n  }\n\n  /** `io.random()` is identical to `Math.random()` when called without options but ensures your random numbers are not regenerated on resume or retry. It will return a pseudo-random floating-point number between optional `min` (default: 0, inclusive) and `max` (default: 1, exclusive). Can optionally `round` to the nearest integer.\n   * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.\n   * @param min Sets the lower bound (inclusive). Can't be higher than `max`.\n   * @param max Sets the upper bound (exclusive). Can't be lower than `min`.\n   * @param round Controls rounding to the nearest integer. Any `max` integer will become inclusive when enabled. Rounding with floating-point bounds may cause unexpected skew and boundary inclusivity.\n   */\n  async random(\n    cacheKey: string | any[],\n    {\n      min = 0,\n      max = 1,\n      round = false,\n    }: {\n      min?: number;\n      max?: number;\n      round?: boolean;\n    } = {}\n  ) {\n    return await this.runTask(\n      cacheKey,\n      async (task) => {\n        if (min > max) {\n          throw new Error(\n            `Lower bound can't be higher than upper bound - min: ${min}, max: ${max}`\n          );\n        }\n\n        if (min === max) {\n          await this.logger.warn(\n            `Lower and upper bounds are identical. The return value is not random and will always be: ${min}`\n          );\n        }\n\n        const withinBounds = (max - min) * Math.random() + min;\n\n        if (!round) {\n          return withinBounds;\n        }\n\n        if (!Number.isInteger(min) || !Number.isInteger(max)) {\n          await this.logger.warn(\n            \"Rounding enabled with floating-point bounds. This may cause unexpected skew and boundary inclusivity.\"\n          );\n        }\n\n        const rounded = Math.round(withinBounds);\n\n        return rounded;\n      },\n      {\n        name: \"random\",\n        icon: \"dice-5-filled\",\n        params: { min, max, round },\n        properties: [\n          ...(min === 0\n            ? []\n            : [\n                {\n                  label: \"min\",\n                  text: String(min),\n                },\n              ]),\n          ...(max === 1\n            ? []\n            : [\n                {\n                  label: \"max\",\n                  text: String(max),\n                },\n              ]),\n          ...(round === false\n            ? []\n            : [\n                {\n                  label: \"round\",\n                  text: String(round),\n                },\n              ]),\n        ],\n        style: { style: \"minimal\" },\n      }\n    );\n  }\n\n  /** `io.wait()` waits for the specified amount of time before continuing the Job. Delays work even if you're on a serverless platform with timeouts, or if your server goes down. They utilize [resumability](https://trigger.dev/docs/documentation/concepts/resumability) to ensure that the Run can be resumed after the delay.\n   * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.\n   * @param seconds The number of seconds to wait. This can be very long, serverless timeouts are not an issue.\n   */\n  async wait(cacheKey: string | any[], seconds: number) {\n    return await this.runTask(cacheKey, async (task) => {}, {\n      name: \"wait\",\n      icon: \"clock\",\n      params: { seconds },\n      noop: true,\n      delayUntil: new Date(Date.now() + seconds * 1000),\n      style: { style: \"minimal\" },\n    });\n  }\n\n  async waitForEvent<T extends z.ZodTypeAny = z.ZodTypeAny>(\n    cacheKey: string | any[],\n    event: {\n      name: string;\n      schema?: T;\n      filter?: EventFilter;\n      source?: string;\n      contextFilter?: EventFilter;\n      accountId?: string;\n    },\n    options?: { timeoutInSeconds?: number }\n  ): Promise<WaitForEventResult<z.output<T>>> {\n    const timeoutInSeconds = options?.timeoutInSeconds ?? 60 * 60;\n\n    return (await this.runTask(\n      cacheKey,\n      async (task, io) => {\n        if (!task.callbackUrl) {\n          throw new Error(\"No callbackUrl found on task\");\n        }\n\n        await this.triggerClient.createEphemeralEventDispatcher({\n          url: task.callbackUrl,\n          name: event.name,\n          filter: event.filter,\n          contextFilter: event.contextFilter,\n          source: event.source,\n          accountId: event.accountId,\n          timeoutInSeconds,\n        });\n\n        return {} as Promise<{}>;\n      },\n      {\n        name: \"Wait for Event\",\n        icon: \"custom-event\",\n        params: {\n          name: event.name,\n          source: event.source,\n          filter: event.filter,\n          contextFilter: event.contextFilter,\n          accountId: event.accountId,\n        },\n        callback: {\n          enabled: true,\n          timeoutInSeconds,\n        },\n        properties: [\n          {\n            label: \"Event\",\n            text: event.name,\n          },\n          {\n            label: \"Timeout\",\n            text: `${timeoutInSeconds}s`,\n          },\n          ...(event.source ? [{ label: \"Source\", text: event.source }] : []),\n          ...(event.accountId ? [{ label: \"Account ID\", text: event.accountId }] : []),\n        ],\n        parseOutput: (output) => {\n          return waitForEventSchema(event.schema ?? z.any()).parse(output);\n        },\n      }\n    )) as WaitForEventResult<z.output<T>>;\n  }\n\n  /** `io.waitForRequest()` allows you to pause the execution of a run until the url provided in the callback is POSTed to.\n   *  This is useful for integrating with external services that require a callback URL to be provided, or if you want to be able to wait until an action is performed somewhere else in your system.\n   *  @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.\n   *  @param callback A callback function that will provide the unique URL to POST to.\n   *  @param options Options for the callback.\n   *  @param options.timeoutInSeconds How long to wait for the request to be POSTed to the callback URL before timing out. Defaults to 1hr.\n   *  @returns The POSTed request JSON body.\n   *  @example\n   * ```ts\n    const result = await io.waitForRequest<{ message: string }>(\n      \"wait-for-request\",\n      async (url, task) => {\n        // Save the URL somewhere so you can POST to it later\n        // Or send it to an external service that will POST to it\n      },\n      { timeoutInSeconds: 60 } // wait 60 seconds\n    );\n    * ```\n   */\n  async waitForRequest<T extends Json<T> | unknown = unknown>(\n    cacheKey: string | any[],\n    callback: (url: string) => Promise<unknown>,\n    options?: { timeoutInSeconds?: number }\n  ): Promise<T> {\n    const timeoutInSeconds = options?.timeoutInSeconds ?? 60 * 60;\n\n    return (await this.runTask(\n      cacheKey,\n      async (task, io) => {\n        if (!task.callbackUrl) {\n          throw new Error(\"No callbackUrl found on task\");\n        }\n\n        task.outputProperties = [\n          {\n            label: \"Callback URL\",\n            text: task.callbackUrl,\n          },\n        ];\n\n        return callback(task.callbackUrl) as Promise<{}>;\n      },\n      {\n        name: \"Wait for Request\",\n        icon: \"clock\",\n        callback: {\n          enabled: true,\n          timeoutInSeconds: options?.timeoutInSeconds,\n        },\n        properties: [\n          {\n            label: \"Timeout\",\n            text: `${timeoutInSeconds}s`,\n          },\n        ],\n      }\n    )) as T;\n  }\n\n  /** `io.createStatus()` allows you to set a status with associated data during the Run. Statuses can be used by your UI using the react package \n   * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.\n   * @param initialStatus The initial status you want this status to have. You can update it during the rub using the returned object.\n   * @returns a TriggerStatus object that you can call `update()` on, to update the status.\n   * @example \n   * ```ts\n   * client.defineJob(\n  //...\n    run: async (payload, io, ctx) => {\n      const generatingImages = await io.createStatus(\"generating-images\", {\n        label: \"Generating Images\",\n        state: \"loading\",\n        data: {\n          progress: 0.1,\n        },\n      });\n\n      //...do stuff\n\n      await generatingImages.update(\"completed-generation\", {\n        label: \"Generated images\",\n        state: \"success\",\n        data: {\n          progress: 1.0,\n          urls: [\"http://...\"]\n        },\n      });\n\n    //...\n  });\n   * ```\n  */\n  async createStatus(\n    cacheKey: IntegrationTaskKey,\n    initialStatus: InitialStatusUpdate\n  ): Promise<TriggerStatus> {\n    const id = typeof cacheKey === \"string\" ? cacheKey : cacheKey.join(\"-\");\n    const status = new TriggerStatus(id, this);\n    await status.update(cacheKey, initialStatus);\n    return status;\n  }\n\n  /** `io.backgroundFetch()` fetches data from a URL that can take longer that the serverless timeout. The actual `fetch` request is performed on the Trigger.dev platform, and the response is sent back to you.\n   * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.\n   * @param url The URL to fetch from.\n   * @param requestInit The options for the request\n   * @param retry The options for retrying the request if it fails\n   * An object where the key is a status code pattern and the value is a retrying strategy.\n   * Supported patterns are:\n   * - Specific status codes: 429\n   * - Ranges: 500-599\n   * - Wildcards: 2xx, 3xx, 4xx, 5xx\n   */\n  async backgroundFetch<TResponseData>(\n    cacheKey: string | any[],\n    url: string,\n    requestInit?: FetchRequestInit,\n    options?: {\n      retry?: FetchRetryOptions;\n      timeout?: FetchTimeoutOptions;\n    }\n  ): Promise<TResponseData> {\n    const urlObject = new URL(url);\n\n    return (await this.runTask(\n      cacheKey,\n      async (task) => {\n        console.log(\"task context\", task.context);\n\n        return task.output;\n      },\n      {\n        name: `fetch ${urlObject.hostname}${urlObject.pathname}`,\n        params: { url, requestInit, retry: options?.retry, timeout: options?.timeout },\n        operation: \"fetch\",\n        icon: \"background\",\n        noop: false,\n        properties: [\n          {\n            label: \"url\",\n            text: url,\n            url,\n          },\n          {\n            label: \"method\",\n            text: requestInit?.method ?? \"GET\",\n          },\n          {\n            label: \"background\",\n            text: \"true\",\n          },\n          ...(options?.timeout\n            ? [{ label: \"timeout\", text: `${options.timeout.durationInMs}ms` }]\n            : []),\n        ],\n        retry: {\n          limit: 0,\n        },\n      }\n    )) as TResponseData;\n  }\n\n  /** `io.backgroundPoll()` will fetch data from a URL on an interval. The actual `fetch` requests are performed on the Trigger.dev server, so you don't have to worry about serverless function timeouts.\n   * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.\n   * @param params The options for the background poll\n   * @param params.url The URL to fetch from.\n   * @param params.requestInit The options for the request, like headers and method\n   * @param params.responseFilter An [EventFilter](https://trigger.dev/docs/documentation/guides/event-filter) that allows you to specify when to stop polling.\n   * @param params.interval The interval in seconds to poll the URL in seconds. Defaults to 10 seconds which is the minimum.\n   * @param params.timeout The timeout in seconds for each request in seconds. Defaults to 10 minutes. Minimum is 60 seconds and max is 1 hour\n   * @param params.requestTimeout An optional object that allows you to timeout individual fetch requests\n   * @param params.requestTimeout An optional object that allows you to timeout individual fetch requests\n   * @param params.requestTimeout.durationInMs The duration in milliseconds to timeout the request\n   * \n   * @example\n   * ```ts\n   * const result = await io.backgroundPoll<{ id: string; status: string; }>(\"poll\", {\n      url: `http://localhost:3030/api/v1/runs/${run.id}`,\n      requestInit: {\n        headers: {\n          Accept: \"application/json\",\n          Authorization: redactString`Bearer ${process.env[\"TRIGGER_API_KEY\"]!}`,\n        },\n      },\n      interval: 10,\n      timeout: 600,\n      responseFilter: {\n        status: [200],\n        body: {\n          status: [\"SUCCESS\"],\n        },\n      },\n    });\n    * ```\n   */\n  async backgroundPoll<TResponseData>(\n    cacheKey: string | any[],\n    params: FetchPollOperation\n  ): Promise<TResponseData> {\n    const urlObject = new URL(params.url);\n\n    return (await this.runTask(\n      cacheKey,\n      async (task) => {\n        return task.output;\n      },\n      {\n        name: `poll ${urlObject.hostname}${urlObject.pathname}`,\n        params,\n        operation: \"fetch-poll\",\n        icon: \"clock-bolt\",\n        noop: false,\n        properties: [\n          {\n            label: \"url\",\n            text: params.url,\n          },\n          {\n            label: \"interval\",\n            text: `${params.interval}s`,\n          },\n          {\n            label: \"timeout\",\n            text: `${params.timeout}s`,\n          },\n        ],\n        retry: {\n          limit: 0,\n        },\n      }\n    )) as TResponseData;\n  }\n\n  /** `io.backgroundFetchResponse()` fetches data from a URL that can take longer that the serverless timeout. The actual `fetch` request is performed on the Trigger.dev platform, and the response is sent back to you.\n   * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.\n   * @param url The URL to fetch from.\n   * @param requestInit The options for the request\n   * @param retry The options for retrying the request if it fails\n   * An object where the key is a status code pattern and the value is a retrying strategy.\n   * Supported patterns are:\n   * - Specific status codes: 429\n   * - Ranges: 500-599\n   * - Wildcards: 2xx, 3xx, 4xx, 5xx\n   */\n  async backgroundFetchResponse<TResponseData>(\n    cacheKey: string | any[],\n    url: string,\n    requestInit?: FetchRequestInit,\n    options?: {\n      retry?: FetchRetryOptions;\n      timeout?: FetchTimeoutOptions;\n    }\n  ): Promise<BackgroundFetchResponse<TResponseData>> {\n    const urlObject = new URL(url);\n\n    return (await this.runTask(\n      cacheKey,\n      async (task) => {\n        return task.output;\n      },\n      {\n        name: `fetch response ${urlObject.hostname}${urlObject.pathname}`,\n        params: { url, requestInit, retry: options?.retry, timeout: options?.timeout },\n        operation: \"fetch-response\",\n        icon: \"background\",\n        noop: false,\n        properties: [\n          {\n            label: \"url\",\n            text: url,\n            url,\n          },\n          {\n            label: \"method\",\n            text: requestInit?.method ?? \"GET\",\n          },\n          {\n            label: \"background\",\n            text: \"true\",\n          },\n          ...(options?.timeout\n            ? [{ label: \"timeout\", text: `${options.timeout.durationInMs}ms` }]\n            : []),\n        ],\n        retry: {\n          limit: 0,\n        },\n      }\n    )) as BackgroundFetchResponse<TResponseData>;\n  }\n\n  /** `io.sendEvent()` allows you to send an event from inside a Job run. The sent event will trigger any Jobs that are listening for that event (based on the name).\n   * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.\n   * @param event The event to send. The event name must match the name of the event that your Jobs are listening for.\n   * @param options Options for sending the event.\n   */\n  async sendEvent(cacheKey: string | any[], event: SendEvent, options?: SendEventOptions) {\n    return await this.runTask(\n      cacheKey,\n      async (task) => {\n        return await this._triggerClient.sendEvent(event, options);\n      },\n      {\n        name: \"Send Event\",\n        params: { event, options },\n        icon: \"send\",\n        properties: [\n          {\n            label: \"name\",\n            text: event.name,\n          },\n          ...(event?.id ? [{ label: \"ID\", text: event.id }] : []),\n          ...sendEventOptionsProperties(options),\n        ],\n      }\n    );\n  }\n\n  /** `io.sendEvents()` allows you to send multiple events from inside a Job run. The sent events will trigger any Jobs that are listening for those events (based on the name).\n   * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.\n   * @param event The events to send. The event names must match the names of the events that your Jobs are listening for.\n   * @param options Options for sending the events.\n   */\n  async sendEvents(cacheKey: string | any[], events: SendEvent[], options?: SendEventOptions) {\n    return await this.runTask(\n      cacheKey,\n      async (task) => {\n        return await this._triggerClient.sendEvents(events, options);\n      },\n      {\n        name: \"Send Multiple Events\",\n        params: { events, options },\n        icon: \"send\",\n        properties: [\n          {\n            label: \"Total Events\",\n            text: String(events.length),\n          },\n          ...sendEventOptionsProperties(options),\n        ],\n      }\n    );\n  }\n\n  async getEvent(cacheKey: string | any[], id: string) {\n    return await this.runTask(\n      cacheKey,\n      async (task) => {\n        return await this._triggerClient.getEvent(id);\n      },\n      {\n        name: \"getEvent\",\n        params: { id },\n        properties: [\n          {\n            label: \"id\",\n            text: id,\n          },\n        ],\n      }\n    );\n  }\n\n  /** `io.cancelEvent()` allows you to cancel an event that was previously sent with `io.sendEvent()`. This will prevent any Jobs from running that are listening for that event if the event was sent with a delay\n   * @param cacheKey\n   * @param eventId\n   * @returns\n   */\n  async cancelEvent(cacheKey: string | any[], eventId: string) {\n    return await this.runTask(\n      cacheKey,\n      async (task) => {\n        return await this._triggerClient.cancelEvent(eventId);\n      },\n      {\n        name: \"cancelEvent\",\n        params: {\n          eventId,\n        },\n        properties: [\n          {\n            label: \"id\",\n            text: eventId,\n          },\n        ],\n      }\n    );\n  }\n\n  async updateSource(\n    cacheKey: string | any[],\n    options: { key: string } & UpdateTriggerSourceBodyV2\n  ) {\n    return this.runTask(\n      cacheKey,\n      async (task) => {\n        return await this._apiClient.updateSource(this._triggerClient.id, options.key, options);\n      },\n      {\n        name: \"Update Source\",\n        description: \"Update Source\",\n        properties: [\n          {\n            label: \"key\",\n            text: options.key,\n          },\n        ],\n        params: options,\n        redact: {\n          paths: [\"secret\"],\n        },\n      }\n    );\n  }\n\n  async updateWebhook(cacheKey: string | any[], options: { key: string } & UpdateWebhookBody) {\n    return this.runTask(\n      cacheKey,\n      async (task) => {\n        return await this._apiClient.updateWebhook(options.key, options);\n      },\n      {\n        name: \"Update Webhook Source\",\n        icon: \"refresh\",\n        properties: [\n          {\n            label: \"key\",\n            text: options.key,\n          },\n        ],\n        params: options,\n      }\n    );\n  }\n\n  /** `io.registerInterval()` allows you to register a [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) that will trigger any jobs it's attached to on a regular interval.\n   * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.\n   * @param dynamicSchedule The [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) to register a new schedule on.\n   * @param id A unique id for the interval. This is used to identify and unregister the interval later.\n   * @param options The options for the interval.\n   * @returns A promise that has information about the interval.\n   * @deprecated Use `DynamicSchedule.register` instead.\n   */\n  async registerInterval(\n    cacheKey: string | any[],\n    dynamicSchedule: DynamicSchedule,\n    id: string,\n    options: IntervalOptions\n  ) {\n    return await this.runTask(\n      cacheKey,\n      async (task) => {\n        return dynamicSchedule.register(id, {\n          type: \"interval\",\n          options,\n        });\n      },\n      {\n        name: \"register-interval\",\n        properties: [\n          { label: \"schedule\", text: dynamicSchedule.id },\n          { label: \"id\", text: id },\n          { label: \"seconds\", text: options.seconds.toString() },\n        ],\n        params: options,\n      }\n    );\n  }\n\n  /** `io.unregisterInterval()` allows you to unregister a [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) that was previously registered with `io.registerInterval()`.\n   * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.\n   * @param dynamicSchedule The [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) to unregister a schedule on.\n   * @param id A unique id for the interval. This is used to identify and unregister the interval later.\n   * @deprecated Use `DynamicSchedule.unregister` instead.\n   */\n  async unregisterInterval(cacheKey: string | any[], dynamicSchedule: DynamicSchedule, id: string) {\n    return await this.runTask(\n      cacheKey,\n      async (task) => {\n        return dynamicSchedule.unregister(id);\n      },\n      {\n        name: \"unregister-interval\",\n        properties: [\n          { label: \"schedule\", text: dynamicSchedule.id },\n          { label: \"id\", text: id },\n        ],\n      }\n    );\n  }\n\n  /** `io.registerCron()` allows you to register a [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) that will trigger any jobs it's attached to on a regular CRON schedule.\n   * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.\n   * @param dynamicSchedule The [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) to register a new schedule on.\n   * @param id A unique id for the schedule. This is used to identify and unregister the schedule later.\n   * @param options The options for the CRON schedule.\n   * @deprecated Use `DynamicSchedule.register` instead.\n   */\n  async registerCron(\n    cacheKey: string | any[],\n    dynamicSchedule: DynamicSchedule,\n    id: string,\n    options: CronOptions\n  ) {\n    return await this.runTask(\n      cacheKey,\n      async (task) => {\n        return dynamicSchedule.register(id, {\n          type: \"cron\",\n          options,\n        });\n      },\n      {\n        name: \"register-cron\",\n        properties: [\n          { label: \"schedule\", text: dynamicSchedule.id },\n          { label: \"id\", text: id },\n          { label: \"cron\", text: options.cron },\n        ],\n        params: options,\n      }\n    );\n  }\n\n  /** `io.unregisterCron()` allows you to unregister a [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) that was previously registered with `io.registerCron()`.\n   * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.\n   * @param dynamicSchedule The [DynamicSchedule](https://trigger.dev/docs/sdk/dynamicschedule) to unregister a schedule on.\n   * @param id A unique id for the interval. This is used to identify and unregister the interval later.\n   * @deprecated Use `DynamicSchedule.unregister` instead.\n   */\n  async unregisterCron(cacheKey: string | any[], dynamicSchedule: DynamicSchedule, id: string) {\n    return await this.runTask(\n      cacheKey,\n      async (task) => {\n        return dynamicSchedule.unregister(id);\n      },\n      {\n        name: \"unregister-cron\",\n        properties: [\n          { label: \"schedule\", text: dynamicSchedule.id },\n          { label: \"id\", text: id },\n        ],\n      }\n    );\n  }\n\n  /** `io.registerTrigger()` allows you to register a [DynamicTrigger](https://trigger.dev/docs/sdk/dynamictrigger) with the specified trigger params.\n   * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.\n   * @param trigger The [DynamicTrigger](https://trigger.dev/docs/sdk/dynamictrigger) to register.\n   * @param id A unique id for the trigger. This is used to identify and unregister the trigger later.\n   * @param params The params for the trigger.\n   * @deprecated Use `DynamicTrigger.register` instead.\n   */\n  async registerTrigger<\n    TTrigger extends DynamicTrigger<EventSpecification<any>, ExternalSource<any, any, any>>,\n  >(\n    cacheKey: string | any[],\n    trigger: TTrigger,\n    id: string,\n    params: ExternalSourceParams<TTrigger[\"source\"]>\n  ): Promise<{ id: string; key: string } | undefined> {\n    return await this.runTask(\n      cacheKey,\n      async (task) => {\n        const registration = await this.runTask(\n          \"register-source\",\n          async (subtask1) => {\n            return trigger.register(id, params);\n          },\n          {\n            name: \"register-source\",\n          }\n        );\n\n        return {\n          id: registration.id,\n          key: registration.source.key,\n        };\n      },\n      {\n        name: \"register-trigger\",\n        properties: [\n          { label: \"trigger\", text: trigger.id },\n          { label: \"id\", text: id },\n        ],\n        params: params as any,\n      }\n    );\n  }\n\n  async getAuth(cacheKey: string | any[], clientId?: string): Promise<ConnectionAuth | undefined> {\n    if (!clientId) {\n      return;\n    }\n\n    return this.runTask(\n      cacheKey,\n      async (task) => {\n        return await this._triggerClient.getAuth(clientId);\n      },\n      { name: \"get-auth\" }\n    );\n  }\n\n  async parallel<T extends Json<T> | void, TItem>(\n    cacheKey: string | any[],\n    items: Array<TItem>,\n    callback: (item: TItem, index: number) => Promise<T>,\n    options?: Pick<RunTaskOptions, \"name\" | \"properties\">\n  ): Promise<Array<T>> {\n    const results = await this.runTask(\n      cacheKey,\n      async (task) => {\n        const outcomes = await Promise.allSettled(\n          items.map((item, index) => spaceOut(() => callback(item, index), index, 15))\n        );\n\n        // If all the outcomes are fulfilled, return the values\n        if (outcomes.every((outcome) => outcome.status === \"fulfilled\")) {\n          return outcomes.map(\n            (outcome) => (outcome as PromiseFulfilledResult<T>).value\n          ) as Array<{}>;\n        }\n\n        // If they any of the errors are non internal errors, throw the first one\n        const nonInternalErrors = outcomes\n          .filter((outcome) => outcome.status === \"rejected\" && !isTriggerError(outcome.reason))\n          .map((outcome) => outcome as PromiseRejectedResult);\n\n        if (nonInternalErrors.length > 0) {\n          throw nonInternalErrors[0].reason;\n        }\n\n        // gather all the internal errors\n        const internalErrors = outcomes\n          .filter((outcome) => outcome.status === \"rejected\" && isTriggerError(outcome.reason))\n          .map((outcome) => outcome as PromiseRejectedResult)\n          .map((outcome) => outcome.reason as TriggerInternalError);\n\n        throw new ResumeWithParallelTaskError(task, internalErrors);\n      },\n      {\n        name: \"parallel\",\n        parallel: true,\n        ...(options ?? {}),\n      }\n    );\n\n    return results as unknown as Array<T>;\n  }\n\n  /** `io.runTask()` allows you to run a [Task](https://trigger.dev/docs/documentation/concepts/tasks) from inside a Job run. A Task is a resumable unit of a Run that can be retried, resumed and is logged. [Integrations](https://trigger.dev/docs/integrations) use Tasks internally to perform their actions.\n   *\n   * @param cacheKey Should be a stable and unique key inside the `run()`. See [resumability](https://trigger.dev/docs/documentation/concepts/resumability) for more information.\n   * @param callback The callback that will be called when the Task is run. The callback receives the Task and the IO as parameters.\n   * @param options The options of how you'd like to run and log the Task.\n   * @param onError The callback that will be called when the Task fails. The callback receives the error, the Task and the IO as parameters. If you wish to retry then return an object with a `retryAt` property.\n   * @returns A Promise that resolves with the returned value of the callback.\n   */\n  async runTask<T extends Json<T> | void>(\n    cacheKey: string | any[],\n    callback: (task: ServerTask, io: IO) => Promise<T>,\n    options?: RunTaskOptions & { parseOutput?: (output: unknown) => T },\n    onError?: RunTaskErrorCallback\n  ): Promise<T> {\n    const parentId = this._taskStorage.getStore()?.taskId;\n\n    if (parentId) {\n      this._logger.debug(\"Using parent task\", {\n        parentId,\n        cacheKey,\n        options,\n      });\n    }\n\n    //don't auto-yield if it's a no-op and a subtask (e.g. a log inside a task)\n    const isSubtaskNoop = options?.noop === true && parentId !== undefined;\n    if (!isSubtaskNoop) {\n      this.#detectAutoYield(\"start_task\", 500);\n    }\n\n    const idempotencyKey = await generateIdempotencyKey(\n      [this._id, parentId ?? \"\", cacheKey].flat()\n    );\n\n    if (this._visitedCacheKeys.has(idempotencyKey)) {\n      if (typeof cacheKey === \"string\") {\n        throw new Error(\n          `Task with cacheKey \"${cacheKey}\" has already been executed in this run. Each task must have a unique cacheKey.`\n        );\n      } else {\n        throw new Error(\n          `Task with cacheKey \"${cacheKey.join(\n            \"-\"\n          )}\" has already been executed in this run. Each task must have a unique cacheKey.`\n        );\n      }\n    }\n\n    this._visitedCacheKeys.add(idempotencyKey);\n\n    const cachedTask = this._cachedTasks.get(idempotencyKey);\n\n    if (cachedTask && cachedTask.status === \"COMPLETED\") {\n      this._logger.debug(\"Using completed cached task\", {\n        idempotencyKey,\n      });\n\n      this._stats.cachedTaskHits++;\n\n      return options?.parseOutput\n        ? options.parseOutput(cachedTask.output)\n        : (cachedTask.output as T);\n    }\n\n    if (options?.noop && this._noopTasksBloomFilter) {\n      if (this._noopTasksBloomFilter.test(idempotencyKey)) {\n        this._logger.debug(\"task idempotency key exists in noopTasksBloomFilter\", {\n          idempotencyKey,\n        });\n\n        this._stats.noopCachedTaskHits++;\n\n        return {} as T;\n      }\n    }\n\n    const runOptions = { ...(options ?? {}), parseOutput: undefined };\n\n    const response = await this.#doRunTask({\n      idempotencyKey,\n      displayKey: typeof cacheKey === \"string\" ? cacheKey : undefined,\n      noop: false,\n      ...(runOptions ?? {}),\n      parentId,\n    });\n\n    if (!response) {\n      this.#forceYield(\"failed_task_run\");\n      throw new Error(\"Failed to run task\"); // this shouldn't actually happen, because forceYield will throw\n    }\n\n    const task =\n      response.version === API_VERSIONS.LAZY_LOADED_CACHED_TASKS\n        ? response.body.task\n        : response.body;\n\n    if (task.forceYield) {\n      this._logger.debug(\"Forcing yield after run task\", {\n        idempotencyKey,\n      });\n\n      this.#forceYield(\"after_run_task\");\n    }\n\n    if (response.version === API_VERSIONS.LAZY_LOADED_CACHED_TASKS) {\n      this._cachedTasksCursor = response.body.cachedTasks?.cursor;\n\n      for (const cachedTask of response.body.cachedTasks?.tasks ?? []) {\n        if (!this._cachedTasks.has(cachedTask.idempotencyKey)) {\n          this._cachedTasks.set(cachedTask.idempotencyKey, cachedTask);\n\n          this._logger.debug(\"Injecting lazy loaded task into task cache\", {\n            idempotencyKey: cachedTask.idempotencyKey,\n          });\n\n          this._stats.lazyLoadedCachedTasks++;\n        }\n      }\n    }\n\n    if (task.status === \"CANCELED\") {\n      this._logger.debug(\"Task canceled\", {\n        idempotencyKey,\n        task,\n      });\n\n      throw new CanceledWithTaskError(task);\n    }\n\n    if (task.status === \"COMPLETED\") {\n      if (task.noop) {\n        this._logger.debug(\"Noop Task completed\", {\n          idempotencyKey,\n        });\n\n        this._noopTasksBloomFilter?.add(task.idempotencyKey);\n      } else {\n        this._logger.debug(\"Cache miss\", {\n          idempotencyKey,\n        });\n\n        this._stats.cachedTaskMisses++;\n        this.#addToCachedTasks(task);\n      }\n\n      return options?.parseOutput ? options.parseOutput(task.output) : (task.output as T);\n    }\n\n    if (task.status === \"ERRORED\") {\n      this._logger.debug(\"Task errored\", {\n        idempotencyKey,\n        task,\n      });\n\n      throw new ErrorWithTask(\n        task,\n        task.error ?? task?.output ? JSON.stringify(task.output) : \"Task errored\"\n      );\n    }\n\n    this.#detectAutoYield(\"before_execute_task\", 1500);\n\n    const executeTask = async () => {\n      try {\n        const result = await callback(task, this);\n\n        if (task.status === \"WAITING\" && task.callbackUrl) {\n          this._logger.debug(\"Waiting for remote callback\", {\n            idempotencyKey,\n            task,\n          });\n          return {} as T;\n        }\n\n        const output = this._outputSerializer.serialize(result);\n\n        this._logger.debug(\"Completing using output\", {\n          idempotencyKey,\n          task,\n        });\n\n        this.#detectAutoYield(\"before_complete_task\", 500, task, output);\n\n        const completedTask = await this.#doCompleteTask(task.id, {\n          output,\n          properties: task.outputProperties ?? undefined,\n        });\n\n        if (!completedTask) {\n          this.#forceYield(\"before_complete_task\", task, output);\n          throw new Error(\"Failed to complete task\"); // this shouldn't actually happen, because forceYield will throw\n        }\n\n        if (completedTask.forceYield) {\n          this._logger.debug(\"Forcing yield after task completed\", {\n            idempotencyKey,\n          });\n\n          this.#forceYield(\"after_complete_task\");\n        }\n\n        this._stats.executedTasks++;\n\n        if (completedTask.status === \"CANCELED\") {\n          throw new CanceledWithTaskError(completedTask);\n        }\n\n        this.#detectAutoYield(\"after_complete_task\", 500);\n\n        const deserializedOutput = this._outputSerializer.deserialize<T>(output);\n\n        return options?.parseOutput ? options.parseOutput(deserializedOutput) : deserializedOutput;\n      } catch (error) {\n        if (isTriggerError(error)) {\n          throw error;\n        }\n\n        let skipRetrying = false;\n\n        if (onError) {\n          try {\n            const onErrorResult = onError(error, task, this);\n\n            if (onErrorResult) {\n              if (onErrorResult instanceof Error) {\n                error = onErrorResult;\n              } else {\n                skipRetrying = !!onErrorResult.skipRetrying;\n\n                if (onErrorResult.retryAt && !skipRetrying) {\n                  const parsedError = ErrorWithStackSchema.safeParse(onErrorResult.error);\n\n                  throw new RetryWithTaskError(\n                    parsedError.success ? parsedError.data : { message: \"Unknown error\" },\n                    task,\n                    onErrorResult.retryAt\n                  );\n                }\n              }\n            }\n          } catch (innerError) {\n            if (isTriggerError(innerError)) {\n              throw innerError;\n            }\n\n            error = innerError;\n          }\n        }\n\n        if (error instanceof ErrorWithTask) {\n          // This means a subtask errored, so we need to update the parent task and not retry it\n          await this._apiClient.failTask(this._id, task.id, {\n            error: error.cause.output as any,\n          });\n\n          throw error;\n        }\n\n        const parsedError = ErrorWithStackSchema.safeParse(error);\n\n        if (options?.retry && !skipRetrying) {\n          const retryAt = calculateRetryAt(options.retry, task.attempts - 1);\n\n          if (retryAt) {\n            throw new RetryWithTaskError(\n              parsedError.success ? parsedError.data : { message: \"Unknown error\" },\n              task,\n              retryAt\n            );\n          }\n        }\n\n        if (parsedError.success) {\n          await this._apiClient.failTask(this._id, task.id, {\n            error: parsedError.data,\n          });\n        } else {\n          const message = typeof error === \"string\" ? error : JSON.stringify(error);\n          await this._apiClient.failTask(this._id, task.id, {\n            error: { name: \"Unknown error\", message },\n          });\n        }\n\n        throw error;\n      }\n    };\n\n    if (task.status === \"WAITING\") {\n      this._logger.debug(\"Task waiting\", {\n        idempotencyKey,\n        task,\n      });\n\n      if (task.callbackUrl) {\n        await this._taskStorage.run({ taskId: task.id }, executeTask);\n      }\n\n      throw new ResumeWithTaskError(task);\n    }\n\n    if (task.status === \"RUNNING\" && typeof task.operation === \"string\") {\n      this._logger.debug(\"Task running operation\", {\n        idempotencyKey,\n        task,\n      });\n\n      throw new ResumeWithTaskError(task);\n    }\n\n    return this._taskStorage.run({ taskId: task.id }, executeTask);\n  }\n\n  /**\n   * `io.yield()` allows you to yield execution of the current run and resume it in a new function execution. Similar to `io.wait()` but does not create a task and resumes execution immediately.\n   */\n  yield(cacheKey: string) {\n    if (!supportsFeature(\"yieldExecution\", this._serverVersion)) {\n      console.warn(\n        \"[trigger.dev] io.yield() is not support by the version of the Trigger.dev server you are using, you will need to upgrade your self-hosted Trigger.dev instance.\"\n      );\n\n      return;\n    }\n\n    if (this._yieldedExecutions.includes(cacheKey)) {\n      return;\n    }\n\n    throw new YieldExecutionError(cacheKey);\n  }\n\n  /**\n   * `io.brb()` is an alias of `io.yield()`\n   */\n  brb = this.yield.bind(this);\n\n  /** `io.try()` allows you to run Tasks and catch any errors that are thrown, it's similar to a normal `try/catch` block but works with [io.runTask()](https://trigger.dev/docs/sdk/io/runtask).\n   * A regular `try/catch` block on its own won't work as expected with Tasks. Internally `runTask()` throws some special errors to control flow execution. This is necessary to deal with resumability, serverless timeouts, and retrying Tasks.\n   * @param tryCallback The code you wish to run\n   * @param catchCallback Thhis will be called if the Task fails. The callback receives the error\n   * @returns A Promise that resolves with the returned value or the error\n   */\n  async try<TResult, TCatchResult>(\n    tryCallback: () => Promise<TResult>,\n    catchCallback: (error: unknown) => Promise<TCatchResult>\n  ): Promise<TResult | TCatchResult> {\n    try {\n      return await tryCallback();\n    } catch (error) {\n      if (isTriggerError(error)) {\n        throw error;\n      }\n\n      return await catchCallback(error);\n    }\n  }\n\n  get store() {\n    return {\n      env: this._envStore,\n      job: this._jobStore,\n      run: this._runStore,\n    };\n  }\n\n  #addToCachedTasks(task: ServerTask) {\n    this._cachedTasks.set(task.idempotencyKey, task);\n  }\n\n  async #doRunTask(task: RunTaskBodyInput) {\n    try {\n      return await this._apiClient.runTask(this._id, task, {\n        cachedTasksCursor: this._cachedTasksCursor,\n      });\n    } catch (error) {\n      if (error instanceof AutoYieldRateLimitError) {\n        this._logger.debug(\"AutoYieldRateLimitError\", {\n          error,\n        });\n\n        throw error;\n      }\n\n      return;\n    }\n  }\n\n  async #doCompleteTask(id: string, task: CompleteTaskBodyV2Input) {\n    try {\n      return await this._apiClient.completeTask(this._id, id, task);\n    } catch (error) {\n      return;\n    }\n  }\n\n  #detectAutoYield(location: string, threshold: number = 1500, task?: ServerTask, output?: string) {\n    const timeRemaining = this.#getRemainingTimeInMillis();\n\n    if (timeRemaining && timeRemaining < threshold) {\n      if (task) {\n        throw new AutoYieldWithCompletedTaskExecutionError(\n          task.id,\n          task.outputProperties ?? [],\n          {\n            location,\n            timeRemaining,\n            timeElapsed: this.#getTimeElapsed(),\n          },\n          output\n        );\n      } else {\n        throw new AutoYieldExecutionError(location, timeRemaining, this.#getTimeElapsed());\n      }\n    }\n  }\n\n  #forceYield(location: string, task?: ServerTask, output?: string) {\n    const timeRemaining = this.#getRemainingTimeInMillis();\n\n    if (timeRemaining) {\n      if (task) {\n        throw new AutoYieldWithCompletedTaskExecutionError(\n          task.id,\n          task.outputProperties ?? [],\n          {\n            location,\n            timeRemaining,\n            timeElapsed: this.#getTimeElapsed(),\n          },\n          output\n        );\n      } else {\n        throw new AutoYieldExecutionError(location, timeRemaining, this.#getTimeElapsed());\n      }\n    }\n  }\n\n  #getTimeElapsed() {\n    return performance.now() - this._timeOrigin;\n  }\n\n  #getRemainingTimeInMillis() {\n    if (this._executionTimeout) {\n      return this._executionTimeout - (performance.now() - this._timeOrigin);\n    }\n\n    return undefined;\n  }\n}\n\n// Generate a stable idempotency key for the key material, using a stable json stringification\nasync function generateIdempotencyKey(keyMaterial: any[]) {\n  const keys = keyMaterial.map((key) => {\n    if (typeof key === \"string\") {\n      return key;\n    }\n\n    return stableStringify(key);\n  });\n\n  const key = keys.join(\":\");\n\n  const hash = await webcrypto.subtle.digest(\"SHA-256\", Buffer.from(key));\n\n  return Buffer.from(hash).toString(\"hex\");\n}\n\nfunction stableStringify(obj: any): string {\n  function sortKeys(obj: any): any {\n    if (typeof obj !== \"object\" || obj === null) {\n      return obj;\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(sortKeys);\n    }\n\n    const sortedKeys = Object.keys(obj).sort();\n    const sortedObj: { [key: string]: any } = {};\n\n    for (const key of sortedKeys) {\n      sortedObj[key] = sortKeys(obj[key]);\n    }\n\n    return sortedObj;\n  }\n\n  const sortedObj = sortKeys(obj);\n  return JSON.stringify(sortedObj);\n}\n\ntype CallbackFunction = (\n  level: \"DEBUG\" | \"INFO\" | \"WARN\" | \"ERROR\" | \"LOG\",\n  message: string,\n  properties?: Record<string, any>\n) => Promise<void>;\n\nexport class IOLogger implements TaskLogger {\n  constructor(private callback: CallbackFunction) {}\n\n  /** Log: essential messages */\n  log(message: string, properties?: Record<string, any>): Promise<void> {\n    return this.callback(\"LOG\", message, properties);\n  }\n\n  /** For debugging: the least important log level */\n  debug(message: string, properties?: Record<string, any>): Promise<void> {\n    return this.callback(\"DEBUG\", message, properties);\n  }\n\n  /** Info: the second least important log level */\n  info(message: string, properties?: Record<string, any>): Promise<void> {\n    return this.callback(\"INFO\", message, properties);\n  }\n\n  /** Warnings: the third most important log level  */\n  warn(message: string, properties?: Record<string, any>): Promise<void> {\n    return this.callback(\"WARN\", message, properties);\n  }\n\n  /** Error: The second most important log level */\n  error(message: string, properties?: Record<string, any>): Promise<void> {\n    return this.callback(\"ERROR\", message, properties);\n  }\n}\n\n// Space out the execution of the callback by a delay of index * delay\nasync function spaceOut<T>(callback: () => Promise<T>, index: number, delay: number): Promise<T> {\n  await new Promise((resolve) => setTimeout(resolve, index * delay));\n\n  return await callback();\n}\n\nfunction sendEventOptionsProperties(options?: SendEventOptions) {\n  return [\n    ...(options?.accountId ? [{ label: \"Account ID\", text: options.accountId }] : []),\n    ...(options?.deliverAfter\n      ? [{ label: \"Deliver After\", text: `${options.deliverAfter}s` }]\n      : []),\n    ...(options?.deliverAt ? [{ label: \"Deliver At\", text: options.deliverAt.toISOString() }] : []),\n  ];\n}\n", "import { DisplayProperty } from \"@trigger.dev/core\";\nimport { ErrorWithStack, SchemaError, ServerTask } from \"@trigger.dev/core\";\n\nexport class ResumeWithTaskError {\n  constructor(public task: ServerTask) {}\n}\n\nexport class ResumeWithParallelTaskError {\n  constructor(\n    public task: ServerTask,\n    public childErrors: Array<TriggerInternalError>\n  ) {}\n}\n\nexport class RetryWithTaskError {\n  constructor(\n    public cause: ErrorWithStack,\n    public task: ServerTask,\n    public retryAt: Date\n  ) {}\n}\n\nexport class CanceledWithTaskError {\n  constructor(public task: ServerTask) {}\n}\n\nexport class YieldExecutionError {\n  constructor(public key: string) {}\n}\n\nexport class AutoYieldExecutionError {\n  constructor(\n    public location: string,\n    public timeRemaining: number,\n    public timeElapsed: number\n  ) {}\n}\n\nexport class AutoYieldWithCompletedTaskExecutionError {\n  constructor(\n    public id: string,\n    public properties: DisplayProperty[] | undefined,\n    public data: { location: string; timeRemaining: number; timeElapsed: number },\n    public output?: string\n  ) {}\n}\n\nexport class AutoYieldRateLimitError {\n  constructor(public resetAtTimestamp: number) {}\n}\n\nexport class ParsedPayloadSchemaError {\n  constructor(public schemaErrors: SchemaError[]) {}\n}\n\nexport type TriggerInternalError =\n  | ResumeWithTaskError\n  | RetryWithTaskError\n  | CanceledWithTaskError\n  | YieldExecutionError\n  | AutoYieldExecutionError\n  | AutoYieldWithCompletedTaskExecutionError\n  | AutoYieldRateLimitError\n  | ResumeWithParallelTaskError;\n\n/** Use this function if you're using a `try/catch` block to catch errors.\n * It checks if a thrown error is a special internal error that you should ignore.\n * If this returns `true` then you must rethrow the error: `throw err;`\n * @param err The error to check\n * @returns `true` if the error is a Trigger Error, `false` otherwise.\n */\nexport function isTriggerError(err: unknown): err is TriggerInternalError {\n  return (\n    err instanceof ResumeWithTaskError ||\n    err instanceof RetryWithTaskError ||\n    err instanceof CanceledWithTaskError ||\n    err instanceof YieldExecutionError ||\n    err instanceof AutoYieldExecutionError ||\n    err instanceof AutoYieldWithCompletedTaskExecutionError ||\n    err instanceof AutoYieldRateLimitError ||\n    err instanceof ResumeWithParallelTaskError\n  );\n}\n\n// This error isn't an internal error but it can be used by the user to figure out which task caused the error\nexport class ErrorWithTask extends Error {\n  constructor(\n    public cause: ServerTask,\n    message: string\n  ) {\n    super(message);\n  }\n}\n", "import type { RetryOptions } from \"@trigger.dev/core\";\nimport { calculateRetryAt } from \"@trigger.dev/core\";\n\nexport { calculateRetryAt };\nexport type { RetryOptions };\n\nexport const retry = {\n  standardBackoff: {\n    limit: 8,\n    factor: 1.8,\n    minTimeoutInMs: 500,\n    maxTimeoutInMs: 30000,\n    randomize: true,\n  },\n  exponentialBackoff: {\n    limit: 8,\n    factor: 2,\n    minTimeoutInMs: 1000,\n    maxTimeoutInMs: 30000,\n    randomize: true,\n  },\n} as const satisfies Record<string, RetryOptions>;\n", "import { DisplayProperty, StatusUpdate } from \"@trigger.dev/core\";\nimport { IntegrationTaskKey } from \"./integrations\";\nimport { IO } from \"./io\";\n\nexport class TriggerStatus {\n  constructor(\n    private id: string,\n    private io: IO\n  ) {}\n\n  async update(key: IntegrationTaskKey, status: StatusUpdate) {\n    const properties: DisplayProperty[] = [];\n\n    if (status.label) {\n      properties.push({\n        label: \"Label\",\n        text: status.label,\n      });\n    }\n\n    if (status.state) {\n      properties.push({\n        label: \"State\",\n        text: status.state,\n      });\n    }\n\n    return await this.io.runTask(\n      key,\n      async (task) => {\n        return await this.io.triggerClient.updateStatus(this.io.runId, this.id, status);\n      },\n      {\n        name: status.label ?? `Status update`,\n        icon: \"bell\",\n        params: {\n          ...status,\n        },\n        properties,\n      }\n    );\n  }\n}\n", "import type {\n  DisplayProperty,\n  EventFilter,\n  FailedRunNotification,\n  OverridableRunTaskOptions,\n  Prettify,\n  RedactString,\n  RegisteredOptionsDiff,\n  RunTaskOptions,\n  RuntimeEnvironmentType,\n  SourceEventOption,\n  SuccessfulRunNotification,\n  TriggerMetadata,\n} from \"@trigger.dev/core\";\nimport { Logger } from \"@trigger.dev/core-backend\";\nimport type TypedEmitter from \"typed-emitter\";\nimport { z } from \"zod\";\nimport { Job } from \"./job\";\nimport { TriggerClient } from \"./triggerClient\";\n\nexport type {\n  DisplayProperty,\n  Logger,\n  OverridableRunTaskOptions,\n  Prettify,\n  RedactString,\n  RegisteredOptionsDiff,\n  RunTaskOptions,\n  SourceEventOption,\n};\n\nexport interface TriggerContext {\n  /** Job metadata */\n  job: { id: string; version: string };\n  /** Environment metadata */\n  environment: { slug: string; id: string; type: RuntimeEnvironmentType };\n  /** Organization metadata */\n  organization: { slug: string; id: string; title: string };\n  /** Project metadata */\n  project: { slug: string; id: string; name: string };\n  /** Run metadata */\n  run: { id: string; isTest: boolean; startedAt: Date; isRetry: boolean };\n  /** Event metadata */\n  event: { id: string; name: string; context: any; timestamp: Date };\n  /** Source metadata */\n  source?: { id: string; metadata?: any };\n  /** Account metadata */\n  account?: { id: string; metadata?: any };\n}\n\nexport interface TriggerPreprocessContext {\n  job: { id: string; version: string };\n  environment: { slug: string; id: string; type: RuntimeEnvironmentType };\n  organization: { slug: string; id: string; title: string };\n  run: { id: string; isTest: boolean };\n  event: { id: string; name: string; context: any; timestamp: Date };\n  account?: { id: string; metadata?: any };\n}\n\nexport interface TaskLogger {\n  debug(message: string, properties?: Record<string, any>): Promise<void>;\n  info(message: string, properties?: Record<string, any>): Promise<void>;\n  warn(message: string, properties?: Record<string, any>): Promise<void>;\n  error(message: string, properties?: Record<string, any>): Promise<void>;\n}\n\nexport type PreprocessResults = {\n  abort: boolean;\n  properties: DisplayProperty[];\n};\n\nexport type TriggerEventType<TTrigger extends Trigger<any>> = TTrigger extends Trigger<\n  infer TEventSpec\n>\n  ? ReturnType<TEventSpec[\"parsePayload\"]>\n  : never;\n\nexport type TriggerInvokeType<TTrigger extends Trigger<any>> = TTrigger extends Trigger<\n  EventSpecification<any, infer TInvoke>\n>\n  ? TInvoke\n  : any;\n\nexport type VerifyResult =\n  | {\n      success: true;\n    }\n  | {\n      success: false;\n      reason?: string;\n    };\n\nexport interface Trigger<TEventSpec extends EventSpecification<any>> {\n  event: TEventSpec;\n  toJSON(): TriggerMetadata;\n  // Attach this trigger to the job and the trigger client\n  // Gives different triggers the ability to do things like register internal jobs\n  attachToJob(triggerClient: TriggerClient, job: Job<Trigger<TEventSpec>, any>): void;\n\n  preprocessRuns: boolean;\n\n  verifyPayload: (payload: ReturnType<TEventSpec[\"parsePayload\"]>) => Promise<VerifyResult>;\n}\n\nexport type TriggerPayload<TTrigger> = TTrigger extends Trigger<EventSpecification<infer TEvent>>\n  ? TEvent\n  : never;\n\nexport const EventSpecificationExampleSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  icon: z.string().optional(),\n  payload: z.any(),\n});\n\nexport type EventSpecificationExample = z.infer<typeof EventSpecificationExampleSchema>;\n\nexport type TypedEventSpecificationExample<TEvent> = {\n  id: string;\n  name: string;\n  icon?: string;\n  payload: TEvent;\n};\n\nexport interface EventSpecification<TEvent extends any, TInvoke extends any = TEvent> {\n  name: string | string[];\n  title: string;\n  source: string;\n  icon: string;\n  properties?: DisplayProperty[];\n  schema?: any;\n  examples?: Array<EventSpecificationExample>;\n  filter?: EventFilter;\n  parsePayload: (payload: unknown) => TEvent;\n  parseInvokePayload?: (payload: unknown) => TInvoke;\n  runProperties?: (payload: TEvent) => DisplayProperty[];\n}\n\nexport type EventTypeFromSpecification<TEventSpec extends EventSpecification<any>> =\n  TEventSpec extends EventSpecification<infer TEvent> ? TEvent : never;\n\nexport type SchemaParserIssue = { path: PropertyKey[]; message: string };\n\nexport type SchemaParserResult<T> =\n  | {\n      success: true;\n      data: T;\n    }\n  | { success: false; error: { issues: SchemaParserIssue[] } };\n\nexport type SchemaParser<T extends unknown = unknown> = {\n  safeParse: (a: unknown) => SchemaParserResult<T>;\n};\n\nexport type WaitForEventResult<TEvent> = {\n  id: string;\n  name: string;\n  source: string;\n  payload: TEvent;\n  timestamp: Date;\n  context?: any;\n  accountId?: string;\n};\n\nexport function waitForEventSchema(schema: z.ZodTypeAny) {\n  return z.object({\n    id: z.string(),\n    name: z.string(),\n    source: z.string(),\n    payload: schema,\n    timestamp: z.coerce.date(),\n    context: z.any().optional(),\n    accountId: z.string().optional(),\n  });\n}\n\nexport type NotificationEvents = {\n  runSucceeeded: (notification: SuccessfulRunNotification<any>) => void;\n  runFailed: (notification: FailedRunNotification) => void;\n};\n\nexport type NotificationsEventEmitter = TypedEmitter<NotificationEvents>;\n", "import { ApiClient } from \"../apiClient\";\nimport { Json } from \"../io\";\nimport { runLocalStorage } from \"../runLocalStorage\";\n\nexport class KeyValueStore {\n  constructor(\n    private apiClient: ApiClient,\n    private type: string | null = null,\n    private namespace: string = \"\"\n  ) {}\n\n  #namespacedKey(key: string) {\n    const parts = [];\n\n    if (this.type) {\n      parts.push(this.type);\n    }\n\n    if (this.namespace) {\n      parts.push(this.namespace);\n    }\n\n    parts.push(key);\n\n    return parts.join(\":\");\n  }\n\n  #sharedProperties(key: string) {\n    return [\n      {\n        label: \"namespace\",\n        text: this.type ?? \"env\",\n      },\n      {\n        label: \"key\",\n        text: key,\n      },\n    ];\n  }\n\n  async delete(cacheKey: string | any[], key: string): Promise<boolean>;\n  async delete(key: string): Promise<boolean>;\n  async delete(param1: string | any[], param2?: string): Promise<boolean> {\n    const runStore = runLocalStorage.getStore();\n\n    if (!runStore) {\n      if (typeof param1 !== \"string\") {\n        throw new Error(\n          \"Please use the store without a cacheKey when accessing from outside a run.\"\n        );\n      }\n\n      return await this.apiClient.store.delete(this.#namespacedKey(param1));\n    }\n\n    const { io } = runStore;\n\n    if (!param2) {\n      throw new Error(\"Please provide a non-empty key when accessing the store from inside a run.\");\n    }\n\n    return await io.runTask(\n      param1,\n      async (task) => {\n        return await this.apiClient.store.delete(this.#namespacedKey(param2));\n      },\n      {\n        name: \"Key-Value Store Delete\",\n        icon: \"database-minus\",\n        params: { key: param2 },\n        properties: this.#sharedProperties(param2),\n        style: { style: \"minimal\" },\n      }\n    );\n  }\n\n  async get<T extends Json<T> = any>(cacheKey: string | any[], key: string): Promise<T | undefined>;\n  async get<T extends Json<T> = any>(key: string): Promise<T | undefined>;\n  async get<T extends Json<T> = any>(\n    param1: string | any[],\n    param2?: string\n  ): Promise<T | undefined> {\n    const runStore = runLocalStorage.getStore();\n\n    if (!runStore) {\n      if (typeof param1 !== \"string\") {\n        throw new Error(\n          \"Please use the store without a cacheKey when accessing from outside a run.\"\n        );\n      }\n\n      return await this.apiClient.store.get(this.#namespacedKey(param1));\n    }\n\n    const { io } = runStore;\n\n    if (!param2) {\n      throw new Error(\"Please provide a non-empty key when accessing the store from inside a run.\");\n    }\n\n    return await io.runTask(\n      param1,\n      async (task) => {\n        return await this.apiClient.store.get(this.#namespacedKey(param2));\n      },\n      {\n        name: \"Key-Value Store Get\",\n        icon: \"database-export\",\n        params: { key: param2 },\n        properties: this.#sharedProperties(param2),\n        style: { style: \"minimal\" },\n      }\n    );\n  }\n\n  async has(cacheKey: string | any[], key: string): Promise<boolean>;\n  async has(key: string): Promise<boolean>;\n  async has(param1: string | any[], param2?: string): Promise<boolean> {\n    const runStore = runLocalStorage.getStore();\n\n    if (!runStore) {\n      if (typeof param1 !== \"string\") {\n        throw new Error(\n          \"Please use the store without a cacheKey when accessing from outside a run.\"\n        );\n      }\n\n      return await this.apiClient.store.has(this.#namespacedKey(param1));\n    }\n\n    const { io } = runStore;\n\n    if (!param2) {\n      throw new Error(\"Please provide a non-empty key when accessing the store from inside a run.\");\n    }\n\n    return await io.runTask(\n      param1,\n      async (task) => {\n        return await this.apiClient.store.has(this.#namespacedKey(param2));\n      },\n      {\n        name: \"Key-Value Store Has\",\n        icon: \"database-search\",\n        params: { key: param2 },\n        properties: this.#sharedProperties(param2),\n        style: { style: \"minimal\" },\n      }\n    );\n  }\n\n  async set<T extends Json<T>>(cacheKey: string | any[], key: string, value: T): Promise<T>;\n  async set<T extends Json<T>>(key: string, value: T): Promise<T>;\n  async set<T extends Json<T>>(param1: string | any[], param2: string | T, param3?: T): Promise<T> {\n    const runStore = runLocalStorage.getStore();\n\n    if (!runStore) {\n      if (typeof param1 !== \"string\") {\n        throw new Error(\n          \"Please use the store without a cacheKey when accessing from outside a run.\"\n        );\n      }\n\n      return await this.apiClient.store.set(this.#namespacedKey(param1), param2 as T);\n    }\n\n    const { io } = runStore;\n\n    if (!param2 || typeof param2 !== \"string\") {\n      throw new Error(\"Please provide a non-empty key when accessing the store from inside a run.\");\n    }\n\n    const value = param3 as T;\n\n    return await io.runTask(\n      param1,\n      async (task) => {\n        return await this.apiClient.store.set(this.#namespacedKey(param2), value);\n      },\n      {\n        name: \"Key-Value Store Set\",\n        icon: \"database-plus\",\n        params: { key: param2, value },\n        properties: [\n          ...this.#sharedProperties(param2),\n          ...(typeof value !== \"object\" || value === null\n            ? [\n                {\n                  label: \"value\",\n                  text: String(value) ?? \"undefined\",\n                },\n              ]\n            : []),\n        ],\n        style: { style: \"minimal\" },\n      }\n    );\n  }\n}\n", "import { AsyncMap } from \"@trigger.dev/core\";\nimport { KeyValueStoreResponseBody } from \"@trigger.dev/core\";\nimport { JSONOutputSerializer, Json } from \"../io\";\n\ntype QueryKeyValueStoreFunction = (\n  action: \"DELETE\" | \"GET\" | \"HAS\" | \"SET\",\n  data: {\n    key: string;\n    value?: string;\n  }\n) => Promise<KeyValueStoreResponseBody>;\n\nexport class KeyValueStoreClient implements AsyncMap {\n  #serializer = new JSONOutputSerializer();\n\n  constructor(\n    private queryStore: QueryKeyValueStoreFunction,\n    private type: string | null = null,\n    private namespace: string = \"\"\n  ) {}\n\n  #namespacedKey(key: string) {\n    const parts = [];\n\n    if (this.type) {\n      parts.push(this.type);\n    }\n\n    if (this.namespace) {\n      parts.push(this.namespace);\n    }\n\n    parts.push(key);\n\n    return parts.join(\":\");\n  }\n\n  async delete(key: string): Promise<boolean> {\n    const result = await this.queryStore(\"DELETE\", {\n      key: this.#namespacedKey(key),\n    });\n\n    if (result.action !== \"DELETE\") {\n      throw new Error(`Unexpected key-value store response: ${result.action}`);\n    }\n\n    return result.deleted;\n  }\n\n  async get<T extends Json<T>>(key: string): Promise<T | undefined> {\n    const result = await this.queryStore(\"GET\", {\n      key: this.#namespacedKey(key),\n    });\n\n    if (result.action !== \"GET\") {\n      throw new Error(`Unexpected key-value store response: ${result.action}`);\n    }\n\n    return this.#serializer.deserialize(result.value);\n  }\n\n  async has(key: string): Promise<boolean> {\n    const result = await this.queryStore(\"HAS\", {\n      key: this.#namespacedKey(key),\n    });\n\n    if (result.action !== \"HAS\") {\n      throw new Error(`Unexpected key-value store response: ${result.action}`);\n    }\n\n    return result.has;\n  }\n\n  async set<T extends Json<T>>(key: string, value: T): Promise<T> {\n    const result = await this.queryStore(\"SET\", {\n      key: this.#namespacedKey(key),\n      value: this.#serializer.serialize(value),\n    });\n\n    if (result.action !== \"SET\") {\n      throw new Error(`Unexpected key-value store response: ${result.action}`);\n    }\n\n    return this.#serializer.deserialize(result.value);\n  }\n}\n", "export type ConcurrencyLimitOptions = {\n  id: string;\n  limit: number;\n};\n\nexport class ConcurrencyLimit {\n  constructor(private options: ConcurrencyLimitOptions) {}\n\n  get id() {\n    return this.options.id;\n  }\n\n  get limit() {\n    return this.options.limit;\n  }\n}\n", "import {\n  DisplayProperty,\n  EventFilter,\n  HttpEndpointMetadata,\n  RequestFilter,\n  RequestWithRawBodySchema,\n  TriggerMetadata,\n} from \"@trigger.dev/core\";\nimport { ParsedPayloadSchemaError } from \"./errors\";\nimport { Job } from \"./job\";\nimport { TriggerClient } from \"./triggerClient\";\nimport { EventSpecification, EventSpecificationExample, Trigger, VerifyResult } from \"./types\";\nimport { formatSchemaErrors } from \"./utils/formatSchemaErrors\";\nimport { slugifyId } from \"./utils\";\n\ntype HttpEndpointOptions<TEventSpecification extends EventSpecification<any>> = {\n  id: string;\n  enabled?: boolean;\n  event: TEventSpecification;\n  respondWith?: RespondWith;\n  verify: VerifyCallback;\n};\n\nexport type RequestOptions = {\n  filter?: RequestFilter;\n};\n\nexport class HttpEndpoint<TEventSpecification extends EventSpecification<any>> {\n  constructor(private readonly options: HttpEndpointOptions<TEventSpecification>) {}\n\n  get id() {\n    return this.options.id;\n  }\n\n  onRequest(options?: RequestOptions): HttpTrigger<EventSpecification<Request>> {\n    return new HttpTrigger({\n      endpointId: this.id,\n      event: this.options.event,\n      filter: options?.filter,\n      verify: this.options.verify,\n    });\n  }\n\n  // @internal\n  async handleRequest(request: Request): Promise<Response | undefined> {\n    if (!this.options.respondWith) return;\n    return this.options.respondWith.handler(request, () => {\n      const clonedRequest = request.clone();\n      return this.options.verify(clonedRequest);\n    });\n  }\n\n  toJSON(): HttpEndpointMetadata {\n    return {\n      id: this.id,\n      icon: this.options.event.icon,\n      version: \"1\",\n      enabled: this.options.enabled ?? true,\n      event: this.options.event,\n      immediateResponseFilter: this.options.respondWith?.filter,\n      skipTriggeringRuns: this.options.respondWith?.skipTriggeringRuns,\n      source: this.options.event.source,\n    };\n  }\n}\n\ntype TriggerOptions<TEventSpecification extends EventSpecification<any>> = {\n  endpointId: string;\n  event: TEventSpecification;\n  filter?: EventFilter;\n  verify: VerifyCallback;\n};\n\nclass HttpTrigger<TEventSpecification extends EventSpecification<any>>\n  implements Trigger<TEventSpecification>\n{\n  constructor(private readonly options: TriggerOptions<TEventSpecification>) {}\n\n  toJSON(): TriggerMetadata {\n    return {\n      type: \"static\",\n      title: this.options.endpointId,\n      properties: this.options.event.properties,\n      rule: {\n        event: `httpendpoint.${this.options.endpointId}`,\n        payload: this.options.filter ?? {},\n        source: this.options.event.source,\n      },\n      link: `http-endpoints/${this.options.endpointId}`,\n      help: {\n        noRuns: {\n          text: \"To start triggering runs click here to setup your HTTP Endpoint with the external API service you want to receive webhooks from.\",\n          link: `http-endpoints/${this.options.endpointId}`,\n        },\n      },\n    };\n  }\n\n  get event() {\n    return this.options.event;\n  }\n\n  attachToJob(triggerClient: TriggerClient, job: Job<Trigger<TEventSpecification>, any>): void {}\n\n  get preprocessRuns() {\n    return false;\n  }\n\n  async verifyPayload(payload: Request) {\n    const clonedRequest = payload.clone();\n    return this.options.verify(clonedRequest);\n  }\n}\n\ntype RespondWith = {\n  /** Only Requests that match this filter will cause the `handler` function to run.\n   * For example, you can use this to only respond to `GET` Requests. */\n  filter?: RequestFilter;\n  /** If you set this to `true`, the Request that comes in won't go on to Trigger any Runs.\n   * This is useful if you want to Respond to the Request, but don't want to Trigger any Runs. */\n  skipTriggeringRuns?: boolean;\n  /** This is a function that's called when a Request comes in.\n   * It's passed the Request object, and expects you to return a Response object. */\n  handler: (request: Request, verify: () => Promise<VerifyResult>) => Promise<Response>;\n};\n\nexport type VerifyCallback = (request: Request) => Promise<VerifyResult>;\n\nexport type EndpointOptions = {\n  /** Used to uniquely identify the HTTP Endpoint inside your Project. */\n  id: string;\n  enabled?: boolean;\n  /** Usually you would use the domain name of the service, e.g. `cal.com`. */\n  source: string;\n  /** An optional title, displayed in the dashboard. */\n  title?: string;\n  /** An optional icon name that's displayed in the dashboard.\n   * Lots of company names are supported, e.g. `github`, `twilio`.\n   * You can also reference the name of any [Tabler icon](https://tabler-icons.io/), e.g. `brand-google-maps`, `brand-twitch`. */\n  icon?: string;\n  /** Used to provide example payloads that are accepted by the job.\n   * This will be available in the dashboard and can be used to trigger test runs. */\n  examples?: EventSpecificationExample[];\n  /** Properties that are displayed in the dashboard. */\n  properties?: DisplayProperty[];\n  /** This optional object allows you to immediately Respond to a Request. This is useful for some APIs where they do a `GET` Request when the webhook is first setup and expect a specific Response.\n\n      Only use this if you really need to Respond to the Request that comes in. Most of the time you don't. */\n  respondWith?: RespondWith;\n  /** This is compulsory, and is used to verify that the received webhook is authentic.\n   * It's a function that expects you to return a result object like:\n    \n  In 90% of cases, you'll want to use the `verifyRequestSignature` helper function we provide.\n\n    @example\n    ```ts\n    //if it's valid\n    return { success: true }\n    //if it's invalid, reason is optional\n    return { success: false, reason: \"No header\" }\n    ```\n\n   */\n  verify: VerifyCallback;\n};\n\nexport function httpEndpoint(options: EndpointOptions): HttpEndpoint<EventSpecification<Request>> {\n  const id = slugifyId(options.id);\n\n  return new HttpEndpoint({\n    id,\n    enabled: options.enabled,\n    respondWith: options.respondWith,\n    verify: options.verify,\n    event: {\n      name: id,\n      title: options.title ?? \"HTTP Trigger\",\n      source: options.source,\n      icon: options.icon ?? \"webhook\",\n      properties: options.properties,\n      examples: options.examples\n        ? options.examples\n        : [\n            {\n              id: \"basic-request\",\n              name: \"Basic Request\",\n              icon: \"http-post\",\n              payload: {\n                url: \"https://cloud.trigger.dev\",\n                method: \"POST\",\n                headers: {\n                  \"Content-Type\": \"application/json\",\n                },\n                rawBody: JSON.stringify({\n                  foo: \"bar\",\n                }),\n              },\n            },\n          ],\n      parsePayload: (rawPayload: any) => {\n        const result = RequestWithRawBodySchema.safeParse(rawPayload);\n\n        if (!result.success) {\n          throw new ParsedPayloadSchemaError(formatSchemaErrors(result.error.issues));\n        }\n\n        return new Request(new URL(result.data.url), {\n          method: result.data.method,\n          headers: result.data.headers,\n          body: result.data.rawBody,\n        });\n      },\n    },\n  });\n}\n", "import type { SchemaError } from \"@trigger.dev/core\";\nimport { SchemaParserIssue } from \"../types\";\n\nexport function formatSchemaErrors(errors: SchemaParserIssue[]): SchemaError[] {\n  return errors.map((error) => {\n    const { path, message } = error;\n    return { path: path.map(String), message };\n  });\n}\n", "import { ConnectionAuth } from \"@trigger.dev/core\";\nimport { IOWithIntegrations, TriggerIntegration } from \"./integrations\";\nimport { IO } from \"./io\";\n\nexport function createIOWithIntegrations<TIntegrations extends Record<string, TriggerIntegration>>(\n  io: IO,\n  auths?: Record<string, ConnectionAuth | undefined>,\n  integrations?: TIntegrations\n): IOWithIntegrations<TIntegrations> {\n  if (!integrations) {\n    return io as IOWithIntegrations<TIntegrations>;\n  }\n\n  const connections = Object.entries(integrations).reduce(\n    (acc, [connectionKey, integration]) => {\n      let auth = auths?.[connectionKey];\n\n      acc[connectionKey] = {\n        integration,\n        auth,\n      };\n\n      return acc;\n    },\n    {} as Record<\n      string,\n      {\n        integration: TriggerIntegration;\n        auth?: ConnectionAuth;\n      }\n    >\n  );\n\n  return new Proxy(io, {\n    get(target, prop, receiver) {\n      // We can return the original io back if the prop is __io\n      if (prop === \"__io\") {\n        return io;\n      }\n\n      if (typeof prop === \"string\" && prop in connections) {\n        const { integration, auth } = connections[prop];\n        return integration.cloneForRun(io, prop, auth);\n      }\n\n      const value = Reflect.get(target, prop, receiver);\n      return typeof value == \"function\" ? value.bind(target) : value;\n    },\n  }) as IOWithIntegrations<TIntegrations>;\n}\n", "import {\n  RegisterSourceEventV2,\n  RegisterTriggerBodyV2,\n  TriggerMetadata,\n  deepMergeFilters,\n} from \"@trigger.dev/core\";\nimport { Job } from \"../job\";\nimport { TriggerClient } from \"../triggerClient\";\nimport { EventSpecification, Trigger } from \"../types\";\nimport { slugifyId } from \"../utils\";\nimport { ExternalSource, ExternalSourceParams } from \"./externalSource\";\nimport { runLocalStorage } from \"../runLocalStorage\";\nimport { EventFilter } from \"@trigger.dev/core\";\n\n/** Options for a DynamicTrigger  */\nexport type DynamicTriggerOptions<\n  TEventSpec extends EventSpecification<any>,\n  TExternalSource extends ExternalSource<any, any, any>,\n> = {\n  /** Used to uniquely identify a DynamicTrigger */\n  id: string;\n  /** An event from an [Integration](https://trigger.dev/docs/integrations) package that you want to attach to the DynamicTrigger. The event types will come through to the payload in your Job's run. */\n  event: TEventSpec;\n  /** An external source fron an [Integration](https://trigger.dev/docs/integrations) package\n   * @example \n   * ```ts\n   *  import { events } from \"@trigger.dev/github\";\n   * \n   *  const dynamicOnIssueOpened = client.defineDynamicTrigger({\n        id: \"github-issue-opened\",\n        event: events.onIssueOpened,\n        source: github.sources.repo,\n      });\n   * ```\n    */\n  source: TExternalSource;\n};\n\n/** `DynamicTrigger` allows you to define a trigger that can be configured dynamically at runtime. */\nexport class DynamicTrigger<\n  TEventSpec extends EventSpecification<any>,\n  TExternalSource extends ExternalSource<any, any, any>,\n> implements Trigger<TEventSpec>\n{\n  #client: TriggerClient;\n  #options: DynamicTriggerOptions<TEventSpec, TExternalSource>;\n  source: TExternalSource;\n\n  /** `DynamicTrigger` allows you to define a trigger that can be configured dynamically at runtime.\n   * @param client The `TriggerClient` instance to use for registering the trigger.\n   * @param options The options for the dynamic trigger.\n   * */\n  constructor(client: TriggerClient, options: DynamicTriggerOptions<TEventSpec, TExternalSource>) {\n    this.#client = client;\n    this.#options = options;\n    this.source = options.source;\n\n    client.attachDynamicTrigger(this);\n  }\n\n  toJSON(): TriggerMetadata {\n    return {\n      type: \"dynamic\",\n      id: this.#options.id,\n    };\n  }\n\n  get id() {\n    return this.#options.id;\n  }\n\n  get event() {\n    return this.#options.event;\n  }\n\n  // @internal\n  registeredTriggerForParams(\n    params: ExternalSourceParams<TExternalSource>,\n    options: { accountId?: string; filter?: EventFilter } = {}\n  ): RegisterTriggerBodyV2 {\n    const key = slugifyId(this.source.key(params));\n\n    return {\n      rule: {\n        event: this.event.name,\n        source: this.event.source,\n        payload: deepMergeFilters(\n          this.source.filter(params),\n          this.event.filter ?? {},\n          options.filter ?? {}\n        ),\n      },\n      source: {\n        version: \"2\",\n        key,\n        channel: this.source.channel,\n        params,\n        //todo add other options here\n        options: {\n          event: typeof this.event.name === \"string\" ? [this.event.name] : this.event.name,\n        },\n        integration: {\n          id: this.source.integration.id,\n          metadata: this.source.integration.metadata,\n          authSource: this.source.integration.authSource,\n        },\n      },\n      accountId: options.accountId,\n    };\n  }\n\n  /** Use this method to register a new configuration with the DynamicTrigger.\n   * @param key The key for the configuration. This will be used to identify the configuration when it is triggered.\n   * @param params The params for the configuration.\n   * @param options Options for the configuration.\n   * @param options.accountId The accountId to associate with the configuration.\n   * @param options.filter The filter to use for the configuration.\n   *\n   */\n  async register(\n    key: string,\n    params: ExternalSourceParams<TExternalSource>,\n    options: { accountId?: string; filter?: EventFilter } = {}\n  ): Promise<RegisterSourceEventV2> {\n    const runStore = runLocalStorage.getStore();\n\n    if (!runStore) {\n      return this.#client.registerTrigger(\n        this.id,\n        key,\n        this.registeredTriggerForParams(params, options)\n      );\n    }\n\n    const { io } = runStore;\n\n    return await io.runTask(\n      [key, \"register\"],\n      async (task) => {\n        return this.#client.registerTrigger(\n          this.id,\n          key,\n          this.registeredTriggerForParams(params, options),\n          task.idempotencyKey\n        );\n      },\n      {\n        name: \"Register Dynamic Trigger\",\n        properties: [\n          { label: \"Dynamic Trigger ID\", text: this.id },\n          { label: \"ID\", text: key },\n        ],\n        params: params as any,\n      }\n    );\n  }\n\n  attachToJob(triggerClient: TriggerClient, job: Job<Trigger<TEventSpec>, any>): void {\n    triggerClient.attachJobToDynamicTrigger(job, this);\n  }\n\n  get preprocessRuns() {\n    return true;\n  }\n\n  async verifyPayload(payload: ReturnType<TEventSpec[\"parsePayload\"]>) {\n    return { success: true as const };\n  }\n}\n", "import { EventFilter, TriggerMetadata, deepMergeFilters } from \"@trigger.dev/core\";\nimport { Job } from \"../job\";\nimport { TriggerClient } from \"../triggerClient\";\nimport {\n  EventSpecification,\n  EventSpecificationExample,\n  EventTypeFromSpecification,\n  SchemaParser,\n  Trigger,\n} from \"../types\";\nimport { formatSchemaErrors } from \"../utils/formatSchemaErrors\";\nimport { ParsedPayloadSchemaError } from \"../errors\";\nimport { VerifyCallback } from \"../httpEndpoint\";\n\ntype EventTriggerOptions<TEventSpecification extends EventSpecification<any>> = {\n  event: TEventSpecification;\n  name?: string | string[];\n  source?: string;\n  filter?: EventFilter;\n  verify?: EventTypeFromSpecification<TEventSpecification> extends Request ? VerifyCallback : never;\n};\n\nexport class EventTrigger<TEventSpecification extends EventSpecification<any>>\n  implements Trigger<TEventSpecification>\n{\n  #options: EventTriggerOptions<TEventSpecification>;\n\n  constructor(options: EventTriggerOptions<TEventSpecification>) {\n    this.#options = options;\n  }\n\n  toJSON(): TriggerMetadata {\n    return {\n      type: \"static\",\n      title: this.#options.name ?? this.#options.event.title,\n      rule: {\n        event: this.#options.name ?? this.#options.event.name,\n        source: this.#options.source ?? \"trigger.dev\",\n        payload: deepMergeFilters(this.#options.filter ?? {}, this.#options.event.filter ?? {}),\n      },\n    };\n  }\n\n  get event() {\n    return this.#options.event;\n  }\n\n  attachToJob(triggerClient: TriggerClient, job: Job<Trigger<TEventSpecification>, any>): void {}\n\n  get preprocessRuns() {\n    return false;\n  }\n\n  async verifyPayload(payload: ReturnType<TEventSpecification[\"parsePayload\"]>) {\n    if (this.#options.verify) {\n      if ((payload as any) instanceof Request) {\n        const clonedRequest = (payload as Request).clone();\n        return this.#options.verify(clonedRequest);\n      }\n    }\n\n    return { success: true as const };\n  }\n}\n\n/** Configuration options for an EventTrigger */\ntype TriggerOptions<TEvent> = {\n  /** The name of the event you are subscribing to. Must be an exact match (case sensitive). To trigger on multiple possible events, pass in an array of event names */\n  name: string | string[];\n  /** A [Zod](https://trigger.dev/docs/documentation/guides/zod) schema that defines the shape of the event payload.\n   * The default is `z.any()` which is `any`.\n   * */\n  schema?: SchemaParser<TEvent>;\n  /** You can use this to filter events based on the source. */\n  source?: string;\n  /** Used to filter which events trigger the Job\n   * @example\n   * filter:\n   * ```ts\n   * {\n   *    name: [\"John\", \"Jane\"],\n   *    age: [18, 21]\n   * }\n   * ```\n   *\n   * This filter would match against an event with the following data:\n   * ```json\n   * {\n   *    \"name\": \"Jane\",\n   *    \"age\": 18,\n   *    \"location\": \"San Francisco\"\n   * }\n   * ```\n   */\n  filter?: EventFilter;\n\n  examples?: EventSpecificationExample[];\n};\n\n/** `eventTrigger()` is set as a [Job's trigger](https://trigger.dev/docs/sdk/job) to subscribe to an event a Job from [a sent event](https://trigger.dev/docs/sdk/triggerclient/instancemethods/sendevent)\n * @param options options for the EventTrigger\n */\nexport function eventTrigger<TEvent extends any = any>(\n  options: TriggerOptions<TEvent>\n): Trigger<EventSpecification<TEvent>> {\n  return new EventTrigger({\n    name: options.name,\n    filter: options.filter,\n    source: options.source,\n    event: {\n      name: options.name,\n      title: \"Event\",\n      source: options.source ?? \"trigger.dev\",\n      icon: \"custom-event\",\n      examples: options.examples,\n      parsePayload: (rawPayload: any) => {\n        if (options.schema) {\n          const results = options.schema.safeParse(rawPayload);\n\n          if (!results.success) {\n            throw new ParsedPayloadSchemaError(formatSchemaErrors(results.error.issues));\n          }\n\n          return results.data;\n        }\n\n        return rawPayload as any;\n      },\n    },\n  });\n}\n", "import {\n  CronOptions,\n  IntervalOptions,\n  ScheduleMetadata,\n  ScheduledPayload,\n  ScheduledPayloadSchema,\n  TriggerMetadata,\n  currentDate,\n} from \"@trigger.dev/core\";\nimport { Job } from \"../job\";\nimport { TriggerClient } from \"../triggerClient\";\nimport { EventSpecification, Trigger } from \"../types\";\nimport cronstrue from \"cronstrue\";\nimport { runLocalStorage } from \"../runLocalStorage\";\n\ntype ScheduledEventSpecification = EventSpecification<ScheduledPayload>;\n\nconst examples = [\n  {\n    id: \"now\",\n    name: \"Now\",\n    icon: \"clock\",\n    payload: {\n      ts: currentDate.marker,\n      lastTimestamp: currentDate.marker,\n    },\n  },\n];\n\nexport class IntervalTrigger implements Trigger<ScheduledEventSpecification> {\n  constructor(private options: IntervalOptions) {}\n\n  get event() {\n    return {\n      name: \"trigger.scheduled\",\n      title: \"Schedule\",\n      source: \"trigger.dev\",\n      icon: \"schedule-interval\",\n      examples,\n      parsePayload: ScheduledPayloadSchema.parse,\n      properties: [\n        {\n          label: \"Interval\",\n          text: `${this.options.seconds}s`,\n        },\n      ],\n    };\n  }\n\n  attachToJob(\n    triggerClient: TriggerClient,\n    job: Job<Trigger<ScheduledEventSpecification>, any>\n  ): void {}\n\n  get preprocessRuns() {\n    return false;\n  }\n\n  async verifyPayload(payload: ReturnType<ScheduledEventSpecification[\"parsePayload\"]>) {\n    return { success: true as const };\n  }\n\n  toJSON(): TriggerMetadata {\n    return {\n      type: \"scheduled\",\n      schedule: {\n        type: \"interval\",\n        options: {\n          seconds: this.options.seconds,\n        },\n      },\n    };\n  }\n}\n\n/** `intervalTrigger()` is set as a [Job's trigger](/sdk/job) to trigger a Job at a recurring interval.\n * @param options An object containing options about the interval.\n */\nexport function intervalTrigger(options: IntervalOptions) {\n  return new IntervalTrigger(options);\n}\n\nexport class CronTrigger implements Trigger<ScheduledEventSpecification> {\n  constructor(private options: CronOptions) {}\n\n  get event() {\n    /**\n     * We need to concat `(UTC)` string at the end of the human readable string to avoid confusion \n     * with execution time/last run of a job in the UI dashboard which is displayed in local time.\n     */\n    const humanReadable = cronstrue.toString(this.options.cron, {\n      throwExceptionOnParseError: false,\n    }).concat(\" (UTC)\");\n\n    return {\n      name: \"trigger.scheduled\",\n      title: \"Cron Schedule\",\n      source: \"trigger.dev\",\n      icon: \"schedule-cron\",\n      examples,\n      parsePayload: ScheduledPayloadSchema.parse,\n      properties: [\n        {\n          label: \"cron\",\n          text: this.options.cron,\n        },\n        {\n          label: \"Schedule\",\n          text: humanReadable,\n        },\n      ],\n    };\n  }\n\n  attachToJob(\n    triggerClient: TriggerClient,\n    job: Job<Trigger<ScheduledEventSpecification>, any>\n  ): void {}\n\n  get preprocessRuns() {\n    return false;\n  }\n\n  async verifyPayload(payload: ReturnType<ScheduledEventSpecification[\"parsePayload\"]>) {\n    return { success: true as const };\n  }\n\n  toJSON(): TriggerMetadata {\n    return {\n      type: \"scheduled\",\n      schedule: {\n        type: \"cron\",\n        options: {\n          cron: this.options.cron,\n        },\n      },\n    };\n  }\n}\n\n/** `cronTrigger()` is set as a [Job's trigger](https://trigger.dev/docs/sdk/job) to trigger a Job on a recurring schedule using a CRON expression.\n * @param options An object containing options about the CRON schedule.\n */\nexport function cronTrigger(options: CronOptions) {\n  return new CronTrigger(options);\n}\n\n/** DynamicSchedule options\n * @param id Used to uniquely identify a DynamicSchedule\n */\nexport type DynamicIntervalOptions = { id: string };\n\n/** DynamicSchedule` allows you to define a scheduled trigger that can be configured dynamically at runtime. */\nexport class DynamicSchedule implements Trigger<ScheduledEventSpecification> {\n  /**\n   * @param client The `TriggerClient` instance to use for registering the trigger.\n   * @param options The options for the schedule.\n   */\n  constructor(\n    private client: TriggerClient,\n    private options: DynamicIntervalOptions\n  ) {\n    client.attachDynamicSchedule(this.options.id);\n  }\n\n  get id() {\n    return this.options.id;\n  }\n\n  get event() {\n    return {\n      name: \"trigger.scheduled\",\n      title: \"Dynamic Schedule\",\n      source: \"trigger.dev\",\n      icon: \"schedule-dynamic\",\n      examples,\n      parsePayload: ScheduledPayloadSchema.parse,\n    };\n  }\n\n  async register(key: string, metadata: ScheduleMetadata) {\n    const runStore = runLocalStorage.getStore();\n\n    if (!runStore) {\n      return this.client.registerSchedule(this.id, key, metadata);\n    }\n\n    const { io } = runStore;\n\n    return await io.runTask(\n      [key, \"register\"],\n      async (task) => {\n        return this.client.registerSchedule(this.id, key, metadata);\n      },\n      {\n        name: \"Register Schedule\",\n        icon: metadata.type === \"cron\" ? \"schedule-cron\" : \"schedule-interval\",\n        properties: [\n          { label: \"Dynamic Schedule\", text: this.id },\n          { label: \"Schedule ID\", text: key },\n        ],\n        params: metadata,\n      }\n    );\n  }\n\n  async unregister(key: string) {\n    const runStore = runLocalStorage.getStore();\n\n    if (!runStore) {\n      return this.client.unregisterSchedule(this.id, key);\n    }\n\n    const { io } = runStore;\n\n    return await io.runTask(\n      [key, \"unregister\"],\n      async (task) => {\n        return this.client.unregisterSchedule(this.id, key);\n      },\n      {\n        name: \"Unregister Schedule\",\n        icon: \"schedule\",\n        properties: [\n          { label: \"Dynamic Schedule\", text: this.id },\n          { label: \"Schedule ID\", text: key },\n        ],\n      }\n    );\n  }\n\n  attachToJob(\n    triggerClient: TriggerClient,\n    job: Job<Trigger<ScheduledEventSpecification>, any>\n  ): void {\n    triggerClient.attachDynamicScheduleToJob(this.options.id, job);\n  }\n\n  get preprocessRuns() {\n    return false;\n  }\n\n  async verifyPayload(payload: ReturnType<ScheduledEventSpecification[\"parsePayload\"]>) {\n    return { success: true as const };\n  }\n\n  toJSON(): TriggerMetadata {\n    return {\n      type: \"dynamic\",\n      id: this.options.id,\n    };\n  }\n}\n", "import {\n  ConnectionAuth,\n  DisplayProperty,\n  EventFilter,\n  HandleTriggerSource,\n  HttpSourceResponseMetadata,\n  NormalizedResponse,\n  Prettify,\n  RegisterTriggerSource,\n  SendEvent,\n  SerializableJson,\n  TriggerMetadata,\n  deepMergeFilters,\n} from \"@trigger.dev/core\";\nimport { Logger } from \"@trigger.dev/core-backend\";\nimport type { Buffer } from \"buffer\";\nimport { IOWithIntegrations, TriggerIntegration } from \"../integrations\";\nimport { IO } from \"../io\";\nimport { Job } from \"../job\";\nimport { TriggerClient } from \"../triggerClient\";\nimport type { EventSpecification, SchemaParser, Trigger, TriggerContext } from \"../types\";\nimport { slugifyId } from \"../utils\";\n\nexport type HttpSourceEvent = {\n  url: string;\n  method: string;\n  headers: Record<string, string>;\n  rawBody?: Buffer | null;\n};\n\ntype SmtpSourceEvent = {\n  from: string;\n  to: string;\n  subject: string;\n  body: string;\n};\n\ntype SqsSourceEvent = {\n  body: string;\n};\n\ntype ExternalSourceChannelMap = {\n  HTTP: {\n    event: Request;\n    register: {\n      url: string;\n    };\n  };\n  SMTP: {\n    event: SmtpSourceEvent;\n    register: {};\n  };\n  SQS: {\n    event: SqsSourceEvent;\n    register: {};\n  };\n};\n\ntype ChannelNames = keyof ExternalSourceChannelMap;\n\ntype TriggerOptionDiff = {\n  desired: string[];\n  missing: string[];\n  orphaned: string[];\n};\n\ntype TriggerOptionDiffs<TTriggerOptionDefinitions extends Record<string, string[]> = any> =\n  TriggerOptionsRecordWithEvent<TriggerOptionDiff, TTriggerOptionDefinitions>;\n\ntype TriggerOptionsRecordWithEvent<\n  TValue,\n  TTriggerOptionDefinitions extends Record<string, string[]>,\n> = {\n  event: TValue;\n} & TriggerOptionRecord<TValue, TTriggerOptionDefinitions>;\n\nexport type TriggerOptionRecord<\n  TValue,\n  TTriggerOptionDefinitions extends Record<string, string[]> = any,\n> = {\n  [K in keyof TTriggerOptionDefinitions]: TValue;\n};\n\ntype RegisterFunctionEvent<\n  TChannel extends ChannelNames,\n  TParams extends any,\n  TTriggerOptionDefinitions extends Record<string, string[]> = any,\n> = {\n  options: TriggerOptionDiffs<TTriggerOptionDefinitions>;\n  source: {\n    active: boolean;\n    data?: any;\n    secret: string;\n  } & ExternalSourceChannelMap[TChannel][\"register\"];\n  params: TParams;\n};\n\ntype RegisterSourceEvent<TTriggerOptionDefinitions extends Record<string, string[]> = any> = {\n  id: string;\n  source: RegisterTriggerSource;\n  dynamicTriggerId?: string;\n  options: TriggerOptionDiffs<TTriggerOptionDefinitions>;\n};\n\ntype RegisterFunctionOutput<TTriggerOptionDefinitions extends Record<string, string[]> = any> = {\n  secret?: string;\n  data?: SerializableJson;\n  options: TriggerOptionsRecordWithEvent<string[], TTriggerOptionDefinitions>;\n};\n\ntype RegisterFunction<\n  TIntegration extends TriggerIntegration,\n  TParams extends any,\n  TChannel extends ChannelNames,\n  TTriggerOptionDefinitions extends Record<string, string[]> = any,\n> = (\n  event: RegisterFunctionEvent<TChannel, TParams, TTriggerOptionDefinitions>,\n  io: IOWithIntegrations<{ integration: TIntegration }>,\n  ctx: TriggerContext\n) => Promise<RegisterFunctionOutput<TTriggerOptionDefinitions> | undefined>;\n\nexport type HandlerEvent<TChannel extends ChannelNames, TParams extends any = any> = {\n  rawEvent: ExternalSourceChannelMap[TChannel][\"event\"];\n  source: Prettify<Omit<HandleTriggerSource, \"params\"> & { params: TParams }>;\n};\n\ntype HandlerFunction<\n  TChannel extends ChannelNames,\n  TParams extends any,\n  TTriggerIntegration extends TriggerIntegration,\n> = (\n  event: HandlerEvent<TChannel, TParams>,\n  logger: Logger,\n  integration: TTriggerIntegration,\n  auth?: ConnectionAuth\n) => Promise<{\n  events: SendEvent[];\n  response?: NormalizedResponse;\n  metadata?: HttpSourceResponseMetadata;\n} | void>;\n\ntype KeyFunction<TParams extends any> = (params: TParams) => string;\ntype FilterFunction<\n  TParams extends any,\n  TTriggerOptionDefinitions extends Record<string, string[]> = any,\n> = (params: TParams, options?: TTriggerOptionDefinitions) => EventFilter;\n\ntype ExternalSourceOptions<\n  TChannel extends ChannelNames,\n  TIntegration extends TriggerIntegration,\n  TParams extends any,\n  TTriggerOptionDefinitions extends Record<string, string[]> = any,\n> = {\n  id: string;\n  version: string;\n  schema: SchemaParser<TParams>;\n  optionSchema?: SchemaParser<TTriggerOptionDefinitions>;\n  integration: TIntegration;\n  register: RegisterFunction<TIntegration, TParams, TChannel, TTriggerOptionDefinitions>;\n  filter?: FilterFunction<TParams, TTriggerOptionDefinitions>;\n  handler: HandlerFunction<TChannel, TParams, TIntegration>;\n  key: KeyFunction<TParams>;\n  properties?: (params: TParams) => DisplayProperty[];\n};\n\nexport class ExternalSource<\n  TIntegration extends TriggerIntegration,\n  TParams extends any,\n  TChannel extends ChannelNames = ChannelNames,\n  TTriggerOptionDefinitions extends Record<string, string[]> = any,\n> {\n  channel: TChannel;\n\n  constructor(\n    channel: TChannel,\n    private options: ExternalSourceOptions<\n      TChannel,\n      TIntegration,\n      TParams,\n      TTriggerOptionDefinitions\n    >\n  ) {\n    this.channel = channel;\n  }\n\n  async handle(\n    source: HandleTriggerSource,\n    rawEvent: ExternalSourceChannelMap[TChannel][\"event\"],\n    logger: Logger\n  ) {\n    return this.options.handler(\n      {\n        source: { ...source, params: source.params as TParams },\n        rawEvent,\n      },\n      logger,\n      this.options.integration\n    );\n  }\n\n  filter(params: TParams, options?: TTriggerOptionDefinitions): EventFilter {\n    return this.options.filter?.(params, options) ?? {};\n  }\n\n  properties(params: TParams): DisplayProperty[] {\n    return this.options.properties?.(params) ?? [];\n  }\n\n  async register(\n    params: TParams,\n    registerEvent: RegisterSourceEvent<TTriggerOptionDefinitions>,\n    io: IO,\n    ctx: TriggerContext\n  ) {\n    const { result: event, ommited: source } = omit(registerEvent, \"source\");\n    const { result: sourceWithoutChannel, ommited: channel } = omit(source, \"channel\");\n    const { result: channelWithoutType } = omit(channel, \"type\");\n\n    const updates = await this.options.register(\n      {\n        ...event,\n        source: { ...sourceWithoutChannel, ...channelWithoutType },\n        params,\n      },\n      io as IOWithIntegrations<{ integration: TIntegration }>,\n      ctx\n    );\n\n    return updates;\n  }\n\n  key(params: TParams): string {\n    const parts = [this.options.id, this.channel];\n\n    parts.push(this.options.key(params));\n    parts.push(this.integration.id);\n\n    return parts.join(\"-\");\n  }\n\n  get integration() {\n    return this.options.integration;\n  }\n\n  get integrationConfig() {\n    return {\n      id: this.integration.id,\n      metadata: this.integration.metadata,\n    };\n  }\n\n  get id() {\n    return this.options.id;\n  }\n\n  get version() {\n    return this.options.version;\n  }\n}\n\nexport type ExternalSourceParams<TExternalSource extends ExternalSource<any, any, any>> =\n  TExternalSource extends ExternalSource<any, infer TParams, any> ? TParams : never;\n\nexport type ExternalSourceTriggerOptions<\n  TEventSpecification extends EventSpecification<any>,\n  TEventSource extends ExternalSource<any, any, any>,\n  TTriggerOptionDefinitions extends Record<string, string[]> = any,\n> = {\n  event: TEventSpecification;\n  source: TEventSource;\n  params: ExternalSourceParams<TEventSource>;\n  options: TriggerOptionRecord<string[], TTriggerOptionDefinitions>;\n};\n\nexport class ExternalSourceTrigger<\n  TEventSpecification extends EventSpecification<any>,\n  TEventSource extends ExternalSource<any, any, any>,\n> implements Trigger<TEventSpecification>\n{\n  constructor(private options: ExternalSourceTriggerOptions<TEventSpecification, TEventSource>) {}\n\n  get event() {\n    return this.options.event;\n  }\n\n  toJSON(): TriggerMetadata {\n    return {\n      type: \"static\",\n      title: \"External Source\",\n      rule: {\n        event: this.event.name,\n        payload: deepMergeFilters(\n          this.options.source.filter(this.options.params, this.options.options),\n          this.event.filter ?? {},\n          this.options.params.filter ?? {}\n        ),\n        source: this.event.source,\n      },\n      properties: this.options.source.properties(this.options.params),\n    };\n  }\n\n  attachToJob(triggerClient: TriggerClient, job: Job<Trigger<TEventSpecification>, any>) {\n    triggerClient.attachSource({\n      key: slugifyId(this.options.source.key(this.options.params)),\n      source: this.options.source,\n      event: this.options.event,\n      params: this.options.params,\n      options: this.options.options,\n    });\n  }\n\n  get preprocessRuns() {\n    return true;\n  }\n\n  async verifyPayload(payload: ReturnType<TEventSpecification[\"parsePayload\"]>) {\n    return { success: true as const };\n  }\n}\n\nexport function omit<T extends Record<string, unknown>, K extends keyof T>(\n  obj: T,\n  key: K\n): { result: Omit<T, K>; ommited: T[K] } {\n  const result: any = {};\n\n  for (const k of Object.keys(obj)) {\n    if (k === key) continue;\n\n    result[k] = obj[k];\n  }\n\n  return { result, ommited: obj[key] };\n}\n", "import {\n  MISSING_CONNECTION_NOTIFICATION,\n  MISSING_CONNECTION_RESOLVED_NOTIFICATION,\n  MissingConnectionNotificationPayload,\n  MissingConnectionNotificationPayloadSchema,\n  MissingConnectionResolvedNotificationPayload,\n  MissingConnectionResolvedNotificationPayloadSchema,\n  TriggerMetadata,\n} from \"@trigger.dev/core\";\nimport { TriggerIntegration } from \"../integrations\";\nimport { Job } from \"../job\";\nimport { TriggerClient } from \"../triggerClient\";\nimport { EventSpecification, Trigger } from \"../types\";\n\nexport function missingConnectionNotification(integrations: Array<TriggerIntegration>) {\n  return new MissingConnectionNotification({ integrations });\n}\n\nexport function missingConnectionResolvedNotification(integrations: Array<TriggerIntegration>) {\n  return new MissingConnectionResolvedNotification({ integrations });\n}\n\ntype MissingConnectionNotificationSpecification =\n  EventSpecification<MissingConnectionNotificationPayload>;\n\ntype MissingConnectionNotificationOptions = {\n  integrations: Array<TriggerIntegration>;\n};\n\nexport class MissingConnectionNotification\n  implements Trigger<MissingConnectionNotificationSpecification>\n{\n  constructor(private options: MissingConnectionNotificationOptions) {}\n\n  get event() {\n    return {\n      name: MISSING_CONNECTION_NOTIFICATION,\n      title: \"Missing Connection Notification\",\n      source: \"trigger.dev\",\n      icon: \"connection-alert\",\n      parsePayload: MissingConnectionNotificationPayloadSchema.parse,\n      properties: [\n        {\n          label: \"Integrations\",\n          text: this.options.integrations.map((i) => i.id).join(\", \"),\n        },\n      ],\n    };\n  }\n\n  attachToJob(\n    triggerClient: TriggerClient,\n    job: Job<Trigger<MissingConnectionNotificationSpecification>, any>\n  ): void {}\n\n  get preprocessRuns() {\n    return false;\n  }\n\n  async verifyPayload(\n    payload: ReturnType<MissingConnectionNotificationSpecification[\"parsePayload\"]>\n  ) {\n    return { success: true as const };\n  }\n\n  toJSON(): TriggerMetadata {\n    return {\n      type: \"static\",\n      title: this.event.title,\n      rule: {\n        event: this.event.name,\n        source: \"trigger.dev\",\n        payload: {\n          client: {\n            id: this.options.integrations.map((i) => i.id),\n          },\n        },\n      },\n    };\n  }\n}\n\ntype MissingConnectionResolvedNotificationSpecification =\n  EventSpecification<MissingConnectionResolvedNotificationPayload>;\n\nexport class MissingConnectionResolvedNotification\n  implements Trigger<MissingConnectionResolvedNotificationSpecification>\n{\n  constructor(private options: MissingConnectionNotificationOptions) {}\n\n  get event() {\n    return {\n      name: MISSING_CONNECTION_RESOLVED_NOTIFICATION,\n      title: \"Missing Connection Resolved Notification\",\n      source: \"trigger.dev\",\n      icon: \"connection-alert\",\n      parsePayload: MissingConnectionResolvedNotificationPayloadSchema.parse,\n      properties: [\n        {\n          label: \"Integrations\",\n          text: this.options.integrations.map((i) => i.id).join(\", \"),\n        },\n      ],\n    };\n  }\n\n  attachToJob(\n    triggerClient: TriggerClient,\n    job: Job<Trigger<MissingConnectionResolvedNotificationSpecification>, any>\n  ): void {}\n\n  get preprocessRuns() {\n    return false;\n  }\n\n  async verifyPayload(\n    payload: ReturnType<MissingConnectionResolvedNotificationSpecification[\"parsePayload\"]>\n  ) {\n    return { success: true as const };\n  }\n\n  toJSON(): TriggerMetadata {\n    return {\n      type: \"static\",\n      title: this.event.title,\n      rule: {\n        event: this.event.name,\n        source: \"trigger.dev\",\n        payload: {\n          client: {\n            id: this.options.integrations.map((i) => i.id),\n          },\n        },\n      },\n    };\n  }\n}\n", "import { TriggerMetadata } from \"@trigger.dev/core\";\nimport { ParsedPayloadSchemaError } from \"../errors\";\nimport { Job } from \"../job\";\nimport { TriggerClient } from \"../triggerClient\";\nimport {\n  EventSpecification,\n  EventSpecificationExample,\n  SchemaParser,\n  Trigger,\n  VerifyResult,\n} from \"../types\";\nimport { formatSchemaErrors } from \"../utils/formatSchemaErrors\";\nimport { TypeOf, ZodType, z } from \"zod\";\n\n/** Configuration options for an InvokeTrigger */\ntype InvokeTriggerOptions<TSchema extends ZodType = z.ZodTypeAny> = {\n  /** A [Zod](https://trigger.dev/docs/documentation/guides/zod) schema that defines the shape of the event payload.\n   * The default is `z.any()` which is `any`.\n   * */\n  schema?: TSchema;\n  examples?: EventSpecificationExample[];\n};\n\nexport class InvokeTrigger<TSchema extends ZodType = z.ZodTypeAny>\n  implements Trigger<EventSpecification<TypeOf<TSchema>, z.input<TSchema>>>\n{\n  #options: InvokeTriggerOptions<TSchema>;\n\n  constructor(options: InvokeTriggerOptions<TSchema>) {\n    this.#options = options;\n  }\n\n  toJSON(): TriggerMetadata {\n    return {\n      type: \"invoke\",\n    };\n  }\n\n  get event() {\n    return {\n      name: \"invoke\",\n      title: \"Manual Invoke\",\n      source: \"trigger.dev\",\n      examples: this.#options.examples ?? [],\n      icon: \"trigger\",\n      parsePayload: (rawPayload: unknown) => {\n        if (this.#options.schema) {\n          const results = this.#options.schema.safeParse(rawPayload);\n\n          if (!results.success) {\n            throw new ParsedPayloadSchemaError(formatSchemaErrors(results.error.issues));\n          }\n\n          return results.data;\n        }\n\n        return rawPayload as any;\n      },\n      parseInvokePayload: (rawPayload: unknown) => {\n        if (this.#options.schema) {\n          const results = this.#options.schema.safeParse(rawPayload);\n\n          if (!results.success) {\n            throw new ParsedPayloadSchemaError(formatSchemaErrors(results.error.issues));\n          }\n\n          return results.data;\n        }\n\n        return rawPayload as any;\n      },\n    };\n  }\n\n  attachToJob(\n    triggerClient: TriggerClient,\n    job: Job<Trigger<EventSpecification<ZodType<TSchema>>>, any>\n  ): void {}\n\n  get preprocessRuns() {\n    return false;\n  }\n\n  async verifyPayload() {\n    return { success: true as const };\n  }\n}\n\nexport function invokeTrigger<TSchema extends ZodType = z.ZodTypeAny>(\n  options?: InvokeTriggerOptions<TSchema>\n): Trigger<EventSpecification<TypeOf<TSchema>, z.input<TSchema>>> {\n  return new InvokeTrigger(options ?? {});\n}\n", "import {\n  DisplayProperty,\n  EventFilter,\n  HandleTriggerSource,\n  RegisterWebhookSource,\n  TriggerMetadata,\n  deepMergeFilters,\n} from \"@trigger.dev/core\";\nimport { IOWithIntegrations, TriggerIntegration } from \"../integrations\";\nimport { IO } from \"../io\";\nimport { Job } from \"../job\";\nimport { TriggerClient } from \"../triggerClient\";\nimport type {\n  EventSpecification,\n  SchemaParser,\n  Trigger,\n  TriggerContext,\n  VerifyResult,\n} from \"../types\";\nimport { slugifyId } from \"../utils\";\nimport { SerializableJson } from \"@trigger.dev/core\";\nimport { Prettify } from \"@trigger.dev/core\";\nimport { createHash } from \"node:crypto\";\n\ntype WebhookCRUDContext<TParams extends any, TConfig extends Record<string, string[]>> = {\n  active: boolean;\n  params: TParams;\n  config: {\n    current: Partial<TConfig>;\n    desired: TConfig;\n  };\n  url: string;\n  secret: string;\n};\n\ntype WebhookCRUDFunction<\n  TIntegration extends TriggerIntegration,\n  TParams extends any,\n  TConfig extends Record<string, string[]>,\n> = (options: {\n  io: IOWithIntegrations<{ integration: TIntegration }>;\n  ctx: WebhookCRUDContext<TParams, TConfig>;\n}) => Promise<any>;\n\ninterface WebhookCRUD<\n  TIntegration extends TriggerIntegration,\n  TParams extends any,\n  TConfig extends Record<string, string[]>,\n> {\n  create: WebhookCRUDFunction<TIntegration, TParams, TConfig>;\n  read?: WebhookCRUDFunction<TIntegration, TParams, TConfig>; // currently unused\n  update?: WebhookCRUDFunction<TIntegration, TParams, TConfig>;\n  delete: WebhookCRUDFunction<TIntegration, TParams, TConfig>;\n}\n\nexport type WebhookConfig<TConfigKeys extends string> = {\n  [K in TConfigKeys]: string[];\n};\n\ntype RegisterFunctionEvent<TParams extends any, TConfig extends Record<string, string[]>> = {\n  source: {\n    active: boolean;\n    data?: any;\n    secret: string;\n    url: string;\n  };\n  params: TParams;\n  config: TConfig;\n};\n\ntype WebhookRegisterEvent<TConfig extends Record<string, string[]>> = {\n  id: string;\n  source: RegisterWebhookSource;\n  dynamicTriggerId?: string;\n  config: TConfig;\n};\n\ntype RegisterFunctionOutput<TConfig extends Record<string, string[]>> = {\n  secret?: string;\n  data?: SerializableJson;\n  config: TConfig;\n};\n\ntype RegisterFunction<\n  TIntegration extends TriggerIntegration,\n  TParams extends any,\n  TConfig extends Record<string, string[]>,\n> = (\n  event: RegisterFunctionEvent<TParams, TConfig>,\n  io: IOWithIntegrations<{ integration: TIntegration }>,\n  ctx: TriggerContext\n) => Promise<RegisterFunctionOutput<TConfig> | undefined>;\n\nexport type WebhookHandlerEvent<TParams extends any = any> = {\n  rawEvent: Request;\n  source: Prettify<Omit<HandleTriggerSource, \"params\"> & { params: TParams }>;\n};\n\ntype WebhookHandlerContext<TParams extends any, TConfig extends Record<string, string[]>> = {\n  params: TParams;\n  config: TConfig;\n  secret: string;\n};\n\nexport type WebhookDeliveryContext = {\n  key: string;\n  secret: string;\n  params: any;\n};\n\ntype EventGenerator<\n  TParams extends any,\n  TConfig extends Record<string, string[]>,\n  TIntegration extends TriggerIntegration,\n> = (options: {\n  request: Request;\n  client: TriggerClient;\n  ctx: WebhookDeliveryContext;\n}) => Promise<any>;\n\ntype KeyFunction<TParams extends any> = (params: TParams) => string;\n\ntype FilterFunction<TParams extends any, TConfig extends Record<string, string[]>> = (\n  params: TParams,\n  config?: TConfig\n) => EventFilter;\n\ntype WebhookOptions<\n  TIntegration extends TriggerIntegration,\n  TParams extends any,\n  TConfig extends Record<string, string[]>,\n> = {\n  id: string;\n  version: string;\n  integration: TIntegration;\n  schemas: {\n    params: SchemaParser<TParams>;\n    config?: SchemaParser<TConfig>;\n  };\n  key: KeyFunction<TParams>;\n  crud: WebhookCRUD<TIntegration, TParams, TConfig>;\n  filter?: FilterFunction<TParams, TConfig>;\n  register?: RegisterFunction<TIntegration, TParams, TConfig>;\n  verify?: (options: {\n    request: Request;\n    client: TriggerClient;\n    ctx: WebhookDeliveryContext;\n  }) => Promise<VerifyResult>;\n  generateEvents: EventGenerator<TParams, TConfig, TIntegration>;\n  properties?: (params: TParams) => DisplayProperty[];\n};\n\nexport class WebhookSource<\n  TIntegration extends TriggerIntegration,\n  TParams extends any = any,\n  TConfig extends Record<string, string[]> = Record<string, string[]>,\n> {\n  constructor(private options: WebhookOptions<TIntegration, TParams, TConfig>) {}\n\n  async generateEvents(request: Request, client: TriggerClient, ctx: WebhookDeliveryContext) {\n    return this.options.generateEvents({\n      request,\n      client,\n      ctx,\n    });\n  }\n\n  filter(params: TParams, config?: TConfig): EventFilter {\n    return this.options.filter?.(params, config) ?? {};\n  }\n\n  properties(params: TParams): DisplayProperty[] {\n    return this.options.properties?.(params) ?? [];\n  }\n\n  get crud() {\n    return this.options.crud;\n  }\n\n  async register(\n    params: TParams,\n    registerEvent: WebhookRegisterEvent<TConfig>,\n    io: IO,\n    ctx: TriggerContext\n  ) {\n    if (!this.options.register) {\n      return;\n    }\n\n    const updates = await this.options.register(\n      {\n        ...registerEvent,\n        params,\n      },\n      io as IOWithIntegrations<{ integration: TIntegration }>,\n      ctx\n    );\n\n    return updates;\n  }\n\n  async verify(\n    request: Request,\n    client: TriggerClient,\n    ctx: WebhookDeliveryContext\n  ): Promise<VerifyResult> {\n    if (this.options.verify) {\n      const clonedRequest = request.clone();\n      return this.options.verify({ request: clonedRequest, client, ctx });\n    }\n\n    return { success: true as const };\n  }\n\n  #shortHash(str: string) {\n    const hash = createHash(\"sha1\").update(str).digest(\"hex\");\n    return hash.slice(0, 7);\n  }\n\n  key(params: TParams): string {\n    const parts = [\"webhook\"];\n\n    parts.push(this.options.key(params));\n    parts.push(this.integration.id);\n\n    return `${this.options.id}-${this.#shortHash(parts.join(\"\"))}`;\n  }\n\n  get integration() {\n    return this.options.integration;\n  }\n\n  get integrationConfig() {\n    return {\n      id: this.integration.id,\n      metadata: this.integration.metadata,\n    };\n  }\n\n  get id() {\n    return this.options.id;\n  }\n\n  get version() {\n    return this.options.version;\n  }\n}\n\nexport type GetWebhookParams<TWebhook extends WebhookSource<any, any, any>> =\n  TWebhook extends WebhookSource<any, infer TParams, any> ? TParams : never;\n\nexport type GetWebhookConfig<TWebhook extends WebhookSource<any, any, any>> =\n  TWebhook extends WebhookSource<any, any, infer TConfig> ? TConfig : never;\n\nexport type WebhookTriggerOptions<\n  TEventSpecification extends EventSpecification<any>,\n  TEventSource extends WebhookSource<any, any, any>,\n  TConfig extends Record<string, string[]> = Record<string, string[]>,\n> = {\n  event: TEventSpecification;\n  source: TEventSource;\n  params: GetWebhookParams<TEventSource>;\n  config: TConfig;\n};\n\nexport class WebhookTrigger<\n  TEventSpecification extends EventSpecification<any>,\n  TEventSource extends WebhookSource<any, any, any>,\n> implements Trigger<TEventSpecification>\n{\n  constructor(private options: WebhookTriggerOptions<TEventSpecification, TEventSource>) {}\n\n  get event() {\n    return this.options.event;\n  }\n\n  get source() {\n    return this.options.source;\n  }\n\n  get key() {\n    return slugifyId(this.options.source.key(this.options.params));\n  }\n\n  toJSON(): TriggerMetadata {\n    return {\n      type: \"static\",\n      title: \"Webhook\",\n      rule: {\n        event: this.event.name,\n        payload: deepMergeFilters(\n          this.options.source.filter(this.options.params, this.options.config),\n          this.event.filter ?? {}\n        ),\n        source: this.event.source,\n      },\n      properties: this.options.source.properties(this.options.params),\n      link: `http-endpoints/${this.key}`,\n    };\n  }\n\n  filter(eventFilter: EventFilter) {\n    const { event, ...optionsWithoutEvent } = this.options;\n    const { filter, ...eventWithoutFilter } = event;\n\n    return new WebhookTrigger({\n      ...optionsWithoutEvent,\n      event: {\n        ...eventWithoutFilter,\n        filter: deepMergeFilters(filter ?? {}, eventFilter),\n      },\n    });\n  }\n\n  attachToJob(triggerClient: TriggerClient, job: Job<Trigger<TEventSpecification>, any>) {\n    triggerClient.defineHttpEndpoint(\n      {\n        id: this.key,\n        source: \"trigger.dev\",\n        icon: this.event.icon,\n        verify: async () => ({ success: true }),\n      },\n      true\n    );\n\n    triggerClient.attachWebhook({\n      key: this.key,\n      source: this.options.source,\n      event: this.options.event,\n      params: this.options.params,\n      config: this.options.config,\n    });\n  }\n\n  get preprocessRuns() {\n    return true;\n  }\n\n  async verifyPayload(payload: ReturnType<TEventSpecification[\"parsePayload\"]>) {\n    return { success: true as const };\n  }\n}\n", "import crypto from \"node:crypto\";\nimport type { BinaryToTextEncoding, BinaryLike, KeyObject } from \"crypto\";\nimport { VerifyResult } from \"./types\";\n\n/** Easily verify webhook payloads when they're using common signing methods. */\nexport async function verifyRequestSignature({\n  request,\n  headerName,\n  headerEncoding = \"hex\",\n  secret,\n  algorithm,\n}: {\n  /** The web request that you want to verify. */\n  request: Request;\n  /** The name of the header that contains the signature. E.g. `X-Cal-Signature-256`. */\n  headerName: string;\n  /** The header encoding. Defaults to `hex`. */\n  headerEncoding?: BinaryToTextEncoding;\n  /** The secret that you use to hash the payload. For HttpEndpoints this will usually originally\n      come from the Trigger.dev dashboard and should be stored in an environment variable. */\n  secret: BinaryLike | KeyObject;\n  /** The hashing algorithm that was used to create the signature. Currently only `sha256` is\n      supported. */\n  algorithm: \"sha256\";\n}): Promise<VerifyResult> {\n  if (!secret) {\n    return {\n      success: false,\n      reason: \"Missing secret – you've probably not set an environment variable.\",\n    };\n  }\n\n  const headerValue = request.headers.get(headerName);\n  if (!headerValue) {\n    return { success: false, reason: \"Missing header\" };\n  }\n\n  switch (algorithm) {\n    case \"sha256\":\n      const success = verifyHmacSha256(headerValue, headerEncoding, secret, await request.text());\n\n      if (success) {\n        return {\n          success,\n        };\n      } else {\n        return { success: false, reason: \"Failed sha256 verification\" };\n      }\n    default:\n      throw new Error(`Unsupported algorithm: ${algorithm}`);\n  }\n}\n\nexport function verifyHmacSha256(\n  headerValue: string,\n  headerEncoding: BinaryToTextEncoding,\n  secret: BinaryLike | KeyObject,\n  body: string\n): boolean {\n  const bodyDigest = crypto.createHmac(\"sha256\", secret).update(body).digest(headerEncoding);\n  const signature = headerValue?.replace(\"hmac-sha256=\", \"\").replace(\"sha256=\", \"\") ?? \"\";\n\n  return signature === bodyDigest;\n}\n", "export * from \"./job\";\nexport * from \"./triggerClient\";\nexport * from \"./integrations\";\nexport * from \"./triggers/eventTrigger\";\nexport * from \"./triggers/externalSource\";\nexport * from \"./triggers/dynamic\";\nexport * from \"./triggers/scheduled\";\nexport * from \"./triggers/notifications\";\nexport * from \"./triggers/invokeTrigger\";\nexport * from \"./triggers/webhook\";\nexport * from \"./io\";\nexport * from \"./types\";\nexport * from \"./utils\";\nexport * from \"./security\";\n\nimport { ServerTask } from \"@trigger.dev/core\";\nimport { RedactString } from \"./types\";\nexport { isTriggerError } from \"./errors\";\nexport { retry } from \"./retry\";\n\nexport type { NormalizedRequest, EventFilter } from \"@trigger.dev/core\";\n\nexport type Task = ServerTask;\n\nimport { ApiEventLog } from \"@trigger.dev/core\";\nexport type SentEvent = ApiEventLog;\n\n/*\n * This function is used to create a redacted string that can be used in the headers of a fetch request.\n * It is used to prevent the string from being logged in trigger.dev.\n * You can use it like this:\n *\n * await io.backgroundFetch<SomeResponseType>(\"https://example.com\", {\n *  headers: {\n *    Authorization: redactString`Bearer ${ACCESS_TOKEN}`,\n *  },\n * })\n */\nexport function redactString(\n  strings: TemplateStringsArray,\n  ...interpolations: string[]\n): RedactString {\n  return {\n    __redactedString: true,\n    strings: strings.raw as string[],\n    interpolations,\n  };\n}\n"],
  "mappings": "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",
  "names": ["context", "propagation", "__privateMethod", "__accessCheck", "version", "CreateAuthorizationCodeResponseSchema", "url", "string", "authorizationCode", "GetPersonalAccessTokenRequestSchema", "GetPersonalAccessTokenResponseSchema", "token", "obfuscatedToken", "z", "literal", "MachineMemory", "MachineConfig", "cpu", "MachineCpu", "optional", "memory", "preset", "MachinePresetName", "MachinePreset", "object", "name", "number", "centsPerMs", "TaskRunBuiltInError", "type", "stackTrace", "TaskRunCustomErrorObject", "raw", "TaskRunStringError", "COULD_NOT_FIND_EXECUTOR", "COULD_NOT_FIND_TASK", "CONFIGURED_INCORRECTLY", "TASK_ALREADY_RUNNING", "TASK_EXECUTION_FAILED", "TASK_EXECUTION_ABORTED", "TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE", "TASK_RUN_CANCELLED", "TASK_OUTPUT_ERROR", "HANDLE_ERROR_ERROR", "GRACEFUL_EXIT_TIMEOUT", "TASK_RUN_CRASHED", "TaskRunInternalError", "code", "message", "TaskRunError", "discriminatedUnion", "TaskRun", "id", "payload", "payloadType", "any", "tags", "array", "isTest", "boolean", "default", "createdAt", "coerce", "date", "startedAt", "maxAttempts", "durationMs", "costInCents", "baseCostInCents", "TaskRunExecutionTask", "filePath", "exportName", "TaskRunExecutionAttempt", "backgroundWorkerId", "backgroundWorkerTaskId", "status", "TaskRunExecutionEnvironment", "slug", "TaskRunExecutionOrganization", "TaskRunExecutionProject", "ref", "TaskRunExecutionBatch", "TaskRunExecution", "task", "attempt", "run", "environment", "organization", "project", "batch", "machine", "TaskRunContext", "omit", "TaskRunExecutionRetry", "delay", "error", "unknown", "TaskRunExecutionUsage", "TaskRunFailedExecutionResult", "retry", "skippedRetrying", "usage", "ok", "output", "TaskRunExecutionResult", "BatchTaskRunExecutionResult", "items", "EnvironmentType", "TaskRunExecutionPayload", "execution", "traceContext", "record", "ProdTaskRunExecution", "worker", "contentHash", "ProdTaskRunExecutionPayload", "FixedWindowRateLimit", "limit", "window", "seconds", "hours", "SlidingWindowRateLimit", "RateLimitOptions", "concurrencyLimit", "rateLimit", "ScheduleMetadata", "cron", "timezone", "TaskMetadata", "queue", "RetryOptions", "schedule", "TaskFileMetadata", "TaskMetadataWithFilePath", "packageVersion", "QueueOptions", "triggerSource", "PreStopCauses", "test", "Config", "triggerDirectories", "triggerUrl", "projectDir", "tsconfigPath", "retries", "enabledInDev", "additionalPackages", "additionalFiles", "dependenciesToBundle", "union", "logLevel", "enableConsoleLogging", "postInstall", "WaitReason", "enum", "TaskRunExecutionLazyAttemptPayload", "TaskResource", "BackgroundWorkerMetadata", "tasks", "ImageDetailsMetadata", "imageTag", "AbortTaskRunError", "constructor", "Error", "parseError", "stringify", "String", "createErrorTaskError", "e", "stack", "JSON", "SerializedError", "createJsonErrorObject", "replace", "__name", "sanitizeError", "correctErrorStackTrace", "correctStackTraceLine", "isDev", "LINES_TO_IGNORE", "regex", "line", "trim", "groupTaskMetadataIssuesByTask", "issues", "issue", "taskIndex", "acc", "restOfPath", "taskName", "key", "taskId", "existing", "WhoAmIResponseSchema", "userId", "email", "dashboardUrl", "GetProjectResponseBody", "externalRef", "title", "GetProjectsResponseBody", "apiKey", "apiUrl", "localOnly", "metadata", "supportsLazyAttempts", "RunTag", "max", "RunTags", "TriggerTaskRequestBody", "options", "dependentAttempt", "dependentBatch", "lockToVersion", "idempotencyKey", "nonnegative", "TriggerTaskResponse", "BatchTriggerTaskRequestBody", "BatchTriggerTaskResponse", "batchId", "runs", "GetBatchResponseBody", "taskRunId", "AddTagsRequestBody", "GetEnvironmentVariablesResponseBody", "StartDeploymentIndexingRequestBody", "imageReference", "selfHosted", "StartDeploymentIndexingResponseBody", "ExternalBuildData", "buildId", "buildToken", "projectId", "InitializeDeploymentResponseBody", "externalBuildData", "registryHost", "DeploymentErrorData", "stderr", "GetDeploymentResponseBody", "shortCode", "errorData", "CreateUploadPayloadUrlResponseBody", "presignedUrl", "UpdateScheduleOptions", "deduplicationKey", "ScheduleGenerator", "expression", "description", "ScheduleObject", "ScheduleType", "active", "generator", "environments", "userName", "nullish", "ListSchedulesResult", "data", "currentPage", "totalPages", "perPage", "AttemptStatus", "RunEnvironmentDetails", "user", "RunScheduleDetails", "externalId", "CommonRunFields", "RunStatus", "taskIdentifier", "isQueued", "isExecuting", "isCompleted", "isSuccess", "isFailed", "isCancelled", "updatedAt", "finishedAt", "delayedUntil", "ttl", "expiredAt", "RetrieveRunResponse", "payloadPresignedUrl", "outputPresignedUrl", "completedAt", "env", "ListRunResponse", "pagination", "next", "CreateEnvironmentVariableRequestBody", "value", "variables", "override", "success", "EnvironmentVariableValue", "EnvironmentVariables", "BackgroundWorkerServerMessages", "payloads", "taskAttemptId", "image", "envType", "orgId", "serverWebsocketMessages", "SERVER_READY", "BACKGROUND_WORKER_MESSAGE", "BackgroundWorkerClientMessages", "BackgroundWorkerProperties", "clientWebsocketMessages", "READY_FOR_TASKS", "inProgressRuns", "BACKGROUND_WORKER_DEPRECATED", "workerToChildMessages", "EXECUTE_TASK_RUN", "TASK_RUN_COMPLETED_NOTIFICATION", "completion", "CLEANUP", "flush", "kill", "UncaughtExceptionMessage", "origin", "zodIssues", "childToWorkerMessages", "TASK_RUN_COMPLETED", "result", "TASKS_READY", "TASKS_FAILED_TO_PARSE", "TASK_HEARTBEAT", "TASK_RUN_HEARTBEAT", "READY_TO_DISPOSE", "undefined", "WAIT_FOR_DURATION", "WAIT_FOR_TASK", "WAIT_FOR_BATCH", "UNCAUGHT_EXCEPTION", "ProdChildToWorkerMessages", "TaskMetadataFailedToParseData", "now", "waitThresholdInMs", "batchFriendlyId", "runFriendlyIds", "ProdWorkerToChildMessages", "callback", "void", "WAIT_COMPLETED_NOTIFICATION", "ProviderToPlatformMessages", "LOG", "LOG_WITH_ACK", "WORKER_CRASHED", "runId", "reason", "exitCode", "logs", "overrideCompletion", "INDEXING_FAILED", "deploymentId", "PlatformToProviderMessages", "INDEX", "envId", "attemptNumber", "checkpointId", "PRE_PULL_DEPLOYMENT", "imageRef", "CreateWorkerMessage", "projectRef", "cliPackageVersion", "CoordinatorToPlatformMessages", "CREATE_WORKER", "CREATE_TASK_RUN_ATTEMPT", "executionPayload", "READY_FOR_EXECUTION", "READY_FOR_LAZY_ATTEMPT", "lazyPayload", "READY_FOR_RESUME", "attemptFriendlyId", "docker", "location", "TASK_RUN_FAILED_TO_RUN", "CHECKPOINT_CREATED", "ms", "keepRunAlive", "RUN_CRASHED", "PlatformToCoordinatorMessages", "RESUME_AFTER_DEPENDENCY", "completions", "executions", "RESUME_AFTER_DURATION", "attemptId", "REQUEST_ATTEMPT_CANCELLATION", "REQUEST_RUN_CANCELLATION", "delayInMs", "DYNAMIC_CONFIG", "checkpointThresholdInMs", "SharedQueueToClientMessages", "ProdWorkerToCoordinatorMessages", "INDEX_TASKS", "IndexTasksMessage", "totalCompletions", "READY_FOR_CHECKPOINT", "CANCEL_CHECKPOINT", "checkpointCanceled", "willCheckpointAndRestore", "shouldExit", "friendlyId", "UNRECOVERABLE_ERROR", "SET_STATE", "CoordinatorToProdWorkerMessages", "EXECUTE_TASK_RUN_LAZY_ATTEMPT", "REQUEST_EXIT", "READY_FOR_RETRY", "ProdWorkerSocketData", "podName", "deploymentVersion", "CoordinatorSocketData", "supportsDynamicConfig", "PRIMARY_VARIANT", "Variant", "AccessoryItem", "text", "variant", "stringPatternMatchers", "Accessory", "style", "TaskEventStyle", "icon", "$endsWith", "$startsWith", "$ignoreCaseEquals", "EventMatcher", "$anythingBut", "$gt", "$lt", "$gte", "tuple", "EventFilter", "FetchRetryHeadersStrategy", "strategy", "limitHeader", "remainingHeader", "resetHeader", "resetFormat", "FetchRetryStrategy", "FetchRetryBackoffStrategy", "FetchRetryByStatusOptions", "FetchTimeoutOptions", "durationInMs", "byStatus", "timeout", "connectionError", "ExceptionEventProperties", "stacktrace", "ExceptionSpanEvent", "time", "exception", "properties", "OtherSpanEvent", "SpanEvent", "isExceptionSpanEvent", "api", "isCancellationSpanEvent", "SpanMessagingEvent", "system", "operation", "destination", "_globalThis", "globalThis", "GLOBAL_TRIGGER_DOT_DEV_KEY", "Symbol", "registerGlobal", "_global", "allowOverride", "instance", "getGlobal", "unregisterGlobal", "SemanticInternalAttributes", "ENVIRONMENT_ID", "ENVIRONMENT_TYPE", "ORGANIZATION_ID", "ORGANIZATION_SLUG", "ORGANIZATION_NAME", "PROJECT_ID", "PROJECT_REF", "PROJECT_NAME", "PROJECT_DIR", "ATTEMPT_ID", "ATTEMPT_NUMBER", "RUN_ID", "RUN_IS_TEST", "BATCH_ID", "TASK_SLUG", "TASK_PATH", "TASK_EXPORT_NAME", "QUEUE_NAME", "QUEUE_ID", "MACHINE_PRESET_NAME", "MACHINE_PRESET_CPU", "MACHINE_PRESET_MEMORY", "MACHINE_PRESET_CENTS_PER_MS", "SPAN_PARTIAL", "SPAN_ID", "OUTPUT", "OUTPUT_TYPE", "STYLE_ACCESSORY", "METADATA", "TRIGGER", "_TaskContextAPI", "PAYLOAD", "PAYLOAD_TYPE", "SHOW", "SHOW_ACTIONS", "WORKER_ID", "WORKER_VERSION", "CLI_VERSION", "SDK_VERSION", "SDK_LANGUAGE", "RETRY_AT", "RETRY_DELAY", "RETRY_COUNT", "LINK_TITLE", "IDEMPOTENCY_KEY", "USAGE_DURATION_MS", "USAGE_COST_IN_CENTS", "RATE_LIMIT_LIMIT", "RATE_LIMIT_REMAINING", "RATE_LIMIT_RESET", "API_NAME", "TaskContextAPI", "getInstance", "isInsideTask", "ctx", "attributes", "contextAttributes", "workerAttributes", "calculateISO8601DurationOpenAIVariantResetAt", "disable", "setGlobalTaskContext", "taskContext", "calculateUnixTimestampInMsResetAt", "resets", "format", "calculateISO8601ResetAt", "calculateUnixTimestampResetAt", "calculateResetAt", "isNaN", "Date", "resetAt", "parseInt", "match", "minutes", "milliseconds", "setSeconds", "getSeconds", "factor", "minTimeoutInMs", "maxTimeoutInMs", "calculateResetAt2", "_ApiError", "defaultRetryOptions", "calculateNextRetryDelay", "opts", "random", "Math", "ApiError", "makeMessage", "msg", "generate", "errorResponse", "headers", "ApiConnectionError", "BadRequestError", "__publicField", "NotFoundError", "ConflictError", "UnprocessableEntityError", "cause", "millisecondsUntilReset", "resetAtUnixEpochMs", "resetAtUnixEpoch", "RateLimitError", "InternalServerError", "err", "castToError", "NULL_SENTINEL", "flattenAttributes", "obj", "prefix", "newPrefix", "Array", "length", "i", "Object", "isRecord", "assign", "unflattenAttributes", "rehydrateNull", "keys", "entries", "part", "nextPart", "parts", "current", "maxIndex", "arrayResult", "primitiveValueOrflattenedAttributes", "accessoryAttributes", "accessory", "CursorPage", "getPaginatedItems", "hasNextPage", "hasPreviousPage", "getNextPage", "pageFetcher", "getPreviousPage", "page", "asyncIterator", "iterPages", "OffsetLimitPage", "zodfetch", "item", "randomize", "requestOptionsKeys", "schema", "requestInit", "ApiPromise", "zodfetchCursorPage", "query", "URLSearchParams", "params", "after", "before", "cursorPageSchema", "$url", "search", "CursorPagePromise", "fetchResult", "zodfetchOffsetLimitPage", "URL", "toString", "offsetLimitPageSchema", "OffsetLimitPagePromise", "method", "pathname", "span", "safeJsonParse", "traceZodFetch", "$requestInit", "_doZodFetch", "_doZodFetchWithRetries", "response", "responseHeaders", "retryResult", "waitForRetry", "errJSON", "errMessage", "parsedResult", "fromZodError", "shouldRetry", "shouldRetryForOptions", "retryOptions", "shouldRetryHeader", "requestInitWithCache", "fromEntries", "createResponseHeaders", "withCache", "resolve", "responsePromise", "asResponse", "withResponse", "parse", "onrejected", "finally", "Promise", "fetchPage_fn", "_fetchPage", "tracer", "startActiveSpan", "_ApiClient", "__privateAdd", "setTimeout", "isEmptyObj", "hasOwn", "hasOwnProperty", "DEFAULT_ZOD_FETCH_OPTIONS", "ApiClient", "baseUrl", "requestOptions", "accessToken", "defaultRequestOptions", "getRunResult", "mergeRequestOptions", "getBatchResults", "triggerTask", "encodedTaskId", "body", "batchTriggerTask", "createUploadPayloadUrl", "getPayloadUrl", "retrieveRun", "listRuns", "searchParams", "createSearchQueryForListRuns", "ListRunResponseItem", "listProjectRuns", "replayRun", "cancelRun", "CanceledRunResponse", "rescheduleRun", "addTags", "createSchedule", "listSchedules", "append", "retrieveSchedule", "scheduleId", "updateSchedule", "deactivateSchedule", "activateSchedule", "deleteSchedule", "DeletedScheduleObject", "listEnvVars", "importEnvVars", "EnvironmentVariableResponseBody", "retrieveEnvVar", "createEnvVar", "updateEnvVar", "deleteEnvVar", "Authorization", "spanParentAsLink", "from", "to", "defaultOptions", "_ClockAPI", "SimpleClock", "preciseNow", "nowStruct", "reset", "ClockAPI", "_instance", "setGlobalClock", "clock", "SIMPLE_CLOCK", "OTEL_LOG_ATTRIBUTE_COUNT_LIMIT", "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT", "OTEL_SPAN_EVENT_COUNT_LIMIT", "OTEL_LINK_COUNT_LIMIT", "OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", "newAttributes", "imposeAttributeLimits", "_LoggerAPI", "calculateAttributeValueLength", "NoopTaskLogger", "debug", "log", "info", "warn", "trace", "LoggerAPI", "logger", "setGlobalTaskLogger", "NOOP_TASK_LOGGER", "NoopRuntimeManager", "waitForDuration", "waitUntil", "waitForTask", "_UsageAPI", "NoopUsageManager", "start", "cpuTime", "stop", "measurement", "pauseAsync", "sample", "NOOP_USAGE_MANAGER", "UsageAPI", "_RuntimeAPI", "setGlobalUsageManager", "manager", "NOOP_RUNTIME_MANAGER", "RuntimeAPI", "runtime", "getEnvVar", "_APIClientManagerAPI", "waitForBatch", "setGlobalRuntimeManager", "runtimeManager", "config", "process", "APIClientManagerAPI", "setGlobalAPIClientConfiguration", "store", "client", "_TaskCatalogAPI", "NoopTaskCatalog", "registerTaskMetadata", "registerTaskFileMetadata", "taskCatalog2", "updateTaskMetadata", "updates", "getAllTaskMetadata", "getTaskMetadata", "getTask", "taskExists", "TaskCatalogAPI", "taskCatalog", "dateDifference", "formatDuration", "end", "formatDurationMilliseconds", "nanosecondsToMilliseconds", "nanoseconds", "millisecondsToNanoseconds", "formatDurationNanoseconds", "belowOneSecondUnits", "duration", "maxDecimalPoints", "largest", "formatDurationInDays", "units", "TriggerTracer", "_config", "_logger", "extractContext", "fn", "parentContext", "startTime", "eventFilterMatches", "setAttributes", "startSpan", "contentFiltersMatches", "patternKey", "patternValue", "includes", "contentFilterMatches", "payloadValue", "objectArray", "contentFilter", "contentFilters", "actualValue", "sensitivity", "$isNull", "detectDependencyVersion", "parsePacket", "stringifyIO", "dataType", "conditionallyExportPacket", "needsOffloading", "pathPrefix", "packet", "byteSize", "lengthLimit", "size", "packetRequiresOffloading", "presignedResponse", "apiClientManager", "filename", "uploadResponse", "fetch", "exportPacket", "conditionallyImportPacket", "importPacket", "createPacketAttributes", "dataKey", "dataTypeKey", "safeJsonParse2", "safeReplacer", "createPacketAttributesAsJson", "deserialize", "prettyPrintPacket", "rawData", "exports", "RegExp", "v", "outputType", "getPacketExtension", "loadSuperJSON", "SpanKind", "z", "parseError", "error", "__privateGet", "name", "stack", "type", "raw", "JSON", "SerializedError", "message", "stackTrace", "sanitizeError", "replace", "code", "DiagConsoleLogger", "logs", "OTLPLogExporter", "OTLPTraceExporter", "registerInstrumentations", "OTEL_LOG_ATTRIBUTE_COUNT_LIMIT", "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT", "OTEL_LOG_ATTRIBUTE_VALUE_LENGTH_LIMIT", "OTEL_SPAN_EVENT_COUNT_LIMIT", "OTEL_LINK_COUNT_LIMIT", "OTEL_ATTRIBUTE_PER_LINK_COUNT_LIMIT", "OTEL_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", "OFFLOAD_IO_PACKET_LENGTH_LIMIT", "ENVIRONMENT_ID", "ENVIRONMENT_TYPE", "ORGANIZATION_ID", "ORGANIZATION_SLUG", "ORGANIZATION_NAME", "PROJECT_ID", "PROJECT_REF", "PROJECT_NAME", "PROJECT_DIR", "ATTEMPT_ID", "ATTEMPT_NUMBER", "RUN_ID", "RUN_IS_TEST", "BATCH_ID", "TASK_SLUG", "TASK_PATH", "TASK_EXPORT_NAME", "QUEUE_NAME", "QUEUE_ID", "MACHINE_PRESET_NAME", "MACHINE_PRESET_CPU", "MACHINE_PRESET_MEMORY", "MACHINE_PRESET_CENTS_PER_MS", "SPAN_PARTIAL", "SPAN_ID", "OUTPUT", "OUTPUT_TYPE", "STYLE", "STYLE_ICON", "STYLE_VARIANT", "STYLE_ACCESSORY", "METADATA", "TRIGGER", "PAYLOAD", "PAYLOAD_TYPE", "SHOW", "SHOW_ACTIONS", "WORKER_ID", "WORKER_VERSION", "CLI_VERSION", "SDK_VERSION", "SDK_LANGUAGE", "RETRY_AT", "RETRY_DELAY", "RETRY_COUNT", "LINK_TITLE", "IDEMPOTENCY_KEY", "USAGE_DURATION_MS", "USAGE_COST_IN_CENTS", "RATE_LIMIT_LIMIT", "RATE_LIMIT_REMAINING", "RATE_LIMIT_RESET", "flattenAttributes", "result", "obj", "undefined", "prefix", "newPrefix", "Array", "value", "i", "Object", "assign", "NULL_SENTINEL", "__name", "isRecord", "_global", "_globalThis", "registerGlobal", "api", "GLOBAL_TRIGGER_DOT_DEV_KEY", "allowOverride", "Error", "instance", "getGlobal", "unregisterGlobal", "API_NAME", "TaskContextAPI", "__privateAdd", "getInstance", "_instance", "isInsideTask", "__privateMethod", "ctx", "worker", "attributes", "contextAttributes", "workerAttributes", "SemanticInternalAttributes", "id", "version", "attempt", "number", "task", "filePath", "exportName", "queue", "environment", "organization", "project", "ref", "run", "isTest", "slug", "batch", "idempotencyKey", "machine", "cpu", "memory", "centsPerMs", "disable", "setGlobalTaskContext", "taskContext", "TaskContextSpanProcessor", "constructor", "innerProcessor", "_innerProcessor", "onStart", "span", "parentContext", "setAttributes", "onEnd", "shutdown", "forceFlush", "TaskContextLogProcessor", "onEmit", "logRecord", "context", "getEnvVar", "process", "env", "_a", "AsyncResourceDetector", "_resolved", "_promise", "Promise", "resolver", "_resolver", "detect", "_config", "Resource", "resolveWithAttributes", "TracingSDK", "config", "asyncResourceDetector", "setLogLevel", "diagLogLevel", "envResourceAttributesSerialized", "envResourceAttributes", "parse", "commonResources", "detectResourcesSync", "detectors", "processDetectorSync", "merge", "SemanticResourceAttributes", "resource", "traceProvider", "NodeTracerProvider", "forceFlushTimeoutMillis", "spanLimits", "attributeCountLimit", "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT", "attributeValueLengthLimit", "eventCountLimit", "attributePerEventCountLimit", "linkCountLimit", "attributePerLinkCountLimit", "spanExporter", "url", "timeoutMillis", "addSpanProcessor", "BatchSpanProcessor", "maxExportBatchSize", "parseInt", "scheduledDelayMillis", "exportTimeoutMillis", "maxQueueSize", "SimpleSpanProcessor", "register", "instrumentations", "tracerProvider", "logExporter", "loggerProvider", "LoggerProvider", "logRecordLimits", "addLogRecordProcessor", "BatchLogRecordProcessor", "SimpleLogRecordProcessor", "_logProvider", "_spanExporter", "_traceProvider", "setGlobalLoggerProvider", "getLogger", "bind", "getTracer", "flush", "all", "level", "DiagLogLevel", "NONE", "ERROR", "WARN", "INFO", "DEBUG", "VERBOSE", "ALL", "diag", "setLogger", "recordSpanException", "recordException", "sanitizeSpanError", "stringify", "setStatus", "SpanStatusCode", "sanitizedError", "MachineCpu", "literal", "MachinePresetName", "enum", "MachineConfig", "optional", "MachineMemory", "preset", "MachinePreset", "TaskRunBuiltInError", "string", "TaskRunCustomErrorObject", "object", "COULD_NOT_FIND_EXECUTOR", "CONFIGURED_INCORRECTLY", "TASK_ALREADY_RUNNING", "TASK_EXECUTION_FAILED", "TASK_EXECUTION_ABORTED", "TASK_PROCESS_EXITED_WITH_NON_ZERO_CODE", "TASK_PROCESS_SIGKILL_TIMEOUT", "TASK_RUN_CANCELLED", "TASK_OUTPUT_ERROR", "HANDLE_ERROR_ERROR", "GRACEFUL_EXIT_TIMEOUT", "TASK_RUN_CRASHED", "TaskRunInternalError", "TaskRunError", "discriminatedUnion", "TaskRunStringError", "payload", "tags", "array", "boolean", "default", "createdAt", "coerce", "date", "maxAttempts", "durationMs", "costInCents", "baseCostInCents", "TaskRunExecutionAttempt", "startedAt", "backgroundWorkerId", "status", "TaskRunExecutionEnvironment", "TaskRunExecutionOrganization", "TaskRunExecutionQueue", "TaskRunExecutionBatch", "TaskRunExecution", "TaskRunExecutionTask", "TaskRun", "TaskRunExecutionProject", "TaskRunContext", "omit", "payloadType", "TaskRunExecutionRetry", "timestamp", "delay", "TaskRunExecutionUsage", "TaskRunFailedExecutionResult", "ok", "retry", "skippedRetrying", "TaskRunSuccessfulExecutionResult", "usage", "BatchTaskRunExecutionResult", "items", "TaskRunExecutionResult", "EnvironmentType", "TaskRunExecutionPayload", "execution", "traceContext", "contentHash", "ProdTaskRunExecutionPayload", "ProdTaskRunExecution", "FixedWindowRateLimit", "window", "seconds", "minutes", "hours", "SlidingWindowRateLimit", "concurrencyLimit", "rateLimit", "RateLimitOptions", "cron", "timezone", "packageVersion", "QueueOptions", "RetryOptions", "triggerSource", "schedule", "ScheduleMetadata", "TaskFileMetadata", "PostStartCauses", "RegexSchema", "custom", "val", "test", "triggerDirectories", "triggerUrl", "projectDir", "tsconfigPath", "retries", "enabledInDev", "additionalPackages", "additionalFiles", "dependenciesToBundle", "logLevel", "enableConsoleLogging", "postInstall", "extraCACerts", "TaskRunExecutionLazyAttemptPayload", "runId", "attemptCount", "messageId", "record", "unknown", "TaskResource", "BackgroundWorkerMetadata", "cliPackageVersion", "ImageDetailsMetadata", "imageTag", "WhoAmIResponseSchema", "userId", "email", "dashboardUrl", "externalRef", "GetProjectsResponseBody", "GetProjectEnvResponse", "apiKey", "apiUrl", "localOnly", "supportsLazyAttempts", "CreateBackgroundWorkerResponse", "RunTag", "RunTags", "union", "TriggerTaskRequestBody", "any", "options", "dependentAttempt", "lockToVersion", "ttl", "nonnegative", "int", "TriggerTaskResponse", "BatchTriggerTaskRequestBody", "BatchTriggerTaskResponse", "batchId", "runs", "taskRunId", "RescheduleRunRequestBody", "GetEnvironmentVariablesResponseBody", "variables", "imageReference", "selfHosted", "StartDeploymentIndexingResponseBody", "ExternalBuildData", "buildToken", "projectId", "shortCode", "registryHost", "InitializeDeploymentRequestBody", "DeploymentErrorData", "stderr", "GetDeploymentResponseBody", "errorData", "nullable", "tasks", "presignedUrl", "lastTimestamp", "UpdateScheduleOptions", "deduplicationKey", "ScheduleGenerator", "expression", "description", "ScheduleObject", "active", "generator", "nextRun", "environments", "DeletedScheduleObject", "ListSchedulesResult", "data", "currentPage", "page", "timezones", "RunEnvironmentDetails", "user", "RunScheduleDetails", "externalId", "CommonRunFields", "RunStatus", "taskIdentifier", "isQueued", "isExecuting", "isCompleted", "isSuccess", "isFailed", "isCancelled", "updatedAt", "finishedAt", "delayedUntil", "expiredAt", "RetrieveRunResponse", "payloadPresignedUrl", "outputPresignedUrl", "attempts", "AttemptStatus", "completedAt", "ListRunResponseItem", "ListRunResponse", "pagination", "previous", "CreateEnvironmentVariableRequestBody", "ImportEnvironmentVariablesRequestBody", "override", "success", "EnvironmentVariableValue", "EnvironmentVariable", "EnvironmentVariables", "propagation", "fromZodError", "defaultRetryOptions", "minTimeoutInMs", "_ApiError", "maxTimeoutInMs", "randomize", "defaultFetchRetryOptions", "byStatus", "strategy", "connectionError", "timeout", "calculateNextRetryDelay", "opts", "random", "Math", "round", "ApiError", "headers", "makeMessage", "param", "msg", "errorResponse", "BadRequestError", "__publicField", "AuthenticationError", "PermissionDeniedError", "UnprocessableEntityError", "RateLimitError", "cause", "NotFoundError", "ConflictError", "resetAtUnixEpochMs", "resetAtUnixEpoch", "InternalServerError", "castToError", "err", "accessoryAttributes", "accessory", "getPaginatedItems", "hasNextPage", "next", "hasPreviousPage", "getNextPage", "pageFetcher", "getPreviousPage", "iterPages", "Symbol", "asyncIterator", "item", "CursorPage", "zodfetch", "OffsetLimitPage", "factor", "schema", "ApiPromise", "_doZodFetch", "zodfetchCursorPage", "params", "query", "set", "String", "after", "cursorPageSchema", "$url", "URL", "fetchResult", "CursorPagePromise", "zodfetchOffsetLimitPage", "limit", "offsetLimitPageSchema", "search", "callback", "requestInitWithCache", "method", "requestInit", "startActiveSpan", "safeJsonParse", "traceZodFetch", "$requestInit", "_doZodFetchWithRetries", "response", "retryResult", "waitForRetry", "errText", "parsedResult", "ApiConnectionError", "shouldRetry", "shouldRetryForOptions", "shouldRetryHeader", "text", "createResponseHeaders", "Request", "withCache", "resolve", "asResponse", "withResponse", "catch", "onrejected", "finally", "onfinally", "_fetchPage", "fetchPage_fn", "OffsetLimitPagePromise", "tracer", "_ApiClient", "variant", "style", "setTimeout", "DEFAULT_ZOD_FETCH_OPTIONS", "ApiClient", "baseUrl", "accessToken", "getRunResult", "mergeRequestOptions", "defaultRequestOptions", "requestOptions", "getBatchResults", "triggerTask", "taskId", "encodedTaskId", "encodeURIComponent", "body", "batchTriggerTask", "createUploadPayloadUrl", "filename", "CreateUploadPayloadUrlResponseBody", "getPayloadUrl", "retrieveRun", "listRuns", "createSearchQueryForListRuns", "searchParams", "before", "listProjectRuns", "replayRun", "ReplayRunResponse", "cancelRun", "CanceledRunResponse", "rescheduleRun", "addTags", "createSchedule", "listSchedules", "toString", "perPage", "append", "retrieveSchedule", "updateSchedule", "deactivateSchedule", "activateSchedule", "deleteSchedule", "scheduleId", "listEnvVars", "projectRef", "importEnvVars", "EnvironmentVariableResponseBody", "retrieveEnvVar", "createEnvVar", "updateEnvVar", "deleteEnvVar", "spanParentAsLink", "Authorization", "inject", "URLSearchParams", "from", "_APIClientManagerAPI", "to", "period", "defaultOptions", "setGlobalAPIClientConfiguration", "baseURL", "store", "client", "APIClientManagerAPI", "apiClientManager", "parsePacket", "stringifyIO", "dataType", "exportPacket", "pathPrefix", "byteLength", "packet", "conditionallyExportPacket", "needsOffloading", "size", "byteSize", "packetRequiresOffloading", "uploadResponse", "conditionallyImportPacket", "presignedResponse", "setAttribute", "importPacket", "loadSuperJSON", "parsed", "dataKey", "dataTypeKey", "createPacketAttributes", "Map", "forEach", "k", "v", "safeReplacer", "getPacketExtension", "outputType", "usage2", "TaskExecutor", "_tracingSDK", "tracingSDK", "_tracer", "_consoleInterceptor", "projectConfig", "_importedConfig", "importedConfig", "_handleErrorFn", "handleErrorFn", "execute", "attemptMessage", "originalPacket", "parsedPayload", "initOutput", "finalOutput", "stringifyError", "TaskRunErrorCodes", "handleErrorResult", "kind", "extractContext", "middlewareFn", "runFn", "init", "fns", "onSuccessFn", "output", "onFailureFn", "cleanupFn", "retriesConfig", "max", "rateLimitError", "millisecondsUntilReset", "retryDelayInMs", "retryAt", "skipRetrying", "Date", "PreciseWallClock", "_origin", "clockTime", "origin", "preciseDate", "preciseNow", "elapsedHrTime", "elapsedNanoseconds", "PreciseDate", "dateStruct", "reset", "SeverityNumber", "iconStringForSeverity", "severityNumber", "DEBUG2", "INFO2", "INFO4", "WARN4", "_ClockAPI", "ERROR4", "clock2", "FATAL3", "SimpleClock", "now", "nowStruct", "logLevels", "SIMPLE_CLOCK", "ClockAPI", "setGlobalClock", "clock", "OtelTaskLogger", "debug", "_level", "properties", "warn", "trace", "safeJsonProcess", "icon", "severityText", "jsonErrorReplacer", "ConsoleInterceptor", "_getTimestampInHrTime", "logger", "sendToStdIO", "intercept", "console", "info", "log", "args", "util", "write", "emit", "getTimestampInHrTime_fn", "getLogMessage", "fallback", "tryParseJSON", "e", "_taskMetadata", "_taskFunctions", "_taskFileMetadata", "registerTaskMetadata", "updateTaskMetadata", "existingMetadata", "updates", "registerTaskFileMetadata", "metadata", "fileMetadata", "push", "getTaskMetadata", "_UsageAPI", "taskExists", "StandardTaskCatalog", "NoopUsageManager", "start", "sample", "cpuTime", "measurement", "pauseAsync", "cb", "NOOP_USAGE_MANAGER", "UsageAPI", "_a2", "setGlobalUsageManager", "calculateDurationInMs", "startSeconds", "startNanoseconds", "endSeconds", "endNanoseconds", "end", "nanoseconds", "DevUsageMeasurement", "_pauses", "stop", "_endedAt", "wallTime", "totalPauses", "registerPause", "_currentMeasurements", "_firstMeasurement", "pauseId", "pauseStart", "pauseEnd", "DevUsageManager", "generateRandomString", "characters", "charactersLength", "charAt", "floor", "setInterval", "sendUsageEvent", "event", "accept", "renewedJwt", "UsageClient", "ProdUsageManager", "_usageClient", "isReportingEnabled", "delegageUsageManager", "_measurement", "exports", "setInterval", "maxDelay", "fullTimeouts", "remainingDelay", "delay", "lastTimeoutResult", "setTimeout", "unboundedTimeout", "_taskWaits", "_batchWaits", "Map", "_pendingCompletionNotifications", "disable", "ms", "waitForDuration", "pendingCompletion", "set", "params", "id", "resolve", "length", "Promise", "items", "reject", "results", "resumeTask", "wait", "runId", "DevRuntimeManager", "__name", "z", "constructor", "payload", "error", "message", "Error", "__name", "ZodSchemaParsedError", "ZodMessageSchema", "object", "version", "default", "type", "string", "unknown", "ZodMessageHandler", "__privateAdd", "_logger", "options", "__privateSet", "messages", "logger", "console", "parsedMessage", "parseMessage", "success", "__privateGet", "handler", "data", "ack", "schema", "parsedPayload", "registerHandlers", "log", "emitter", "on", "callback", "info", "eventName", "hasCallback", "handleMessage", "_schema", "ZodMessageSender", "sender", "import_v3", "import_workers", "import_zodMessageHandler", "ulid", "__defProp", "addMissingVersionField", "val", "z", "message", "name", "string", "optional", "stack", "SchemaErrorSchema", "object", "path", "array", "stringPatternMatchers", "$ignoreCaseEquals", "EventMatcherSchema", "boolean", "$exists", "$isNull", "$anythingBut", "union", "number", "$gte", "$between", "$includes", "EventFilterSchema", "lazy", "EventRuleSchema", "event", "source", "payload", "context", "ConnectionAuthSchema", "type", "accessToken", "scopes", "additionalFields", "IntegrationMetadataSchema", "id", "IntegrationConfigSchema", "metadata", "authSource", "LiteralSchema", "record", "DeserializedJsonSchema", "date", "symbol", "SerializableJsonSchema", "label", "url", "z", "string", "optional", "StyleSchema", "object", "style", "SCHEDULED_EVENT", "ScheduledPayloadSchema", "lastTimestamp", "date", "IntervalOptionsSchema", "seconds", "CronOptionsSchema", "cron", "options", "accountId", "metadata", "any", "IntervalMetadataSchema", "type", "ScheduleMetadataSchema", "CronMetadataSchema", "RegisterDynamicSchedulePayloadSchema", "id", "jobs", "array", "version", "TaskStatusSchema", "TaskSchema", "icon", "nullable", "noop", "boolean", "startedAt", "coerce", "completedAt", "status", "description", "properties", "DisplayPropertySchema", "outputProperties", "params", "DeserializedJsonSchema", "output", "context", "parentId", "operation", "callbackUrl", "childExecutionMode", "ServerTaskSchema", "idempotencyKey", "attempts", "forceYield", "CachedTaskSchema", "name", "payload", "or", "title", "source", "schema", "DynamicTriggerMetadataSchema", "literal", "noRuns", "StaticTriggerMetadataSchema", "union", "rule", "EventRuleSchema", "link", "InvokeTriggerMetadataSchema", "ScheduledTriggerMetadataSchema", "schedule", "StatusUpdateStateSchema", "StatusUpdateDataSchema", "record", "label", "data", "InitalStatusUpdateSchema", "StatusUpdateSchema", "JobRunStatusRecordSchema", "RunStatusSchema", "RunTaskSchema", "displayKey", "RunTaskWithSubtasksSchema", "updatedAt", "GetRunSchema", "RunSchema", "nextCursor", "RequestFilterSchema", "method", "HTTPMethodUnionSchema", "headers", "ResponseFilterSchema", "query", "extend", "secret", "UpdateTriggerSourceBodyV2Schema", "secret", "z", "string", "data", "SerializableJsonSchema", "options", "object", "event", "array", "and", "record", "UpdateWebhookBodySchema", "active", "literal", "config", "type", "url", "type", "RegisterSQSTriggerSourceBodySchema", "z", "literal", "RegisterSourceChannelBodySchema", "RegisterHTTPTriggerSourceBodySchema", "RegisterSMTPTriggerSourceBodySchema", "REGISTER_WEBHOOK", "DELIVER_WEBHOOK_REQUEST", "RegisterWebhookSourceSchema", "params", "active", "boolean", "secret", "url", "string", "data", "DeserializedJsonSchema", "optional", "clientId", "config", "object", "current", "record", "REGISTER_SOURCE_EVENT_V1", "REGISTER_SOURCE_EVENT_V2", "RegisterTriggerSourceSchema", "key", "SourceEventOptionSchema", "name", "value", "RegisterSourceEventSchemaV1", "source", "events", "array", "missingEvents", "orphanedEvents", "dynamicTriggerId", "RegisteredOptionsDiffSchema", "desired", "missing", "orphaned", "RegisterSourceEventOptionsSchema", "event", "and", "id", "options", "HttpSourceResponseMetadataSchema", "HandleTriggerSourceSchema", "any", "auth", "ConnectionAuthSchema", "metadata", "HttpSourceRequestHeadersSchema", "transform", "s", "undefined", "JSON", "parse", "WebhookSourceRequestHeadersSchema", "PongSuccessResponseSchema", "ok", "triggerSdkVersion", "PongErrorResponseSchema", "error", "triggerVersion", "PongResponseSchema", "endpointId", "ValidateErrorResponseSchema", "ValidateSuccessResponseSchema", "QueueOptionsSchema", "maxConcurrent", "ConcurrencyLimitOptionsSchema", "limit", "JobMetadataSchema", "version", "trigger", "TriggerMetadataSchema", "integrations", "internal", "enabled", "startPosition", "enum", "concurrencyLimit", "int", "channel", "integration", "IntegrationConfigSchema", "registerSourceJob", "SourceMetadataV2Schema", "SourceMetadataSchema", "SourceMetadataV1Schema", "WebhookMetadataSchema", "httpEndpoint", "WebhookContextMetadataSchema", "jobs", "HttpEndpointMetadataSchema", "icon", "properties", "DisplayPropertySchema", "EventSpecificationSchema", "immediateResponseFilter", "RequestFilterSchema", "skipTriggeringRuns", "IndexEndpointResponseSchema", "sources", "webhooks", "dynamicTriggers", "DynamicTriggerEndpointMetadataSchema", "dynamicSchedules", "httpEndpoints", "EndpointIndexErrorSchema", "message", "raw", "number", "disabledJobs", "default", "stats", "IndexEndpointStatsSchema", "GetEndpointIndexResponseSchema", "updatedAt", "coerce", "date", "EndpointHeadersSchema", "ExecuteJobRunMetadataSchema", "successSubscription", "failedSubscription", "ExecuteJobHeadersSchema", "RawEventSchema", "payload", "timestamp", "deliverAt", "cancelledAt", "SendEventOptionsSchema", "deliverAfter", "accountId", "SendEventBodySchema", "DeliverEventResponseSchema", "deliveredAt", "RuntimeEnvironmentTypeSchema", "RunSourceContextSchema", "AutoYieldConfigSchema", "startTaskThreshold", "beforeExecuteTaskThreshold", "beforeCompleteTaskThreshold", "afterCompleteTaskThreshold", "RunJobBodySchema", "ApiEventLogSchema", "job", "run", "isTest", "isRetry", "environment", "organization", "title", "project", "account", "tasks", "CachedTaskSchema", "cachedTaskCursor", "connections", "yieldedExecutions", "runChunkExecutionLimit", "RunJobErrorSchema", "status", "ErrorWithStackSchema", "task", "TaskSchema", "location", "timeRemaining", "timeElapsed", "RunJobAutoYieldWithCompletedTaskExecutionErrorSchema", "output", "reset", "errors", "retryAt", "RunJobErrorResponseSchema", "RunJobAutoYieldExecutionErrorSchema", "RunJobYieldExecutionErrorSchema", "RunJobAutoYieldRateLimitErrorSchema", "RunJobUnresolvedAuthErrorSchema", "RunJobInvalidPayloadErrorSchema", "RunJobResumeWithTaskSchema", "RunJobRetryWithTaskSchema", "RunJobCanceledWithTaskSchema", "RunJobResumeWithParallelTaskSchema", "childErrors", "RunJobResponseSchema", "RunJobSuccessSchema", "slug", "PreprocessRunResponseSchema", "CreateRunResponseOkSchema", "CreateRunResponseErrorSchema", "CreateRunResponseBodySchema", "RedactStringSchema", "strings", "level", "paths", "RetryOptionsSchema", "factor", "randomize", "RunTaskOptionsSchema", "delayUntil", "displayKey", "description", "style", "callback", "timeoutInSeconds", "connectionKey", "operation", "noop", "redact", "RedactSchema", "RunTaskBodyInputSchema", "parentId", "RunTaskBodyOutputSchema", "RunTaskResponseWithCachedTasksBodySchema", "cachedTasks", "cursor", "CompleteTaskBodyInputSchema", "CompleteTaskBodyV2InputSchema", "FailTaskBodyInputSchema", "NormalizedRequestSchema", "headers", "query", "body", "NormalizedResponseSchema", "HttpSourceResponseSchema", "response", "WebhookDeliveryResponseSchema", "verified", "rule", "EventRuleSchema", "RegisterTriggerBodySchemaV2", "InitializeTriggerBodySchema", "RegisterCommonScheduleBodySchema", "RegisterIntervalScheduleBodySchema", "InitializeCronScheduleBodySchema", "RegisterScheduleBodySchema", "discriminatedUnion", "RegisterScheduleResponseBodySchema", "schedule", "ScheduleMetadataSchema", "CreateExternalConnectionBodySchema", "accessToken", "scopes", "GetRunStatusesSchema", "RunStatusSchema", "statuses", "InvokeJobRequestBodySchema", "context", "callbackUrl", "InvokeOptionsSchema", "idempotencyKey", "EphemeralEventDispatcherRequestBodySchema", "filter", "EventFilterSchema", "contextFilter", "EphemeralEventDispatcherResponseBodySchema", "action", "deleted", "MISSING_CONNECTION_RESOLVED_NOTIFICATION", "client", "createdAt", "authorizationUrl", "MissingDeveloperConnectionNotificationPayloadSchema", "CommonMissingConnectionNotificationPayloadSchema", "MissingConnectionNotificationPayloadSchema", "MissingExternalConnectionNotificationPayloadSchema", "CommonMissingConnectionNotificationResolvedPayloadSchema", "integrationAuthMethod", "expiresAt", "MissingDeveloperConnectionResolvedNotificationPayloadSchema", "MissingConnectionResolvedNotificationPayloadSchema", "MissingExternalConnectionResolvedNotificationPayloadSchema", "FetchRetryHeadersStrategySchema", "limitHeader", "remainingHeader", "resetHeader", "bodyFilter", "resetFormat", "FetchRetryBackoffStrategySchema", "union", "instanceof", "ArrayBuffer", "FetchRetryOptionsSchema", "FetchTimeoutOptionsSchema", "durationInMs", "FetchOperationSchema", "requestInit", "FetchRequestInitSchema", "retry", "FetchRetryStrategySchema", "FetchPollOperationSchema", "requestTimeout", "GetEventSchema", "completedAt", "CancelRunsForEventSchema", "cancelledRunIds", "failedToCancelRunIds", "RequestWithRawBodySchema", "method", "rawBody", "CancelRunsForJobSchema", "deepMergeFilters", "result", "hasOwnProperty", "existingValue", "filterValue", "assertExhaustive", "DEFAULT_RETRY_OPTIONS", "minTimeoutInMs", "maxTimeoutInMs", "calculateRetryAt", "retryOptions", "retryCount", "random", "timeoutInMs", "calculateResetAt", "resets", "format", "calculateISO8601DurationOpenAIVariantResetAt", "calculateISO8601ResetAt", "now", "calculateUnixTimestampResetAt", "calculateUnixTimestampInMsResetAt", "resetAt", "parseInt", "isNaN", "calculateISO8601ResetAt", "calculateISO8601DurationOpenAIVariantResetAt", "resets", "pattern", "match", "undefined", "minutes", "parseInt", "resetAt", "getHours", "hours", "setMinutes", "setSeconds", "getSeconds", "Math", "setMilliseconds", "currentDate", "marker", "replace", "now", "currentTimestampMilliseconds", "getTime", "currentTimestampSeconds", "replacements", "urlWithSearchParams", "urlObj", "URL", "url", "value", "Object", "entries", "toString", "eventFilterMatches", "filter", "patternKey", "item", "includes", "payloadValue", "patternValue", "every", "contentFiltersMatches", "actualValue", "contentFilter", "contentFilterMatches", "$gt", "$gte", "$between", "sensitivity", "$isNull", "Array", "isArray", "$not", "clonedRequest", "requestMethodMatches", "searchParams", "searchParamsObject", "json", "body", "requestFilterMatches", "response", "version", "Buffer", "constructor", "size", "_BloomFilter", "bitArray", "add", "index", "Math", "test", "floor", "BloomFilter", "filter", "Uint8Array", "from", "__name", "NOOP_TASK_SET_SIZE", "murmurHash3", "h1", "seed", "h2", "i", "length", "ch", "str", "charCodeAt", "imul", "_Logger", "Logger", "name", "level", "filteredKeys", "createReplacer", "jsonReplacer", "additionalFields", "child", "satisfiesLogLevel", "logLevel", "setLevel", "log", "error", "warn", "info", "debug", "loggerFunction", "getSpan", "context", "structuredLog", "timestamp", "Date", "currentSpan", "parentSpanId", "stringify", "value", "bigIntReplacer", "toString", "safeJsonClone", "structureArgs", "args", "JSON", "filterKeys", "obj", "keys", "isArray", "item", "filteredObj", "includes", "key", "prettyPrintBytes", "env", "NODE_ENV", "sizeInBytes", "getSizeInBytes", "__accessCheck", "AsyncLocalStorage", "TypedAsyncLocalStorage", "constructor", "__privateMethod", "runWith", "context", "fn", "getStore", "_TypedAsyncLocalStorage", "storage", "runLocalStorage", "__name", "replaceSpacesWithDash", "Job", "_Job", "attachToClient", "client", "options", "Object", "integration", "acc", "metadata", "toJSON", "internal", "id", "name", "version", "trigger", "integrations", "startPosition", "enabled", "preprocessRuns", "concurrencyLimit", "undefined", "triggerClient", "Error", "runStore", "param3", "result", "invokeJob", "idempotencyKey", "task", "label", "text", "params", "param2", "properties", "runTask", "callbackUrl", "outputProperties", "ctx", "slug", "payload", "callback", "timeoutInSeconds", "batch", "length", "results", "io", "url", "project", "API_VERSIONS", "ErrorWithStackSchema", "HttpEndpointRequestHeadersSchema", "EventEmitter", "env", "Logger", "z", "supportsFeature", "_ResumeWithParallelTaskError", "webcrypto", "_RetryWithTaskError", "ResumeWithTaskError", "ResumeWithParallelTaskError", "childErrors", "_CanceledWithTaskError", "cause", "retryAt", "RetryWithTaskError", "CanceledWithTaskError", "key", "_AutoYieldWithCompletedTaskExecutionError", "YieldExecutionError", "AutoYieldExecutionError", "location", "AutoYieldWithCompletedTaskExecutionError", "data", "output", "AutoYieldRateLimitError", "resetAtTimestamp", "ParsedPayloadSchemaError", "schemaErrors", "factor", "_TriggerStatus", "minTimeoutInMs", "maxTimeoutInMs", "randomize", "exponentialBackoff", "limit", "TriggerStatus", "constructor", "id", "io", "update", "key", "status", "label", "properties", "text", "state", "name", "params", "__name", "icon", "optional", "payload", "any", "__privateAdd", "waitForEventSchema", "z", "string", "schema", "timestamp", "coerce", "context", "accountId", "KeyValueStore", "__privateMethod", "delete", "runStore", "store", "param2", "style", "param1", "apiClient", "value", "String", "parts", "type", "_JSONOutputSerializer", "push", "_IO", "serialize", "JSON", "stringify", "deserialize", "parse", "JSONOutputSerializer", "IO", "options", "_outputSerializer", "_visitedCacheKeys", "brb", "bind", "_id", "_apiClient", "_logger", "logger", "Logger", "_cachedTasks", "_jobLogger", "jobLogger", "_jobLogLevel", "_timeOrigin", "timeOrigin", "_envStore", "_jobStore", "_stats", "initialCachedTasks", "cachedTaskHits", "cachedTaskMisses", "cachedTasks", "_taskStorage", "AsyncLocalStorage", "_context", "_yieldedExecutions", "noopTasksSet", "_noopTasksBloomFilter", "_serverVersion", "serverVersion", "stats", "runId", "triggerClient", "_triggerClient", "logLevel", "data", "Error", "message", "stack", "level", "task", "description", "noop", "min", "max", "withinBounds", "rounded", "round", "wait", "cacheKey", "runTask", "seconds", "delayUntil", "waitForEvent", "callbackUrl", "url", "event", "filter", "contextFilter", "source", "timeoutInSeconds", "callback", "parseOutput", "output", "waitForRequest", "createStatus", "backgroundFetch", "requestInit", "console", "log", "urlObject", "retry", "timeout", "operation", "backgroundPoll", "interval", "backgroundFetchResponse", "method", "sendEventOptionsProperties", "sendEvents", "events", "cancelEvent", "eventId", "updateSource", "updateWebhook", "unregisterInterval", "dynamicSchedule", "unregister", "unregisterCron", "registration", "trigger", "clientId", "outcomes", "outcome", "map", "nonInternalErrors", "parallel", "results", "getStore", "parentId", "debug", "isSubtaskNoop", "idempotencyKey", "flat", "cachedTask", "noopCachedTaskHits", "runOptions", "undefined", "response", "displayKey", "API_VERSIONS", "LAZY_LOADED_CACHED_TASKS", "_cachedTasksCursor", "body", "lazyLoadedCachedTasks", "CanceledWithTaskError", "ErrorWithTask", "error", "executeTask", "result", "completedTask", "executedTasks", "deserializedOutput", "isTriggerError", "skipRetrying", "onError", "onErrorResult", "ErrorWithStackSchema", "safeParse", "innerError", "parsedError", "retryAt", "calculateRetryAt", "taskId", "ResumeWithTaskError", "yield", "warn", "tryCallback", "_runStore", "cachedTasksCursor", "timeRemaining", "AutoYieldWithCompletedTaskExecutionError", "location", "timeElapsed", "AutoYieldExecutionError", "performance", "_executionTimeout", "keys", "stableStringify", "webcrypto", "subtle", "Buffer", "hash", "generateIdempotencyKey", "sortKeys", "obj", "Array", "isArray", "sortedObj", "sortedKeys", "IOLogger", "_KeyValueStoreClient", "deliverAfter", "_namespacedKey", "namespacedKey_fn", "KeyValueStoreClient", "queryStore", "namespace", "action", "__privateGet", "has", "_UnknownVersionError", "version2", "_ApiClient", "join", "UnknownVersionError", "version", "MAX_RETRIES", "EXPONENT_FACTOR", "MIN_DELAY_IN_MS", "MAX_DELAY_IN_MS", "JITTER_IN_MS", "ApiClient", "registerEndpoint", "headers", "Authorization", "json", "zodfetchWithVersions", "ServerTaskSchema", "apiKey", "completeTask", "failTask", "sendEvent", "client", "zodfetch", "CancelRunsForEventSchema", "updateStatus", "JobRunStatusRecordSchema", "webhookData", "registerSchedule", "RegisterScheduleResponseBodySchema", "unregisterSchedule", "getAuth", "ConnectionAuthSchema", "getEvent", "GetEventSchema", "getRunStatuses", "jobSlug", "GetRunsSchema", "jobId", "cancelRunsForJob", "CancelRunsForJobSchema", "STORE_URL", "authHeader", "headResponse", "MAX_BODY_BYTE_LENGTH", "assertExhaustive", "getApiKey", "fullRequestInit", "requestInitWithCache", "retryCount", "requestHeaders", "responseHeaders", "retryAfter", "resolve", "versionedSchemaMap", "rawBody", "versionedSchema", "delay", "unversionedSchema", "withCache", "cache", "_", "Request", "requestInitWithoutMethod", "Promise", "setTimeout", "fetchHead", "AutoYieldRateLimitError", "parseInt", "jsonBody", "jitterValue", "safeResponseText", "ConcurrencyLimit", "_HttpEndpoint", "RequestWithRawBodySchema", "path", "formatSchemaErrors", "HttpEndpoint", "onRequest", "clonedRequest", "verify", "toJSON", "enabled", "immediateResponseFilter", "respondWith", "skipTriggeringRuns", "rule", "noRuns", "link", "attachToJob", "preprocessRuns", "verifyPayload", "HttpTrigger", "httpEndpoint", "title", "examples", "foo", "parsePayload", "success", "ParsedPayloadSchemaError", "createIOWithIntegrations", "_DynamicTrigger", "acc", "connectionKey", "integration", "auth", "__privateSet", "prop", "Reflect", "get", "target", "deepMergeFilters", "DynamicTrigger", "_options", "attachDynamicTrigger", "channel", "metadata", "authSource", "register", "_EventTrigger", "EventTrigger", "eventTrigger", "cronstrue", "ts", "currentDate", "lastTimestamp", "IntervalTrigger", "ScheduledPayloadSchema", "schedule", "intervalTrigger", "CronTrigger", "humanReadable", "throwExceptionOnParseError", "concat", "cron", "cronTrigger", "DynamicSchedule", "attachDynamicScheduleToJob", "registerWebhookEvent", "REGISTER_WEBHOOK", "RegisterWebhookPayloadSchema", "registerSourceEvent", "REGISTER_SOURCE_EVENT_V2", "EventEmitter", "RegisterSourceEventSchemaV2", "TriggerClient", "_client", "on", "handleRequest", "request", "triggerVersion", "authorization", "endpointId", "ok", "jobs", "sources", "webhooks", "Object", "dynamicTriggers", "registerSourceJob", "dynamicTriggerRegisterSourceJobId", "httpEndpoints", "entries", "dynamicTrigger", "execution", "job", "standardHeaders", "sourceRequestNeedsBody", "sourceRequestInit", "dynamicId", "secret", "inputMetadata", "duplex", "sourceRequest", "webhookRequest", "verified", "runNotification", "rawJson", "defineJob", "existingRegisteredJob", "Job", "defineAuthResolver", "resolver", "defineDynamicSchedule", "defineDynamicTrigger", "defineHttpEndpoint", "suppressWarnings", "existingHttpEndpoint", "endpoint", "defineConcurrencyLimit", "attach", "dynamicTriggerId", "integrations", "run", "updates", "__internal", "attachJobToDynamicTrigger", "attachSource", "registeredSource", "deepMergeOptions", "attachDynamicSchedule", "attachWebhook", "generateEvents", "registeredWebhook", "config", "registerPayload", "crudOptions", "crud", "create", "registerTrigger", "cancelRunsForEvent", "getRun", "cancelRun", "getRuns", "createEphemeralEventDispatcher", "env", "authorized", "localApiKey", "parsedPayload", "abort", "yieldedExecutions", "jobLogLevel", "executionTimeout", "runChunkExecutionLimit", "resolvedConnections", "issues", "ioWithConnections", "isTest", "childError", "reset", "resetAtTimestamp", "YieldExecutionError", "errors", "errorWithStack", "cause", "project", "organization", "slug", "environment", "account", "handler", "handledResponse", "info", "ctx", "handlers", "okResponse", "resolvedAuthResults", "allResolved", "authResolver", "resolvedAuth", "accessToken", "additionalFields", "resolverError", "internal", "startPosition", "start", "notification", "_ExternalSource", "onFailure", "obj2", "obj1", "hasOwnProperty", "mergedOptions", "ExternalSource", "ommited", "registerEvent", "result", "sourceWithoutChannel", "event", "source", "channelWithoutType", "params", "ctx", "updates", "parts", "channel", "push", "integration", "join", "options", "integrationConfig", "metadata", "id", "__name", "ExternalSource", "ExternalSourceTrigger", "constructor", "options", "event", "toJSON", "rule", "name", "payload", "attachToJob", "triggerClient", "params", "preprocessRuns", "verifyPayload", "success", "result", "ommited", "key", "omit", "MISSING_CONNECTION_NOTIFICATION", "missingConnectionNotification", "MissingConnectionNotification", "integrations", "missingConnectionResolvedNotification", "MissingConnectionResolvedNotification", "_MissingConnectionResolvedNotification", "source", "icon", "parsePayload", "properties", "label", "client", "id", "_InvokeTrigger", "MissingConnectionResolvedNotificationPayloadSchema", "text", "__privateGet", "type", "title", "i", "_options", "_WebhookSource", "rawPayload", "ParsedPayloadSchemaError", "parseInvokePayload", "schema", "results", "formatSchemaErrors", "InvokeTrigger", "invokeTrigger", "deepMergeFilters", "createHash", "WebhookSource", "generateEvents", "ctx", "filter", "crud", "register", "registerEvent", "updates", "ctx", "updates", "options", "clonedRequest", "request", "client", "success", "params", "parts", "integrationConfig", "integration", "id", "metadata", "version", "hash", "slice", "WebhookSource", "WebhookTrigger", "constructor", "event", "source", "key", "slugifyId", "toJSON", "title", "name", "payload", "source", "properties", "filter", "eventFilter", "eventWithoutFilter", "attachToJob", "triggerClient", "id", "icon", "event", "verify", "success", "attachWebhook", "params", "options", "config", "__name", "WebhookTrigger", "dotenv", "axios", "handleError", "handleError"]
}
